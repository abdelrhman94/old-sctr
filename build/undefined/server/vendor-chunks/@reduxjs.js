"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@reduxjs";
exports.ids = ["vendor-chunks/@reduxjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/@reduxjs/toolkit/dist/query/react/rtk-query-react.modern.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/dist/query/react/rtk-query-react.modern.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApiProvider: () => (/* binding */ ApiProvider),\n/* harmony export */   NamedSchemaError: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_1__.NamedSchemaError),\n/* harmony export */   QueryStatus: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_1__.QueryStatus),\n/* harmony export */   UNINITIALIZED_VALUE: () => (/* binding */ UNINITIALIZED_VALUE),\n/* harmony export */   _NEVER: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_1__._NEVER),\n/* harmony export */   buildCreateApi: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_1__.buildCreateApi),\n/* harmony export */   copyWithStructuralSharing: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_1__.copyWithStructuralSharing),\n/* harmony export */   coreModule: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_1__.coreModule),\n/* harmony export */   coreModuleName: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_1__.coreModuleName),\n/* harmony export */   createApi: () => (/* binding */ createApi),\n/* harmony export */   defaultSerializeQueryArgs: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_1__.defaultSerializeQueryArgs),\n/* harmony export */   fakeBaseQuery: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_1__.fakeBaseQuery),\n/* harmony export */   fetchBaseQuery: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_1__.fetchBaseQuery),\n/* harmony export */   reactHooksModule: () => (/* binding */ reactHooksModule),\n/* harmony export */   reactHooksModuleName: () => (/* binding */ reactHooksModuleName),\n/* harmony export */   retry: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_1__.retry),\n/* harmony export */   setupListeners: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_1__.setupListeners),\n/* harmony export */   skipToken: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_1__.skipToken)\n/* harmony export */ });\n/* harmony import */ var _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @reduxjs/toolkit/query */ \"(ssr)/./node_modules/@reduxjs/toolkit/dist/query/rtk-query.modern.mjs\");\n/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-redux */ \"(ssr)/./node_modules/react-redux/dist/react-redux.mjs\");\n/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! reselect */ \"(ssr)/./node_modules/reselect/dist/reselect.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\");\n// src/query/react/index.ts\n\n\n// src/query/react/module.ts\n\n\n\n\n// src/query/utils/capitalize.ts\nfunction capitalize(str) {\n  return str.replace(str[0], str[0].toUpperCase());\n}\n\n// src/query/utils/countObjectKeys.ts\nfunction countObjectKeys(obj) {\n  let count = 0;\n  for (const _key in obj) {\n    count++;\n  }\n  return count;\n}\n\n// src/query/endpointDefinitions.ts\nfunction isQueryDefinition(e) {\n  return e.type === \"query\" /* query */;\n}\nfunction isMutationDefinition(e) {\n  return e.type === \"mutation\" /* mutation */;\n}\nfunction isInfiniteQueryDefinition(e) {\n  return e.type === \"infinitequery\" /* infinitequery */;\n}\n\n// src/query/tsHelpers.ts\nfunction safeAssign(target, ...args) {\n  return Object.assign(target, ...args);\n}\n\n// src/query/react/buildHooks.ts\n\n\n\n\n\n// src/query/react/constants.ts\nvar UNINITIALIZED_VALUE = Symbol();\n\n// src/query/react/useSerializedStableValue.ts\n\n\nfunction useStableQueryArgs(queryArgs) {\n  const cache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(queryArgs);\n  const copy = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (0,_reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_1__.copyWithStructuralSharing)(cache.current, queryArgs), [queryArgs]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (cache.current !== copy) {\n      cache.current = copy;\n    }\n  }, [copy]);\n  return copy;\n}\n\n// src/query/react/useShallowStableValue.ts\n\n\nfunction useShallowStableValue(value) {\n  const cache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!(0,react_redux__WEBPACK_IMPORTED_MODULE_2__.shallowEqual)(cache.current, value)) {\n      cache.current = value;\n    }\n  }, [value]);\n  return (0,react_redux__WEBPACK_IMPORTED_MODULE_2__.shallowEqual)(cache.current, value) ? cache.current : value;\n}\n\n// src/query/react/buildHooks.ts\nvar canUseDOM = () => !!(typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\");\nvar isDOM = /* @__PURE__ */ canUseDOM();\nvar isRunningInReactNative = () => typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\";\nvar isReactNative = /* @__PURE__ */ isRunningInReactNative();\nvar getUseIsomorphicLayoutEffect = () => isDOM || isReactNative ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nvar useIsomorphicLayoutEffect = /* @__PURE__ */ getUseIsomorphicLayoutEffect();\nvar noPendingQueryStateSelector = (selected) => {\n  if (selected.isUninitialized) {\n    return {\n      ...selected,\n      isUninitialized: false,\n      isFetching: true,\n      isLoading: selected.data !== void 0 ? false : true,\n      status: _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_1__.QueryStatus.pending\n    };\n  }\n  return selected;\n};\nfunction pick(obj, ...keys) {\n  const ret = {};\n  keys.forEach((key) => {\n    ret[key] = obj[key];\n  });\n  return ret;\n}\nvar COMMON_HOOK_DEBUG_FIELDS = [\"data\", \"status\", \"isLoading\", \"isSuccess\", \"isError\", \"error\"];\nfunction buildHooks({\n  api,\n  moduleOptions: {\n    batch,\n    hooks: {\n      useDispatch,\n      useSelector,\n      useStore\n    },\n    unstable__sideEffectsInRender,\n    createSelector\n  },\n  serializeQueryArgs,\n  context\n}) {\n  const usePossiblyImmediateEffect = unstable__sideEffectsInRender ? (cb) => cb() : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n  return {\n    buildQueryHooks,\n    buildInfiniteQueryHooks,\n    buildMutationHook,\n    usePrefetch\n  };\n  function queryStatePreSelector(currentState, lastResult, queryArgs) {\n    if (lastResult?.endpointName && currentState.isUninitialized) {\n      const {\n        endpointName\n      } = lastResult;\n      const endpointDefinition = context.endpointDefinitions[endpointName];\n      if (queryArgs !== _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_1__.skipToken && serializeQueryArgs({\n        queryArgs: lastResult.originalArgs,\n        endpointDefinition,\n        endpointName\n      }) === serializeQueryArgs({\n        queryArgs,\n        endpointDefinition,\n        endpointName\n      })) lastResult = void 0;\n    }\n    let data = currentState.isSuccess ? currentState.data : lastResult?.data;\n    if (data === void 0) data = currentState.data;\n    const hasData = data !== void 0;\n    const isFetching = currentState.isLoading;\n    const isLoading = (!lastResult || lastResult.isLoading || lastResult.isUninitialized) && !hasData && isFetching;\n    const isSuccess = currentState.isSuccess || hasData && (isFetching && !lastResult?.isError || currentState.isUninitialized);\n    return {\n      ...currentState,\n      data,\n      currentData: currentState.data,\n      isFetching,\n      isLoading,\n      isSuccess\n    };\n  }\n  function infiniteQueryStatePreSelector(currentState, lastResult, queryArgs) {\n    if (lastResult?.endpointName && currentState.isUninitialized) {\n      const {\n        endpointName\n      } = lastResult;\n      const endpointDefinition = context.endpointDefinitions[endpointName];\n      if (queryArgs !== _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_1__.skipToken && serializeQueryArgs({\n        queryArgs: lastResult.originalArgs,\n        endpointDefinition,\n        endpointName\n      }) === serializeQueryArgs({\n        queryArgs,\n        endpointDefinition,\n        endpointName\n      })) lastResult = void 0;\n    }\n    let data = currentState.isSuccess ? currentState.data : lastResult?.data;\n    if (data === void 0) data = currentState.data;\n    const hasData = data !== void 0;\n    const isFetching = currentState.isLoading;\n    const isLoading = (!lastResult || lastResult.isLoading || lastResult.isUninitialized) && !hasData && isFetching;\n    const isSuccess = currentState.isSuccess || isFetching && hasData;\n    return {\n      ...currentState,\n      data,\n      currentData: currentState.data,\n      isFetching,\n      isLoading,\n      isSuccess\n    };\n  }\n  function usePrefetch(endpointName, defaultOptions) {\n    const dispatch = useDispatch();\n    const stableDefaultOptions = useShallowStableValue(defaultOptions);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((arg, options) => dispatch(api.util.prefetch(endpointName, arg, {\n      ...stableDefaultOptions,\n      ...options\n    })), [endpointName, dispatch, stableDefaultOptions]);\n  }\n  function useQuerySubscriptionCommonImpl(endpointName, arg, {\n    refetchOnReconnect,\n    refetchOnFocus,\n    refetchOnMountOrArgChange,\n    skip = false,\n    pollingInterval = 0,\n    skipPollingIfUnfocused = false,\n    ...rest\n  } = {}) {\n    const {\n      initiate\n    } = api.endpoints[endpointName];\n    const dispatch = useDispatch();\n    const subscriptionSelectorsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(void 0);\n    if (!subscriptionSelectorsRef.current) {\n      const returnedValue = dispatch(api.internalActions.internal_getRTKQSubscriptions());\n      if (true) {\n        if (typeof returnedValue !== \"object\" || typeof returnedValue?.type === \"string\") {\n          throw new Error( false ? 0 : `Warning: Middleware for RTK-Query API at reducerPath \"${api.reducerPath}\" has not been added to the store.\n    You must add the middleware for RTK-Query to function correctly!`);\n        }\n      }\n      subscriptionSelectorsRef.current = returnedValue;\n    }\n    const stableArg = useStableQueryArgs(skip ? _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_1__.skipToken : arg);\n    const stableSubscriptionOptions = useShallowStableValue({\n      refetchOnReconnect,\n      refetchOnFocus,\n      pollingInterval,\n      skipPollingIfUnfocused\n    });\n    const initialPageParam = rest.initialPageParam;\n    const stableInitialPageParam = useShallowStableValue(initialPageParam);\n    const promiseRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(void 0);\n    let {\n      queryCacheKey,\n      requestId\n    } = promiseRef.current || {};\n    let currentRenderHasSubscription = false;\n    if (queryCacheKey && requestId) {\n      currentRenderHasSubscription = subscriptionSelectorsRef.current.isRequestSubscribed(queryCacheKey, requestId);\n    }\n    const subscriptionRemoved = !currentRenderHasSubscription && promiseRef.current !== void 0;\n    usePossiblyImmediateEffect(() => {\n      if (subscriptionRemoved) {\n        promiseRef.current = void 0;\n      }\n    }, [subscriptionRemoved]);\n    usePossiblyImmediateEffect(() => {\n      const lastPromise = promiseRef.current;\n      if (typeof process !== \"undefined\" && \"development\" === \"removeMeOnCompilation\") {}\n      if (stableArg === _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_1__.skipToken) {\n        lastPromise?.unsubscribe();\n        promiseRef.current = void 0;\n        return;\n      }\n      const lastSubscriptionOptions = promiseRef.current?.subscriptionOptions;\n      if (!lastPromise || lastPromise.arg !== stableArg) {\n        lastPromise?.unsubscribe();\n        const promise = dispatch(initiate(stableArg, {\n          subscriptionOptions: stableSubscriptionOptions,\n          forceRefetch: refetchOnMountOrArgChange,\n          ...isInfiniteQueryDefinition(context.endpointDefinitions[endpointName]) ? {\n            initialPageParam: stableInitialPageParam\n          } : {}\n        }));\n        promiseRef.current = promise;\n      } else if (stableSubscriptionOptions !== lastSubscriptionOptions) {\n        lastPromise.updateSubscriptionOptions(stableSubscriptionOptions);\n      }\n    }, [dispatch, initiate, refetchOnMountOrArgChange, stableArg, stableSubscriptionOptions, subscriptionRemoved, stableInitialPageParam, endpointName]);\n    return [promiseRef, dispatch, initiate, stableSubscriptionOptions];\n  }\n  function buildUseQueryState(endpointName, preSelector) {\n    const useQueryState = (arg, {\n      skip = false,\n      selectFromResult\n    } = {}) => {\n      const {\n        select\n      } = api.endpoints[endpointName];\n      const stableArg = useStableQueryArgs(skip ? _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_1__.skipToken : arg);\n      const lastValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(void 0);\n      const selectDefaultResult = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (\n        // Normally ts-ignores are bad and should be avoided, but we're\n        // already casting this selector to be `Selector<any>` anyway,\n        // so the inconsistencies don't matter here\n        // @ts-ignore\n        createSelector([\n          // @ts-ignore\n          select(stableArg),\n          (_, lastResult) => lastResult,\n          (_) => stableArg\n        ], preSelector, {\n          memoizeOptions: {\n            resultEqualityCheck: react_redux__WEBPACK_IMPORTED_MODULE_2__.shallowEqual\n          }\n        })\n      ), [select, stableArg]);\n      const querySelector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => selectFromResult ? createSelector([selectDefaultResult], selectFromResult, {\n        devModeChecks: {\n          identityFunctionCheck: \"never\"\n        }\n      }) : selectDefaultResult, [selectDefaultResult, selectFromResult]);\n      const currentState = useSelector((state) => querySelector(state, lastValue.current), react_redux__WEBPACK_IMPORTED_MODULE_2__.shallowEqual);\n      const store = useStore();\n      const newLastValue = selectDefaultResult(store.getState(), lastValue.current);\n      useIsomorphicLayoutEffect(() => {\n        lastValue.current = newLastValue;\n      }, [newLastValue]);\n      return currentState;\n    };\n    return useQueryState;\n  }\n  function usePromiseRefUnsubscribeOnUnmount(promiseRef) {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n      return () => {\n        promiseRef.current?.unsubscribe?.();\n        promiseRef.current = void 0;\n      };\n    }, [promiseRef]);\n  }\n  function refetchOrErrorIfUnmounted(promiseRef) {\n    if (!promiseRef.current) throw new Error( false ? 0 : \"Cannot refetch a query that has not been started yet.\");\n    return promiseRef.current.refetch();\n  }\n  function buildQueryHooks(endpointName) {\n    const useQuerySubscription = (arg, options = {}) => {\n      const [promiseRef] = useQuerySubscriptionCommonImpl(endpointName, arg, options);\n      usePromiseRefUnsubscribeOnUnmount(promiseRef);\n      return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n        /**\n         * A method to manually refetch data for the query\n         */\n        refetch: () => refetchOrErrorIfUnmounted(promiseRef)\n      }), [promiseRef]);\n    };\n    const useLazyQuerySubscription = ({\n      refetchOnReconnect,\n      refetchOnFocus,\n      pollingInterval = 0,\n      skipPollingIfUnfocused = false\n    } = {}) => {\n      const {\n        initiate\n      } = api.endpoints[endpointName];\n      const dispatch = useDispatch();\n      const [arg, setArg] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(UNINITIALIZED_VALUE);\n      const promiseRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(void 0);\n      const stableSubscriptionOptions = useShallowStableValue({\n        refetchOnReconnect,\n        refetchOnFocus,\n        pollingInterval,\n        skipPollingIfUnfocused\n      });\n      usePossiblyImmediateEffect(() => {\n        const lastSubscriptionOptions = promiseRef.current?.subscriptionOptions;\n        if (stableSubscriptionOptions !== lastSubscriptionOptions) {\n          promiseRef.current?.updateSubscriptionOptions(stableSubscriptionOptions);\n        }\n      }, [stableSubscriptionOptions]);\n      const subscriptionOptionsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(stableSubscriptionOptions);\n      usePossiblyImmediateEffect(() => {\n        subscriptionOptionsRef.current = stableSubscriptionOptions;\n      }, [stableSubscriptionOptions]);\n      const trigger = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(arg2, preferCacheValue = false) {\n        let promise;\n        batch(() => {\n          promiseRef.current?.unsubscribe();\n          promiseRef.current = promise = dispatch(initiate(arg2, {\n            subscriptionOptions: subscriptionOptionsRef.current,\n            forceRefetch: !preferCacheValue\n          }));\n          setArg(arg2);\n        });\n        return promise;\n      }, [dispatch, initiate]);\n      const reset = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        if (promiseRef.current?.queryCacheKey) {\n          dispatch(api.internalActions.removeQueryResult({\n            queryCacheKey: promiseRef.current?.queryCacheKey\n          }));\n        }\n      }, [dispatch]);\n      (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        return () => {\n          promiseRef?.current?.unsubscribe();\n        };\n      }, []);\n      (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (arg !== UNINITIALIZED_VALUE && !promiseRef.current) {\n          trigger(arg, true);\n        }\n      }, [arg, trigger]);\n      return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => [trigger, arg, {\n        reset\n      }], [trigger, arg, reset]);\n    };\n    const useQueryState = buildUseQueryState(endpointName, queryStatePreSelector);\n    return {\n      useQueryState,\n      useQuerySubscription,\n      useLazyQuerySubscription,\n      useLazyQuery(options) {\n        const [trigger, arg, {\n          reset\n        }] = useLazyQuerySubscription(options);\n        const queryStateResults = useQueryState(arg, {\n          ...options,\n          skip: arg === UNINITIALIZED_VALUE\n        });\n        const info = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n          lastArg: arg\n        }), [arg]);\n        return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => [trigger, {\n          ...queryStateResults,\n          reset\n        }, info], [trigger, queryStateResults, reset, info]);\n      },\n      useQuery(arg, options) {\n        const querySubscriptionResults = useQuerySubscription(arg, options);\n        const queryStateResults = useQueryState(arg, {\n          selectFromResult: arg === _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_1__.skipToken || options?.skip ? void 0 : noPendingQueryStateSelector,\n          ...options\n        });\n        const debugValue = pick(queryStateResults, ...COMMON_HOOK_DEBUG_FIELDS);\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(debugValue);\n        return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n          ...queryStateResults,\n          ...querySubscriptionResults\n        }), [queryStateResults, querySubscriptionResults]);\n      }\n    };\n  }\n  function buildInfiniteQueryHooks(endpointName) {\n    const useInfiniteQuerySubscription = (arg, options = {}) => {\n      const [promiseRef, dispatch, initiate, stableSubscriptionOptions] = useQuerySubscriptionCommonImpl(endpointName, arg, options);\n      const subscriptionOptionsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(stableSubscriptionOptions);\n      usePossiblyImmediateEffect(() => {\n        subscriptionOptionsRef.current = stableSubscriptionOptions;\n      }, [stableSubscriptionOptions]);\n      const trigger = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(arg2, direction) {\n        let promise;\n        batch(() => {\n          promiseRef.current?.unsubscribe();\n          promiseRef.current = promise = dispatch(initiate(arg2, {\n            subscriptionOptions: subscriptionOptionsRef.current,\n            direction\n          }));\n        });\n        return promise;\n      }, [promiseRef, dispatch, initiate]);\n      usePromiseRefUnsubscribeOnUnmount(promiseRef);\n      const stableArg = useStableQueryArgs(options.skip ? _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_1__.skipToken : arg);\n      const refetch = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => refetchOrErrorIfUnmounted(promiseRef), [promiseRef]);\n      return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        const fetchNextPage = () => {\n          return trigger(stableArg, \"forward\");\n        };\n        const fetchPreviousPage = () => {\n          return trigger(stableArg, \"backward\");\n        };\n        return {\n          trigger,\n          /**\n           * A method to manually refetch data for the query\n           */\n          refetch,\n          fetchNextPage,\n          fetchPreviousPage\n        };\n      }, [refetch, trigger, stableArg]);\n    };\n    const useInfiniteQueryState = buildUseQueryState(endpointName, infiniteQueryStatePreSelector);\n    return {\n      useInfiniteQueryState,\n      useInfiniteQuerySubscription,\n      useInfiniteQuery(arg, options) {\n        const {\n          refetch,\n          fetchNextPage,\n          fetchPreviousPage\n        } = useInfiniteQuerySubscription(arg, options);\n        const queryStateResults = useInfiniteQueryState(arg, {\n          selectFromResult: arg === _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_1__.skipToken || options?.skip ? void 0 : noPendingQueryStateSelector,\n          ...options\n        });\n        const debugValue = pick(queryStateResults, ...COMMON_HOOK_DEBUG_FIELDS, \"hasNextPage\", \"hasPreviousPage\");\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(debugValue);\n        return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n          ...queryStateResults,\n          fetchNextPage,\n          fetchPreviousPage,\n          refetch\n        }), [queryStateResults, fetchNextPage, fetchPreviousPage, refetch]);\n      }\n    };\n  }\n  function buildMutationHook(name) {\n    return ({\n      selectFromResult,\n      fixedCacheKey\n    } = {}) => {\n      const {\n        select,\n        initiate\n      } = api.endpoints[name];\n      const dispatch = useDispatch();\n      const [promise, setPromise] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n      (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => () => {\n        if (!promise?.arg.fixedCacheKey) {\n          promise?.reset();\n        }\n      }, [promise]);\n      const triggerMutation = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(arg) {\n        const promise2 = dispatch(initiate(arg, {\n          fixedCacheKey\n        }));\n        setPromise(promise2);\n        return promise2;\n      }, [dispatch, initiate, fixedCacheKey]);\n      const {\n        requestId\n      } = promise || {};\n      const selectDefaultResult = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => select({\n        fixedCacheKey,\n        requestId: promise?.requestId\n      }), [fixedCacheKey, promise, select]);\n      const mutationSelector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => selectFromResult ? createSelector([selectDefaultResult], selectFromResult) : selectDefaultResult, [selectFromResult, selectDefaultResult]);\n      const currentState = useSelector(mutationSelector, react_redux__WEBPACK_IMPORTED_MODULE_2__.shallowEqual);\n      const originalArgs = fixedCacheKey == null ? promise?.arg.originalArgs : void 0;\n      const reset = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        batch(() => {\n          if (promise) {\n            setPromise(void 0);\n          }\n          if (fixedCacheKey) {\n            dispatch(api.internalActions.removeMutationResult({\n              requestId,\n              fixedCacheKey\n            }));\n          }\n        });\n      }, [dispatch, fixedCacheKey, promise, requestId]);\n      const debugValue = pick(currentState, ...COMMON_HOOK_DEBUG_FIELDS, \"endpointName\");\n      (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(debugValue);\n      const finalState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n        ...currentState,\n        originalArgs,\n        reset\n      }), [currentState, originalArgs, reset]);\n      return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => [triggerMutation, finalState], [triggerMutation, finalState]);\n    };\n  }\n}\n\n// src/query/react/module.ts\nvar reactHooksModuleName = /* @__PURE__ */ Symbol();\nvar reactHooksModule = ({\n  batch = react_redux__WEBPACK_IMPORTED_MODULE_2__.batch,\n  hooks = {\n    useDispatch: react_redux__WEBPACK_IMPORTED_MODULE_2__.useDispatch,\n    useSelector: react_redux__WEBPACK_IMPORTED_MODULE_2__.useSelector,\n    useStore: react_redux__WEBPACK_IMPORTED_MODULE_2__.useStore\n  },\n  createSelector = reselect__WEBPACK_IMPORTED_MODULE_3__.createSelector,\n  unstable__sideEffectsInRender = false,\n  ...rest\n} = {}) => {\n  if (true) {\n    const hookNames = [\"useDispatch\", \"useSelector\", \"useStore\"];\n    let warned = false;\n    for (const hookName of hookNames) {\n      if (countObjectKeys(rest) > 0) {\n        if (rest[hookName]) {\n          if (!warned) {\n            console.warn(\"As of RTK 2.0, the hooks now need to be specified as one object, provided under a `hooks` key:\\n`reactHooksModule({ hooks: { useDispatch, useSelector, useStore } })`\");\n            warned = true;\n          }\n        }\n        hooks[hookName] = rest[hookName];\n      }\n      if (typeof hooks[hookName] !== \"function\") {\n        throw new Error( false ? 0 : `When using custom hooks for context, all ${hookNames.length} hooks need to be provided: ${hookNames.join(\", \")}.\nHook ${hookName} was either not provided or not a function.`);\n      }\n    }\n  }\n  return {\n    name: reactHooksModuleName,\n    init(api, {\n      serializeQueryArgs\n    }, context) {\n      const anyApi = api;\n      const {\n        buildQueryHooks,\n        buildInfiniteQueryHooks,\n        buildMutationHook,\n        usePrefetch\n      } = buildHooks({\n        api,\n        moduleOptions: {\n          batch,\n          hooks,\n          unstable__sideEffectsInRender,\n          createSelector\n        },\n        serializeQueryArgs,\n        context\n      });\n      safeAssign(anyApi, {\n        usePrefetch\n      });\n      safeAssign(context, {\n        batch\n      });\n      return {\n        injectEndpoint(endpointName, definition) {\n          if (isQueryDefinition(definition)) {\n            const {\n              useQuery,\n              useLazyQuery,\n              useLazyQuerySubscription,\n              useQueryState,\n              useQuerySubscription\n            } = buildQueryHooks(endpointName);\n            safeAssign(anyApi.endpoints[endpointName], {\n              useQuery,\n              useLazyQuery,\n              useLazyQuerySubscription,\n              useQueryState,\n              useQuerySubscription\n            });\n            api[`use${capitalize(endpointName)}Query`] = useQuery;\n            api[`useLazy${capitalize(endpointName)}Query`] = useLazyQuery;\n          }\n          if (isMutationDefinition(definition)) {\n            const useMutation = buildMutationHook(endpointName);\n            safeAssign(anyApi.endpoints[endpointName], {\n              useMutation\n            });\n            api[`use${capitalize(endpointName)}Mutation`] = useMutation;\n          } else if (isInfiniteQueryDefinition(definition)) {\n            const {\n              useInfiniteQuery,\n              useInfiniteQuerySubscription,\n              useInfiniteQueryState\n            } = buildInfiniteQueryHooks(endpointName);\n            safeAssign(anyApi.endpoints[endpointName], {\n              useInfiniteQuery,\n              useInfiniteQuerySubscription,\n              useInfiniteQueryState\n            });\n            api[`use${capitalize(endpointName)}InfiniteQuery`] = useInfiniteQuery;\n          }\n        }\n      };\n    }\n  };\n};\n\n// src/query/react/index.ts\n\n\n// src/query/react/ApiProvider.tsx\n\n\n\n\n\n\nfunction ApiProvider(props) {\n  const context = props.context || react_redux__WEBPACK_IMPORTED_MODULE_2__.ReactReduxContext;\n  const existingContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(context);\n  if (existingContext) {\n    throw new Error( false ? 0 : \"Existing Redux context detected. If you already have a store set up, please use the traditional Redux setup.\");\n  }\n  const [store] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_4__.configureStore)({\n    reducer: {\n      [props.api.reducerPath]: props.api.reducer\n    },\n    middleware: (gDM) => gDM().concat(props.api.middleware)\n  }));\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => props.setupListeners === false ? void 0 : (0,_reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_1__.setupListeners)(store.dispatch, props.setupListeners), [props.setupListeners, store.dispatch]);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_redux__WEBPACK_IMPORTED_MODULE_2__.Provider, { store, context }, props.children);\n}\n\n// src/query/react/index.ts\nvar createApi = /* @__PURE__ */ (0,_reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_1__.buildCreateApi)((0,_reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_1__.coreModule)(), reactHooksModule());\n\n//# sourceMappingURL=rtk-query-react.modern.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9kaXN0L3F1ZXJ5L3JlYWN0L3J0ay1xdWVyeS1yZWFjdC5tb2Rlcm4ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDb0U7O0FBRXBFO0FBQ3NGO0FBQzZDO0FBQ3RFOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ3lJO0FBQ3pFO0FBQytFO0FBQ25GOztBQUU1RDtBQUNBOztBQUVBO0FBQ21EO0FBQ2dCO0FBQ25FO0FBQ0EsZ0JBQWdCLDZDQUFNO0FBQ3RCLGVBQWUsOENBQU8sT0FBTyxpRkFBeUI7QUFDdEQsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ21FO0FBQ3hCO0FBQzNDO0FBQ0EsZ0JBQWdCLDZDQUFPO0FBQ3ZCLEVBQUUsZ0RBQVU7QUFDWixTQUFTLHlEQUFZO0FBQ3JCO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsU0FBUyx5REFBWTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGtEQUFlLEdBQUcsNENBQVU7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0RBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7QUFDRCxvRkFBb0YsNENBQVU7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSx3QkFBd0IsNkRBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esd0JBQXdCLDZEQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtEQUFXO0FBQ3RCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHFDQUFxQyw2Q0FBTztBQUM1QztBQUNBO0FBQ0EsVUFBVSxJQUFxQztBQUMvQztBQUNBLDBCQUEwQixNQUFxQyxHQUFHLENBQTJCLDREQUE0RCxnQkFBZ0I7QUFDeks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCw2REFBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx1QkFBdUIsNkNBQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNENBQTRDLGFBQW9CLDhCQUE4QixFQUV2RjtBQUNQLHdCQUF3Qiw2REFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFJO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUixrREFBa0QsNkRBQVM7QUFDM0Qsd0JBQXdCLDZDQUFPO0FBQy9CLGtDQUFrQyw4Q0FBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHFEQUFhO0FBQzlDO0FBQ0EsU0FBUztBQUNUO0FBQ0EsNEJBQTRCLDhDQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCwyRkFBMkYscURBQWE7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0RBQVU7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNkNBQTZDLE1BQXFDLEdBQUcsQ0FBNEI7QUFDakg7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQSxhQUFhLDhDQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBSTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSw0QkFBNEIsK0NBQVE7QUFDcEMseUJBQXlCLDZDQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxxQ0FBcUMsNkNBQU87QUFDNUM7QUFDQTtBQUNBLE9BQU87QUFDUCxzQkFBc0Isa0RBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLG9CQUFvQixrREFBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1AsTUFBTSxnREFBVTtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTSxnREFBVTtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsYUFBYSw4Q0FBUTtBQUNyQjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHFCQUFxQiw4Q0FBUTtBQUM3QjtBQUNBLFNBQVM7QUFDVCxlQUFlLDhDQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw2REFBUztBQUM3QztBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVEsb0RBQWE7QUFDckIsZUFBZSw4Q0FBUTtBQUN2QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0EscUNBQXFDLDZDQUFPO0FBQzVDO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asc0JBQXNCLGtEQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQSwwREFBMEQsNkRBQVM7QUFDbkUsc0JBQXNCLGtEQUFXO0FBQ2pDLGFBQWEsOENBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0Esb0NBQW9DLDZEQUFTO0FBQzdDO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUSxvREFBYTtBQUNyQixlQUFlLDhDQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFJO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esb0NBQW9DLCtDQUFRO0FBQzVDLE1BQU0sZ0RBQVU7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDhCQUE4QixrREFBVztBQUN6QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQVE7QUFDUixrQ0FBa0MsOENBQVE7QUFDMUM7QUFDQTtBQUNBLE9BQU87QUFDUCwrQkFBK0IsOENBQVE7QUFDdkMseURBQXlELHFEQUFhO0FBQ3RFO0FBQ0Esb0JBQW9CLGtEQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsTUFBTSxvREFBYTtBQUNuQix5QkFBeUIsOENBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGFBQWEsOENBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOENBQU87QUFDakI7QUFDQSxpQkFBaUIsb0RBQWE7QUFDOUIsaUJBQWlCLG9EQUFhO0FBQzlCLGNBQWMsaURBQVU7QUFDeEIsR0FBRztBQUNILG1CQUFtQixvREFBZTtBQUNsQztBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ04sTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4SUFBOEksU0FBUyxzQ0FBc0M7QUFDN0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE1BQXFDLEdBQUcsQ0FBNEIsK0NBQStDLGtCQUFrQiw2QkFBNkIscUJBQXFCO0FBQy9NLE9BQU8sVUFBVTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isc0JBQXNCLHlCQUF5QjtBQUMvQywwQkFBMEIseUJBQXlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isc0JBQXNCLHlCQUF5QjtBQUMvQyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isc0JBQXNCLHlCQUF5QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDdUM7O0FBRXZDO0FBQ3NHO0FBQ25FO0FBQ2E7QUFDakI7QUFDMkI7QUFDRjtBQUN4RDtBQUNBLG1DQUFtQywwREFBaUI7QUFDcEQsMEJBQTBCLGlEQUFVO0FBQ3BDO0FBQ0Esb0JBQW9CLE1BQXFDLEdBQUcsQ0FBNEI7QUFDeEY7QUFDQSxrQkFBa0IsMkNBQWMsT0FBTyxnRUFBYztBQUNyRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVUsaURBQWlELHNFQUFjO0FBQzNFLHlCQUF5QixnREFBbUIsQ0FBQyxpREFBUSxJQUFJLGdCQUFnQjtBQUN6RTs7QUFFQTtBQUNBLGdDQUFnQyxzRUFBYyxDQUFDLGtFQUFVO0FBT3ZEO0FBQ0YiLCJzb3VyY2VzIjpbIi9ob21lL3Byb2plY3Qvbm9kZV9tb2R1bGVzL0ByZWR1eGpzL3Rvb2xraXQvZGlzdC9xdWVyeS9yZWFjdC9ydGstcXVlcnktcmVhY3QubW9kZXJuLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvcXVlcnkvcmVhY3QvaW5kZXgudHNcbmltcG9ydCB7IGJ1aWxkQ3JlYXRlQXBpLCBjb3JlTW9kdWxlIH0gZnJvbSBcIkByZWR1eGpzL3Rvb2xraXQvcXVlcnlcIjtcblxuLy8gc3JjL3F1ZXJ5L3JlYWN0L21vZHVsZS50c1xuaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTMgfSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdFwiO1xuaW1wb3J0IHsgYmF0Y2ggYXMgcnJCYXRjaCwgdXNlRGlzcGF0Y2ggYXMgcnJVc2VEaXNwYXRjaCwgdXNlU2VsZWN0b3IgYXMgcnJVc2VTZWxlY3RvciwgdXNlU3RvcmUgYXMgcnJVc2VTdG9yZSB9IGZyb20gXCJyZWFjdC1yZWR1eFwiO1xuaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3IgYXMgX2NyZWF0ZVNlbGVjdG9yIH0gZnJvbSBcInJlc2VsZWN0XCI7XG5cbi8vIHNyYy9xdWVyeS91dGlscy9jYXBpdGFsaXplLnRzXG5mdW5jdGlvbiBjYXBpdGFsaXplKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2Uoc3RyWzBdLCBzdHJbMF0udG9VcHBlckNhc2UoKSk7XG59XG5cbi8vIHNyYy9xdWVyeS91dGlscy9jb3VudE9iamVjdEtleXMudHNcbmZ1bmN0aW9uIGNvdW50T2JqZWN0S2V5cyhvYmopIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgZm9yIChjb25zdCBfa2V5IGluIG9iaikge1xuICAgIGNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufVxuXG4vLyBzcmMvcXVlcnkvZW5kcG9pbnREZWZpbml0aW9ucy50c1xuZnVuY3Rpb24gaXNRdWVyeURlZmluaXRpb24oZSkge1xuICByZXR1cm4gZS50eXBlID09PSBcInF1ZXJ5XCIgLyogcXVlcnkgKi87XG59XG5mdW5jdGlvbiBpc011dGF0aW9uRGVmaW5pdGlvbihlKSB7XG4gIHJldHVybiBlLnR5cGUgPT09IFwibXV0YXRpb25cIiAvKiBtdXRhdGlvbiAqLztcbn1cbmZ1bmN0aW9uIGlzSW5maW5pdGVRdWVyeURlZmluaXRpb24oZSkge1xuICByZXR1cm4gZS50eXBlID09PSBcImluZmluaXRlcXVlcnlcIiAvKiBpbmZpbml0ZXF1ZXJ5ICovO1xufVxuXG4vLyBzcmMvcXVlcnkvdHNIZWxwZXJzLnRzXG5mdW5jdGlvbiBzYWZlQXNzaWduKHRhcmdldCwgLi4uYXJncykge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih0YXJnZXQsIC4uLmFyZ3MpO1xufVxuXG4vLyBzcmMvcXVlcnkvcmVhY3QvYnVpbGRIb29rcy50c1xuaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSwgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTIgfSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdFwiO1xuaW1wb3J0IHsgUXVlcnlTdGF0dXMsIHNraXBUb2tlbiB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0L3F1ZXJ5XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRGVidWdWYWx1ZSwgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDMsIHVzZUxheW91dEVmZmVjdCwgdXNlTWVtbyBhcyB1c2VNZW1vMiwgdXNlUmVmIGFzIHVzZVJlZjMsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBzaGFsbG93RXF1YWwgYXMgc2hhbGxvd0VxdWFsMiB9IGZyb20gXCJyZWFjdC1yZWR1eFwiO1xuXG4vLyBzcmMvcXVlcnkvcmVhY3QvY29uc3RhbnRzLnRzXG52YXIgVU5JTklUSUFMSVpFRF9WQUxVRSA9IFN5bWJvbCgpO1xuXG4vLyBzcmMvcXVlcnkvcmVhY3QvdXNlU2VyaWFsaXplZFN0YWJsZVZhbHVlLnRzXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlTWVtbyB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgY29weVdpdGhTdHJ1Y3R1cmFsU2hhcmluZyB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0L3F1ZXJ5XCI7XG5mdW5jdGlvbiB1c2VTdGFibGVRdWVyeUFyZ3MocXVlcnlBcmdzKSB7XG4gIGNvbnN0IGNhY2hlID0gdXNlUmVmKHF1ZXJ5QXJncyk7XG4gIGNvbnN0IGNvcHkgPSB1c2VNZW1vKCgpID0+IGNvcHlXaXRoU3RydWN0dXJhbFNoYXJpbmcoY2FjaGUuY3VycmVudCwgcXVlcnlBcmdzKSwgW3F1ZXJ5QXJnc10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChjYWNoZS5jdXJyZW50ICE9PSBjb3B5KSB7XG4gICAgICBjYWNoZS5jdXJyZW50ID0gY29weTtcbiAgICB9XG4gIH0sIFtjb3B5XSk7XG4gIHJldHVybiBjb3B5O1xufVxuXG4vLyBzcmMvcXVlcnkvcmVhY3QvdXNlU2hhbGxvd1N0YWJsZVZhbHVlLnRzXG5pbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MiwgdXNlUmVmIGFzIHVzZVJlZjIgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHNoYWxsb3dFcXVhbCB9IGZyb20gXCJyZWFjdC1yZWR1eFwiO1xuZnVuY3Rpb24gdXNlU2hhbGxvd1N0YWJsZVZhbHVlKHZhbHVlKSB7XG4gIGNvbnN0IGNhY2hlID0gdXNlUmVmMih2YWx1ZSk7XG4gIHVzZUVmZmVjdDIoKCkgPT4ge1xuICAgIGlmICghc2hhbGxvd0VxdWFsKGNhY2hlLmN1cnJlbnQsIHZhbHVlKSkge1xuICAgICAgY2FjaGUuY3VycmVudCA9IHZhbHVlO1xuICAgIH1cbiAgfSwgW3ZhbHVlXSk7XG4gIHJldHVybiBzaGFsbG93RXF1YWwoY2FjaGUuY3VycmVudCwgdmFsdWUpID8gY2FjaGUuY3VycmVudCA6IHZhbHVlO1xufVxuXG4vLyBzcmMvcXVlcnkvcmVhY3QvYnVpbGRIb29rcy50c1xudmFyIGNhblVzZURPTSA9ICgpID0+ICEhKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09IFwidW5kZWZpbmVkXCIpO1xudmFyIGlzRE9NID0gLyogQF9fUFVSRV9fICovIGNhblVzZURPTSgpO1xudmFyIGlzUnVubmluZ0luUmVhY3ROYXRpdmUgPSAoKSA9PiB0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIG5hdmlnYXRvci5wcm9kdWN0ID09PSBcIlJlYWN0TmF0aXZlXCI7XG52YXIgaXNSZWFjdE5hdGl2ZSA9IC8qIEBfX1BVUkVfXyAqLyBpc1J1bm5pbmdJblJlYWN0TmF0aXZlKCk7XG52YXIgZ2V0VXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9ICgpID0+IGlzRE9NIHx8IGlzUmVhY3ROYXRpdmUgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3QzO1xudmFyIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSAvKiBAX19QVVJFX18gKi8gZ2V0VXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgpO1xudmFyIG5vUGVuZGluZ1F1ZXJ5U3RhdGVTZWxlY3RvciA9IChzZWxlY3RlZCkgPT4ge1xuICBpZiAoc2VsZWN0ZWQuaXNVbmluaXRpYWxpemVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnNlbGVjdGVkLFxuICAgICAgaXNVbmluaXRpYWxpemVkOiBmYWxzZSxcbiAgICAgIGlzRmV0Y2hpbmc6IHRydWUsXG4gICAgICBpc0xvYWRpbmc6IHNlbGVjdGVkLmRhdGEgIT09IHZvaWQgMCA/IGZhbHNlIDogdHJ1ZSxcbiAgICAgIHN0YXR1czogUXVlcnlTdGF0dXMucGVuZGluZ1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHNlbGVjdGVkO1xufTtcbmZ1bmN0aW9uIHBpY2sob2JqLCAuLi5rZXlzKSB7XG4gIGNvbnN0IHJldCA9IHt9O1xuICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIHJldFtrZXldID0gb2JqW2tleV07XG4gIH0pO1xuICByZXR1cm4gcmV0O1xufVxudmFyIENPTU1PTl9IT09LX0RFQlVHX0ZJRUxEUyA9IFtcImRhdGFcIiwgXCJzdGF0dXNcIiwgXCJpc0xvYWRpbmdcIiwgXCJpc1N1Y2Nlc3NcIiwgXCJpc0Vycm9yXCIsIFwiZXJyb3JcIl07XG5mdW5jdGlvbiBidWlsZEhvb2tzKHtcbiAgYXBpLFxuICBtb2R1bGVPcHRpb25zOiB7XG4gICAgYmF0Y2gsXG4gICAgaG9va3M6IHtcbiAgICAgIHVzZURpc3BhdGNoLFxuICAgICAgdXNlU2VsZWN0b3IsXG4gICAgICB1c2VTdG9yZVxuICAgIH0sXG4gICAgdW5zdGFibGVfX3NpZGVFZmZlY3RzSW5SZW5kZXIsXG4gICAgY3JlYXRlU2VsZWN0b3JcbiAgfSxcbiAgc2VyaWFsaXplUXVlcnlBcmdzLFxuICBjb250ZXh0XG59KSB7XG4gIGNvbnN0IHVzZVBvc3NpYmx5SW1tZWRpYXRlRWZmZWN0ID0gdW5zdGFibGVfX3NpZGVFZmZlY3RzSW5SZW5kZXIgPyAoY2IpID0+IGNiKCkgOiB1c2VFZmZlY3QzO1xuICByZXR1cm4ge1xuICAgIGJ1aWxkUXVlcnlIb29rcyxcbiAgICBidWlsZEluZmluaXRlUXVlcnlIb29rcyxcbiAgICBidWlsZE11dGF0aW9uSG9vayxcbiAgICB1c2VQcmVmZXRjaFxuICB9O1xuICBmdW5jdGlvbiBxdWVyeVN0YXRlUHJlU2VsZWN0b3IoY3VycmVudFN0YXRlLCBsYXN0UmVzdWx0LCBxdWVyeUFyZ3MpIHtcbiAgICBpZiAobGFzdFJlc3VsdD8uZW5kcG9pbnROYW1lICYmIGN1cnJlbnRTdGF0ZS5pc1VuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZW5kcG9pbnROYW1lXG4gICAgICB9ID0gbGFzdFJlc3VsdDtcbiAgICAgIGNvbnN0IGVuZHBvaW50RGVmaW5pdGlvbiA9IGNvbnRleHQuZW5kcG9pbnREZWZpbml0aW9uc1tlbmRwb2ludE5hbWVdO1xuICAgICAgaWYgKHF1ZXJ5QXJncyAhPT0gc2tpcFRva2VuICYmIHNlcmlhbGl6ZVF1ZXJ5QXJncyh7XG4gICAgICAgIHF1ZXJ5QXJnczogbGFzdFJlc3VsdC5vcmlnaW5hbEFyZ3MsXG4gICAgICAgIGVuZHBvaW50RGVmaW5pdGlvbixcbiAgICAgICAgZW5kcG9pbnROYW1lXG4gICAgICB9KSA9PT0gc2VyaWFsaXplUXVlcnlBcmdzKHtcbiAgICAgICAgcXVlcnlBcmdzLFxuICAgICAgICBlbmRwb2ludERlZmluaXRpb24sXG4gICAgICAgIGVuZHBvaW50TmFtZVxuICAgICAgfSkpIGxhc3RSZXN1bHQgPSB2b2lkIDA7XG4gICAgfVxuICAgIGxldCBkYXRhID0gY3VycmVudFN0YXRlLmlzU3VjY2VzcyA/IGN1cnJlbnRTdGF0ZS5kYXRhIDogbGFzdFJlc3VsdD8uZGF0YTtcbiAgICBpZiAoZGF0YSA9PT0gdm9pZCAwKSBkYXRhID0gY3VycmVudFN0YXRlLmRhdGE7XG4gICAgY29uc3QgaGFzRGF0YSA9IGRhdGEgIT09IHZvaWQgMDtcbiAgICBjb25zdCBpc0ZldGNoaW5nID0gY3VycmVudFN0YXRlLmlzTG9hZGluZztcbiAgICBjb25zdCBpc0xvYWRpbmcgPSAoIWxhc3RSZXN1bHQgfHwgbGFzdFJlc3VsdC5pc0xvYWRpbmcgfHwgbGFzdFJlc3VsdC5pc1VuaW5pdGlhbGl6ZWQpICYmICFoYXNEYXRhICYmIGlzRmV0Y2hpbmc7XG4gICAgY29uc3QgaXNTdWNjZXNzID0gY3VycmVudFN0YXRlLmlzU3VjY2VzcyB8fCBoYXNEYXRhICYmIChpc0ZldGNoaW5nICYmICFsYXN0UmVzdWx0Py5pc0Vycm9yIHx8IGN1cnJlbnRTdGF0ZS5pc1VuaW5pdGlhbGl6ZWQpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5jdXJyZW50U3RhdGUsXG4gICAgICBkYXRhLFxuICAgICAgY3VycmVudERhdGE6IGN1cnJlbnRTdGF0ZS5kYXRhLFxuICAgICAgaXNGZXRjaGluZyxcbiAgICAgIGlzTG9hZGluZyxcbiAgICAgIGlzU3VjY2Vzc1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gaW5maW5pdGVRdWVyeVN0YXRlUHJlU2VsZWN0b3IoY3VycmVudFN0YXRlLCBsYXN0UmVzdWx0LCBxdWVyeUFyZ3MpIHtcbiAgICBpZiAobGFzdFJlc3VsdD8uZW5kcG9pbnROYW1lICYmIGN1cnJlbnRTdGF0ZS5pc1VuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZW5kcG9pbnROYW1lXG4gICAgICB9ID0gbGFzdFJlc3VsdDtcbiAgICAgIGNvbnN0IGVuZHBvaW50RGVmaW5pdGlvbiA9IGNvbnRleHQuZW5kcG9pbnREZWZpbml0aW9uc1tlbmRwb2ludE5hbWVdO1xuICAgICAgaWYgKHF1ZXJ5QXJncyAhPT0gc2tpcFRva2VuICYmIHNlcmlhbGl6ZVF1ZXJ5QXJncyh7XG4gICAgICAgIHF1ZXJ5QXJnczogbGFzdFJlc3VsdC5vcmlnaW5hbEFyZ3MsXG4gICAgICAgIGVuZHBvaW50RGVmaW5pdGlvbixcbiAgICAgICAgZW5kcG9pbnROYW1lXG4gICAgICB9KSA9PT0gc2VyaWFsaXplUXVlcnlBcmdzKHtcbiAgICAgICAgcXVlcnlBcmdzLFxuICAgICAgICBlbmRwb2ludERlZmluaXRpb24sXG4gICAgICAgIGVuZHBvaW50TmFtZVxuICAgICAgfSkpIGxhc3RSZXN1bHQgPSB2b2lkIDA7XG4gICAgfVxuICAgIGxldCBkYXRhID0gY3VycmVudFN0YXRlLmlzU3VjY2VzcyA/IGN1cnJlbnRTdGF0ZS5kYXRhIDogbGFzdFJlc3VsdD8uZGF0YTtcbiAgICBpZiAoZGF0YSA9PT0gdm9pZCAwKSBkYXRhID0gY3VycmVudFN0YXRlLmRhdGE7XG4gICAgY29uc3QgaGFzRGF0YSA9IGRhdGEgIT09IHZvaWQgMDtcbiAgICBjb25zdCBpc0ZldGNoaW5nID0gY3VycmVudFN0YXRlLmlzTG9hZGluZztcbiAgICBjb25zdCBpc0xvYWRpbmcgPSAoIWxhc3RSZXN1bHQgfHwgbGFzdFJlc3VsdC5pc0xvYWRpbmcgfHwgbGFzdFJlc3VsdC5pc1VuaW5pdGlhbGl6ZWQpICYmICFoYXNEYXRhICYmIGlzRmV0Y2hpbmc7XG4gICAgY29uc3QgaXNTdWNjZXNzID0gY3VycmVudFN0YXRlLmlzU3VjY2VzcyB8fCBpc0ZldGNoaW5nICYmIGhhc0RhdGE7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmN1cnJlbnRTdGF0ZSxcbiAgICAgIGRhdGEsXG4gICAgICBjdXJyZW50RGF0YTogY3VycmVudFN0YXRlLmRhdGEsXG4gICAgICBpc0ZldGNoaW5nLFxuICAgICAgaXNMb2FkaW5nLFxuICAgICAgaXNTdWNjZXNzXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiB1c2VQcmVmZXRjaChlbmRwb2ludE5hbWUsIGRlZmF1bHRPcHRpb25zKSB7XG4gICAgY29uc3QgZGlzcGF0Y2ggPSB1c2VEaXNwYXRjaCgpO1xuICAgIGNvbnN0IHN0YWJsZURlZmF1bHRPcHRpb25zID0gdXNlU2hhbGxvd1N0YWJsZVZhbHVlKGRlZmF1bHRPcHRpb25zKTtcbiAgICByZXR1cm4gdXNlQ2FsbGJhY2soKGFyZywgb3B0aW9ucykgPT4gZGlzcGF0Y2goYXBpLnV0aWwucHJlZmV0Y2goZW5kcG9pbnROYW1lLCBhcmcsIHtcbiAgICAgIC4uLnN0YWJsZURlZmF1bHRPcHRpb25zLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pKSwgW2VuZHBvaW50TmFtZSwgZGlzcGF0Y2gsIHN0YWJsZURlZmF1bHRPcHRpb25zXSk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlUXVlcnlTdWJzY3JpcHRpb25Db21tb25JbXBsKGVuZHBvaW50TmFtZSwgYXJnLCB7XG4gICAgcmVmZXRjaE9uUmVjb25uZWN0LFxuICAgIHJlZmV0Y2hPbkZvY3VzLFxuICAgIHJlZmV0Y2hPbk1vdW50T3JBcmdDaGFuZ2UsXG4gICAgc2tpcCA9IGZhbHNlLFxuICAgIHBvbGxpbmdJbnRlcnZhbCA9IDAsXG4gICAgc2tpcFBvbGxpbmdJZlVuZm9jdXNlZCA9IGZhbHNlLFxuICAgIC4uLnJlc3RcbiAgfSA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgaW5pdGlhdGVcbiAgICB9ID0gYXBpLmVuZHBvaW50c1tlbmRwb2ludE5hbWVdO1xuICAgIGNvbnN0IGRpc3BhdGNoID0gdXNlRGlzcGF0Y2goKTtcbiAgICBjb25zdCBzdWJzY3JpcHRpb25TZWxlY3RvcnNSZWYgPSB1c2VSZWYzKHZvaWQgMCk7XG4gICAgaWYgKCFzdWJzY3JpcHRpb25TZWxlY3RvcnNSZWYuY3VycmVudCkge1xuICAgICAgY29uc3QgcmV0dXJuZWRWYWx1ZSA9IGRpc3BhdGNoKGFwaS5pbnRlcm5hbEFjdGlvbnMuaW50ZXJuYWxfZ2V0UlRLUVN1YnNjcmlwdGlvbnMoKSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmV0dXJuZWRWYWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgcmV0dXJuZWRWYWx1ZT8udHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzNykgOiBgV2FybmluZzogTWlkZGxld2FyZSBmb3IgUlRLLVF1ZXJ5IEFQSSBhdCByZWR1Y2VyUGF0aCBcIiR7YXBpLnJlZHVjZXJQYXRofVwiIGhhcyBub3QgYmVlbiBhZGRlZCB0byB0aGUgc3RvcmUuXG4gICAgWW91IG11c3QgYWRkIHRoZSBtaWRkbGV3YXJlIGZvciBSVEstUXVlcnkgdG8gZnVuY3Rpb24gY29ycmVjdGx5IWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdWJzY3JpcHRpb25TZWxlY3RvcnNSZWYuY3VycmVudCA9IHJldHVybmVkVmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IHN0YWJsZUFyZyA9IHVzZVN0YWJsZVF1ZXJ5QXJncyhza2lwID8gc2tpcFRva2VuIDogYXJnKTtcbiAgICBjb25zdCBzdGFibGVTdWJzY3JpcHRpb25PcHRpb25zID0gdXNlU2hhbGxvd1N0YWJsZVZhbHVlKHtcbiAgICAgIHJlZmV0Y2hPblJlY29ubmVjdCxcbiAgICAgIHJlZmV0Y2hPbkZvY3VzLFxuICAgICAgcG9sbGluZ0ludGVydmFsLFxuICAgICAgc2tpcFBvbGxpbmdJZlVuZm9jdXNlZFxuICAgIH0pO1xuICAgIGNvbnN0IGluaXRpYWxQYWdlUGFyYW0gPSByZXN0LmluaXRpYWxQYWdlUGFyYW07XG4gICAgY29uc3Qgc3RhYmxlSW5pdGlhbFBhZ2VQYXJhbSA9IHVzZVNoYWxsb3dTdGFibGVWYWx1ZShpbml0aWFsUGFnZVBhcmFtKTtcbiAgICBjb25zdCBwcm9taXNlUmVmID0gdXNlUmVmMyh2b2lkIDApO1xuICAgIGxldCB7XG4gICAgICBxdWVyeUNhY2hlS2V5LFxuICAgICAgcmVxdWVzdElkXG4gICAgfSA9IHByb21pc2VSZWYuY3VycmVudCB8fCB7fTtcbiAgICBsZXQgY3VycmVudFJlbmRlckhhc1N1YnNjcmlwdGlvbiA9IGZhbHNlO1xuICAgIGlmIChxdWVyeUNhY2hlS2V5ICYmIHJlcXVlc3RJZCkge1xuICAgICAgY3VycmVudFJlbmRlckhhc1N1YnNjcmlwdGlvbiA9IHN1YnNjcmlwdGlvblNlbGVjdG9yc1JlZi5jdXJyZW50LmlzUmVxdWVzdFN1YnNjcmliZWQocXVlcnlDYWNoZUtleSwgcmVxdWVzdElkKTtcbiAgICB9XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uUmVtb3ZlZCA9ICFjdXJyZW50UmVuZGVySGFzU3Vic2NyaXB0aW9uICYmIHByb21pc2VSZWYuY3VycmVudCAhPT0gdm9pZCAwO1xuICAgIHVzZVBvc3NpYmx5SW1tZWRpYXRlRWZmZWN0KCgpID0+IHtcbiAgICAgIGlmIChzdWJzY3JpcHRpb25SZW1vdmVkKSB7XG4gICAgICAgIHByb21pc2VSZWYuY3VycmVudCA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9LCBbc3Vic2NyaXB0aW9uUmVtb3ZlZF0pO1xuICAgIHVzZVBvc3NpYmx5SW1tZWRpYXRlRWZmZWN0KCgpID0+IHtcbiAgICAgIGNvbnN0IGxhc3RQcm9taXNlID0gcHJvbWlzZVJlZi5jdXJyZW50O1xuICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInJlbW92ZU1lT25Db21waWxhdGlvblwiKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKHN1YnNjcmlwdGlvblJlbW92ZWQpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YWJsZUFyZyA9PT0gc2tpcFRva2VuKSB7XG4gICAgICAgIGxhc3RQcm9taXNlPy51bnN1YnNjcmliZSgpO1xuICAgICAgICBwcm9taXNlUmVmLmN1cnJlbnQgPSB2b2lkIDA7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxhc3RTdWJzY3JpcHRpb25PcHRpb25zID0gcHJvbWlzZVJlZi5jdXJyZW50Py5zdWJzY3JpcHRpb25PcHRpb25zO1xuICAgICAgaWYgKCFsYXN0UHJvbWlzZSB8fCBsYXN0UHJvbWlzZS5hcmcgIT09IHN0YWJsZUFyZykge1xuICAgICAgICBsYXN0UHJvbWlzZT8udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IGRpc3BhdGNoKGluaXRpYXRlKHN0YWJsZUFyZywge1xuICAgICAgICAgIHN1YnNjcmlwdGlvbk9wdGlvbnM6IHN0YWJsZVN1YnNjcmlwdGlvbk9wdGlvbnMsXG4gICAgICAgICAgZm9yY2VSZWZldGNoOiByZWZldGNoT25Nb3VudE9yQXJnQ2hhbmdlLFxuICAgICAgICAgIC4uLmlzSW5maW5pdGVRdWVyeURlZmluaXRpb24oY29udGV4dC5lbmRwb2ludERlZmluaXRpb25zW2VuZHBvaW50TmFtZV0pID8ge1xuICAgICAgICAgICAgaW5pdGlhbFBhZ2VQYXJhbTogc3RhYmxlSW5pdGlhbFBhZ2VQYXJhbVxuICAgICAgICAgIH0gOiB7fVxuICAgICAgICB9KSk7XG4gICAgICAgIHByb21pc2VSZWYuY3VycmVudCA9IHByb21pc2U7XG4gICAgICB9IGVsc2UgaWYgKHN0YWJsZVN1YnNjcmlwdGlvbk9wdGlvbnMgIT09IGxhc3RTdWJzY3JpcHRpb25PcHRpb25zKSB7XG4gICAgICAgIGxhc3RQcm9taXNlLnVwZGF0ZVN1YnNjcmlwdGlvbk9wdGlvbnMoc3RhYmxlU3Vic2NyaXB0aW9uT3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSwgW2Rpc3BhdGNoLCBpbml0aWF0ZSwgcmVmZXRjaE9uTW91bnRPckFyZ0NoYW5nZSwgc3RhYmxlQXJnLCBzdGFibGVTdWJzY3JpcHRpb25PcHRpb25zLCBzdWJzY3JpcHRpb25SZW1vdmVkLCBzdGFibGVJbml0aWFsUGFnZVBhcmFtLCBlbmRwb2ludE5hbWVdKTtcbiAgICByZXR1cm4gW3Byb21pc2VSZWYsIGRpc3BhdGNoLCBpbml0aWF0ZSwgc3RhYmxlU3Vic2NyaXB0aW9uT3B0aW9uc107XG4gIH1cbiAgZnVuY3Rpb24gYnVpbGRVc2VRdWVyeVN0YXRlKGVuZHBvaW50TmFtZSwgcHJlU2VsZWN0b3IpIHtcbiAgICBjb25zdCB1c2VRdWVyeVN0YXRlID0gKGFyZywge1xuICAgICAgc2tpcCA9IGZhbHNlLFxuICAgICAgc2VsZWN0RnJvbVJlc3VsdFxuICAgIH0gPSB7fSkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzZWxlY3RcbiAgICAgIH0gPSBhcGkuZW5kcG9pbnRzW2VuZHBvaW50TmFtZV07XG4gICAgICBjb25zdCBzdGFibGVBcmcgPSB1c2VTdGFibGVRdWVyeUFyZ3Moc2tpcCA/IHNraXBUb2tlbiA6IGFyZyk7XG4gICAgICBjb25zdCBsYXN0VmFsdWUgPSB1c2VSZWYzKHZvaWQgMCk7XG4gICAgICBjb25zdCBzZWxlY3REZWZhdWx0UmVzdWx0ID0gdXNlTWVtbzIoKCkgPT4gKFxuICAgICAgICAvLyBOb3JtYWxseSB0cy1pZ25vcmVzIGFyZSBiYWQgYW5kIHNob3VsZCBiZSBhdm9pZGVkLCBidXQgd2UncmVcbiAgICAgICAgLy8gYWxyZWFkeSBjYXN0aW5nIHRoaXMgc2VsZWN0b3IgdG8gYmUgYFNlbGVjdG9yPGFueT5gIGFueXdheSxcbiAgICAgICAgLy8gc28gdGhlIGluY29uc2lzdGVuY2llcyBkb24ndCBtYXR0ZXIgaGVyZVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNyZWF0ZVNlbGVjdG9yKFtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgc2VsZWN0KHN0YWJsZUFyZyksXG4gICAgICAgICAgKF8sIGxhc3RSZXN1bHQpID0+IGxhc3RSZXN1bHQsXG4gICAgICAgICAgKF8pID0+IHN0YWJsZUFyZ1xuICAgICAgICBdLCBwcmVTZWxlY3Rvciwge1xuICAgICAgICAgIG1lbW9pemVPcHRpb25zOiB7XG4gICAgICAgICAgICByZXN1bHRFcXVhbGl0eUNoZWNrOiBzaGFsbG93RXF1YWwyXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKSwgW3NlbGVjdCwgc3RhYmxlQXJnXSk7XG4gICAgICBjb25zdCBxdWVyeVNlbGVjdG9yID0gdXNlTWVtbzIoKCkgPT4gc2VsZWN0RnJvbVJlc3VsdCA/IGNyZWF0ZVNlbGVjdG9yKFtzZWxlY3REZWZhdWx0UmVzdWx0XSwgc2VsZWN0RnJvbVJlc3VsdCwge1xuICAgICAgICBkZXZNb2RlQ2hlY2tzOiB7XG4gICAgICAgICAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrOiBcIm5ldmVyXCJcbiAgICAgICAgfVxuICAgICAgfSkgOiBzZWxlY3REZWZhdWx0UmVzdWx0LCBbc2VsZWN0RGVmYXVsdFJlc3VsdCwgc2VsZWN0RnJvbVJlc3VsdF0pO1xuICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gdXNlU2VsZWN0b3IoKHN0YXRlKSA9PiBxdWVyeVNlbGVjdG9yKHN0YXRlLCBsYXN0VmFsdWUuY3VycmVudCksIHNoYWxsb3dFcXVhbDIpO1xuICAgICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZSgpO1xuICAgICAgY29uc3QgbmV3TGFzdFZhbHVlID0gc2VsZWN0RGVmYXVsdFJlc3VsdChzdG9yZS5nZXRTdGF0ZSgpLCBsYXN0VmFsdWUuY3VycmVudCk7XG4gICAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgbGFzdFZhbHVlLmN1cnJlbnQgPSBuZXdMYXN0VmFsdWU7XG4gICAgICB9LCBbbmV3TGFzdFZhbHVlXSk7XG4gICAgICByZXR1cm4gY3VycmVudFN0YXRlO1xuICAgIH07XG4gICAgcmV0dXJuIHVzZVF1ZXJ5U3RhdGU7XG4gIH1cbiAgZnVuY3Rpb24gdXNlUHJvbWlzZVJlZlVuc3Vic2NyaWJlT25Vbm1vdW50KHByb21pc2VSZWYpIHtcbiAgICB1c2VFZmZlY3QzKCgpID0+IHtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHByb21pc2VSZWYuY3VycmVudD8udW5zdWJzY3JpYmU/LigpO1xuICAgICAgICBwcm9taXNlUmVmLmN1cnJlbnQgPSB2b2lkIDA7XG4gICAgICB9O1xuICAgIH0sIFtwcm9taXNlUmVmXSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVmZXRjaE9yRXJyb3JJZlVubW91bnRlZChwcm9taXNlUmVmKSB7XG4gICAgaWYgKCFwcm9taXNlUmVmLmN1cnJlbnQpIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTIoMzgpIDogXCJDYW5ub3QgcmVmZXRjaCBhIHF1ZXJ5IHRoYXQgaGFzIG5vdCBiZWVuIHN0YXJ0ZWQgeWV0LlwiKTtcbiAgICByZXR1cm4gcHJvbWlzZVJlZi5jdXJyZW50LnJlZmV0Y2goKTtcbiAgfVxuICBmdW5jdGlvbiBidWlsZFF1ZXJ5SG9va3MoZW5kcG9pbnROYW1lKSB7XG4gICAgY29uc3QgdXNlUXVlcnlTdWJzY3JpcHRpb24gPSAoYXJnLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgIGNvbnN0IFtwcm9taXNlUmVmXSA9IHVzZVF1ZXJ5U3Vic2NyaXB0aW9uQ29tbW9uSW1wbChlbmRwb2ludE5hbWUsIGFyZywgb3B0aW9ucyk7XG4gICAgICB1c2VQcm9taXNlUmVmVW5zdWJzY3JpYmVPblVubW91bnQocHJvbWlzZVJlZik7XG4gICAgICByZXR1cm4gdXNlTWVtbzIoKCkgPT4gKHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbWV0aG9kIHRvIG1hbnVhbGx5IHJlZmV0Y2ggZGF0YSBmb3IgdGhlIHF1ZXJ5XG4gICAgICAgICAqL1xuICAgICAgICByZWZldGNoOiAoKSA9PiByZWZldGNoT3JFcnJvcklmVW5tb3VudGVkKHByb21pc2VSZWYpXG4gICAgICB9KSwgW3Byb21pc2VSZWZdKTtcbiAgICB9O1xuICAgIGNvbnN0IHVzZUxhenlRdWVyeVN1YnNjcmlwdGlvbiA9ICh7XG4gICAgICByZWZldGNoT25SZWNvbm5lY3QsXG4gICAgICByZWZldGNoT25Gb2N1cyxcbiAgICAgIHBvbGxpbmdJbnRlcnZhbCA9IDAsXG4gICAgICBza2lwUG9sbGluZ0lmVW5mb2N1c2VkID0gZmFsc2VcbiAgICB9ID0ge30pID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaW5pdGlhdGVcbiAgICAgIH0gPSBhcGkuZW5kcG9pbnRzW2VuZHBvaW50TmFtZV07XG4gICAgICBjb25zdCBkaXNwYXRjaCA9IHVzZURpc3BhdGNoKCk7XG4gICAgICBjb25zdCBbYXJnLCBzZXRBcmddID0gdXNlU3RhdGUoVU5JTklUSUFMSVpFRF9WQUxVRSk7XG4gICAgICBjb25zdCBwcm9taXNlUmVmID0gdXNlUmVmMyh2b2lkIDApO1xuICAgICAgY29uc3Qgc3RhYmxlU3Vic2NyaXB0aW9uT3B0aW9ucyA9IHVzZVNoYWxsb3dTdGFibGVWYWx1ZSh7XG4gICAgICAgIHJlZmV0Y2hPblJlY29ubmVjdCxcbiAgICAgICAgcmVmZXRjaE9uRm9jdXMsXG4gICAgICAgIHBvbGxpbmdJbnRlcnZhbCxcbiAgICAgICAgc2tpcFBvbGxpbmdJZlVuZm9jdXNlZFxuICAgICAgfSk7XG4gICAgICB1c2VQb3NzaWJseUltbWVkaWF0ZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGxhc3RTdWJzY3JpcHRpb25PcHRpb25zID0gcHJvbWlzZVJlZi5jdXJyZW50Py5zdWJzY3JpcHRpb25PcHRpb25zO1xuICAgICAgICBpZiAoc3RhYmxlU3Vic2NyaXB0aW9uT3B0aW9ucyAhPT0gbGFzdFN1YnNjcmlwdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgICBwcm9taXNlUmVmLmN1cnJlbnQ/LnVwZGF0ZVN1YnNjcmlwdGlvbk9wdGlvbnMoc3RhYmxlU3Vic2NyaXB0aW9uT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH0sIFtzdGFibGVTdWJzY3JpcHRpb25PcHRpb25zXSk7XG4gICAgICBjb25zdCBzdWJzY3JpcHRpb25PcHRpb25zUmVmID0gdXNlUmVmMyhzdGFibGVTdWJzY3JpcHRpb25PcHRpb25zKTtcbiAgICAgIHVzZVBvc3NpYmx5SW1tZWRpYXRlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc3Vic2NyaXB0aW9uT3B0aW9uc1JlZi5jdXJyZW50ID0gc3RhYmxlU3Vic2NyaXB0aW9uT3B0aW9ucztcbiAgICAgIH0sIFtzdGFibGVTdWJzY3JpcHRpb25PcHRpb25zXSk7XG4gICAgICBjb25zdCB0cmlnZ2VyID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24oYXJnMiwgcHJlZmVyQ2FjaGVWYWx1ZSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBwcm9taXNlO1xuICAgICAgICBiYXRjaCgoKSA9PiB7XG4gICAgICAgICAgcHJvbWlzZVJlZi5jdXJyZW50Py51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIHByb21pc2VSZWYuY3VycmVudCA9IHByb21pc2UgPSBkaXNwYXRjaChpbml0aWF0ZShhcmcyLCB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb25PcHRpb25zOiBzdWJzY3JpcHRpb25PcHRpb25zUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBmb3JjZVJlZmV0Y2g6ICFwcmVmZXJDYWNoZVZhbHVlXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHNldEFyZyhhcmcyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgfSwgW2Rpc3BhdGNoLCBpbml0aWF0ZV0pO1xuICAgICAgY29uc3QgcmVzZXQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmIChwcm9taXNlUmVmLmN1cnJlbnQ/LnF1ZXJ5Q2FjaGVLZXkpIHtcbiAgICAgICAgICBkaXNwYXRjaChhcGkuaW50ZXJuYWxBY3Rpb25zLnJlbW92ZVF1ZXJ5UmVzdWx0KHtcbiAgICAgICAgICAgIHF1ZXJ5Q2FjaGVLZXk6IHByb21pc2VSZWYuY3VycmVudD8ucXVlcnlDYWNoZUtleVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfSwgW2Rpc3BhdGNoXSk7XG4gICAgICB1c2VFZmZlY3QzKCgpID0+IHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICBwcm9taXNlUmVmPy5jdXJyZW50Py51bnN1YnNjcmliZSgpO1xuICAgICAgICB9O1xuICAgICAgfSwgW10pO1xuICAgICAgdXNlRWZmZWN0MygoKSA9PiB7XG4gICAgICAgIGlmIChhcmcgIT09IFVOSU5JVElBTElaRURfVkFMVUUgJiYgIXByb21pc2VSZWYuY3VycmVudCkge1xuICAgICAgICAgIHRyaWdnZXIoYXJnLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSwgW2FyZywgdHJpZ2dlcl0pO1xuICAgICAgcmV0dXJuIHVzZU1lbW8yKCgpID0+IFt0cmlnZ2VyLCBhcmcsIHtcbiAgICAgICAgcmVzZXRcbiAgICAgIH1dLCBbdHJpZ2dlciwgYXJnLCByZXNldF0pO1xuICAgIH07XG4gICAgY29uc3QgdXNlUXVlcnlTdGF0ZSA9IGJ1aWxkVXNlUXVlcnlTdGF0ZShlbmRwb2ludE5hbWUsIHF1ZXJ5U3RhdGVQcmVTZWxlY3Rvcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVzZVF1ZXJ5U3RhdGUsXG4gICAgICB1c2VRdWVyeVN1YnNjcmlwdGlvbixcbiAgICAgIHVzZUxhenlRdWVyeVN1YnNjcmlwdGlvbixcbiAgICAgIHVzZUxhenlRdWVyeShvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IFt0cmlnZ2VyLCBhcmcsIHtcbiAgICAgICAgICByZXNldFxuICAgICAgICB9XSA9IHVzZUxhenlRdWVyeVN1YnNjcmlwdGlvbihvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcXVlcnlTdGF0ZVJlc3VsdHMgPSB1c2VRdWVyeVN0YXRlKGFyZywge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgc2tpcDogYXJnID09PSBVTklOSVRJQUxJWkVEX1ZBTFVFXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBpbmZvID0gdXNlTWVtbzIoKCkgPT4gKHtcbiAgICAgICAgICBsYXN0QXJnOiBhcmdcbiAgICAgICAgfSksIFthcmddKTtcbiAgICAgICAgcmV0dXJuIHVzZU1lbW8yKCgpID0+IFt0cmlnZ2VyLCB7XG4gICAgICAgICAgLi4ucXVlcnlTdGF0ZVJlc3VsdHMsXG4gICAgICAgICAgcmVzZXRcbiAgICAgICAgfSwgaW5mb10sIFt0cmlnZ2VyLCBxdWVyeVN0YXRlUmVzdWx0cywgcmVzZXQsIGluZm9dKTtcbiAgICAgIH0sXG4gICAgICB1c2VRdWVyeShhcmcsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcXVlcnlTdWJzY3JpcHRpb25SZXN1bHRzID0gdXNlUXVlcnlTdWJzY3JpcHRpb24oYXJnLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcXVlcnlTdGF0ZVJlc3VsdHMgPSB1c2VRdWVyeVN0YXRlKGFyZywge1xuICAgICAgICAgIHNlbGVjdEZyb21SZXN1bHQ6IGFyZyA9PT0gc2tpcFRva2VuIHx8IG9wdGlvbnM/LnNraXAgPyB2b2lkIDAgOiBub1BlbmRpbmdRdWVyeVN0YXRlU2VsZWN0b3IsXG4gICAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGVidWdWYWx1ZSA9IHBpY2socXVlcnlTdGF0ZVJlc3VsdHMsIC4uLkNPTU1PTl9IT09LX0RFQlVHX0ZJRUxEUyk7XG4gICAgICAgIHVzZURlYnVnVmFsdWUoZGVidWdWYWx1ZSk7XG4gICAgICAgIHJldHVybiB1c2VNZW1vMigoKSA9PiAoe1xuICAgICAgICAgIC4uLnF1ZXJ5U3RhdGVSZXN1bHRzLFxuICAgICAgICAgIC4uLnF1ZXJ5U3Vic2NyaXB0aW9uUmVzdWx0c1xuICAgICAgICB9KSwgW3F1ZXJ5U3RhdGVSZXN1bHRzLCBxdWVyeVN1YnNjcmlwdGlvblJlc3VsdHNdKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGJ1aWxkSW5maW5pdGVRdWVyeUhvb2tzKGVuZHBvaW50TmFtZSkge1xuICAgIGNvbnN0IHVzZUluZmluaXRlUXVlcnlTdWJzY3JpcHRpb24gPSAoYXJnLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgIGNvbnN0IFtwcm9taXNlUmVmLCBkaXNwYXRjaCwgaW5pdGlhdGUsIHN0YWJsZVN1YnNjcmlwdGlvbk9wdGlvbnNdID0gdXNlUXVlcnlTdWJzY3JpcHRpb25Db21tb25JbXBsKGVuZHBvaW50TmFtZSwgYXJnLCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbk9wdGlvbnNSZWYgPSB1c2VSZWYzKHN0YWJsZVN1YnNjcmlwdGlvbk9wdGlvbnMpO1xuICAgICAgdXNlUG9zc2libHlJbW1lZGlhdGVFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzdWJzY3JpcHRpb25PcHRpb25zUmVmLmN1cnJlbnQgPSBzdGFibGVTdWJzY3JpcHRpb25PcHRpb25zO1xuICAgICAgfSwgW3N0YWJsZVN1YnNjcmlwdGlvbk9wdGlvbnNdKTtcbiAgICAgIGNvbnN0IHRyaWdnZXIgPSB1c2VDYWxsYmFjayhmdW5jdGlvbihhcmcyLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgbGV0IHByb21pc2U7XG4gICAgICAgIGJhdGNoKCgpID0+IHtcbiAgICAgICAgICBwcm9taXNlUmVmLmN1cnJlbnQ/LnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgcHJvbWlzZVJlZi5jdXJyZW50ID0gcHJvbWlzZSA9IGRpc3BhdGNoKGluaXRpYXRlKGFyZzIsIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbk9wdGlvbnM6IHN1YnNjcmlwdGlvbk9wdGlvbnNSZWYuY3VycmVudCxcbiAgICAgICAgICAgIGRpcmVjdGlvblxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgfSwgW3Byb21pc2VSZWYsIGRpc3BhdGNoLCBpbml0aWF0ZV0pO1xuICAgICAgdXNlUHJvbWlzZVJlZlVuc3Vic2NyaWJlT25Vbm1vdW50KHByb21pc2VSZWYpO1xuICAgICAgY29uc3Qgc3RhYmxlQXJnID0gdXNlU3RhYmxlUXVlcnlBcmdzKG9wdGlvbnMuc2tpcCA/IHNraXBUb2tlbiA6IGFyZyk7XG4gICAgICBjb25zdCByZWZldGNoID0gdXNlQ2FsbGJhY2soKCkgPT4gcmVmZXRjaE9yRXJyb3JJZlVubW91bnRlZChwcm9taXNlUmVmKSwgW3Byb21pc2VSZWZdKTtcbiAgICAgIHJldHVybiB1c2VNZW1vMigoKSA9PiB7XG4gICAgICAgIGNvbnN0IGZldGNoTmV4dFBhZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRyaWdnZXIoc3RhYmxlQXJnLCBcImZvcndhcmRcIik7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZldGNoUHJldmlvdXNQYWdlID0gKCkgPT4ge1xuICAgICAgICAgIHJldHVybiB0cmlnZ2VyKHN0YWJsZUFyZywgXCJiYWNrd2FyZFwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0cmlnZ2VyLFxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEEgbWV0aG9kIHRvIG1hbnVhbGx5IHJlZmV0Y2ggZGF0YSBmb3IgdGhlIHF1ZXJ5XG4gICAgICAgICAgICovXG4gICAgICAgICAgcmVmZXRjaCxcbiAgICAgICAgICBmZXRjaE5leHRQYWdlLFxuICAgICAgICAgIGZldGNoUHJldmlvdXNQYWdlXG4gICAgICAgIH07XG4gICAgICB9LCBbcmVmZXRjaCwgdHJpZ2dlciwgc3RhYmxlQXJnXSk7XG4gICAgfTtcbiAgICBjb25zdCB1c2VJbmZpbml0ZVF1ZXJ5U3RhdGUgPSBidWlsZFVzZVF1ZXJ5U3RhdGUoZW5kcG9pbnROYW1lLCBpbmZpbml0ZVF1ZXJ5U3RhdGVQcmVTZWxlY3Rvcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVzZUluZmluaXRlUXVlcnlTdGF0ZSxcbiAgICAgIHVzZUluZmluaXRlUXVlcnlTdWJzY3JpcHRpb24sXG4gICAgICB1c2VJbmZpbml0ZVF1ZXJ5KGFyZywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcmVmZXRjaCxcbiAgICAgICAgICBmZXRjaE5leHRQYWdlLFxuICAgICAgICAgIGZldGNoUHJldmlvdXNQYWdlXG4gICAgICAgIH0gPSB1c2VJbmZpbml0ZVF1ZXJ5U3Vic2NyaXB0aW9uKGFyZywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHF1ZXJ5U3RhdGVSZXN1bHRzID0gdXNlSW5maW5pdGVRdWVyeVN0YXRlKGFyZywge1xuICAgICAgICAgIHNlbGVjdEZyb21SZXN1bHQ6IGFyZyA9PT0gc2tpcFRva2VuIHx8IG9wdGlvbnM/LnNraXAgPyB2b2lkIDAgOiBub1BlbmRpbmdRdWVyeVN0YXRlU2VsZWN0b3IsXG4gICAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGVidWdWYWx1ZSA9IHBpY2socXVlcnlTdGF0ZVJlc3VsdHMsIC4uLkNPTU1PTl9IT09LX0RFQlVHX0ZJRUxEUywgXCJoYXNOZXh0UGFnZVwiLCBcImhhc1ByZXZpb3VzUGFnZVwiKTtcbiAgICAgICAgdXNlRGVidWdWYWx1ZShkZWJ1Z1ZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHVzZU1lbW8yKCgpID0+ICh7XG4gICAgICAgICAgLi4ucXVlcnlTdGF0ZVJlc3VsdHMsXG4gICAgICAgICAgZmV0Y2hOZXh0UGFnZSxcbiAgICAgICAgICBmZXRjaFByZXZpb3VzUGFnZSxcbiAgICAgICAgICByZWZldGNoXG4gICAgICAgIH0pLCBbcXVlcnlTdGF0ZVJlc3VsdHMsIGZldGNoTmV4dFBhZ2UsIGZldGNoUHJldmlvdXNQYWdlLCByZWZldGNoXSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBidWlsZE11dGF0aW9uSG9vayhuYW1lKSB7XG4gICAgcmV0dXJuICh7XG4gICAgICBzZWxlY3RGcm9tUmVzdWx0LFxuICAgICAgZml4ZWRDYWNoZUtleVxuICAgIH0gPSB7fSkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzZWxlY3QsXG4gICAgICAgIGluaXRpYXRlXG4gICAgICB9ID0gYXBpLmVuZHBvaW50c1tuYW1lXTtcbiAgICAgIGNvbnN0IGRpc3BhdGNoID0gdXNlRGlzcGF0Y2goKTtcbiAgICAgIGNvbnN0IFtwcm9taXNlLCBzZXRQcm9taXNlXSA9IHVzZVN0YXRlKCk7XG4gICAgICB1c2VFZmZlY3QzKCgpID0+ICgpID0+IHtcbiAgICAgICAgaWYgKCFwcm9taXNlPy5hcmcuZml4ZWRDYWNoZUtleSkge1xuICAgICAgICAgIHByb21pc2U/LnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgIH0sIFtwcm9taXNlXSk7XG4gICAgICBjb25zdCB0cmlnZ2VyTXV0YXRpb24gPSB1c2VDYWxsYmFjayhmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZTIgPSBkaXNwYXRjaChpbml0aWF0ZShhcmcsIHtcbiAgICAgICAgICBmaXhlZENhY2hlS2V5XG4gICAgICAgIH0pKTtcbiAgICAgICAgc2V0UHJvbWlzZShwcm9taXNlMik7XG4gICAgICAgIHJldHVybiBwcm9taXNlMjtcbiAgICAgIH0sIFtkaXNwYXRjaCwgaW5pdGlhdGUsIGZpeGVkQ2FjaGVLZXldKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVxdWVzdElkXG4gICAgICB9ID0gcHJvbWlzZSB8fCB7fTtcbiAgICAgIGNvbnN0IHNlbGVjdERlZmF1bHRSZXN1bHQgPSB1c2VNZW1vMigoKSA9PiBzZWxlY3Qoe1xuICAgICAgICBmaXhlZENhY2hlS2V5LFxuICAgICAgICByZXF1ZXN0SWQ6IHByb21pc2U/LnJlcXVlc3RJZFxuICAgICAgfSksIFtmaXhlZENhY2hlS2V5LCBwcm9taXNlLCBzZWxlY3RdKTtcbiAgICAgIGNvbnN0IG11dGF0aW9uU2VsZWN0b3IgPSB1c2VNZW1vMigoKSA9PiBzZWxlY3RGcm9tUmVzdWx0ID8gY3JlYXRlU2VsZWN0b3IoW3NlbGVjdERlZmF1bHRSZXN1bHRdLCBzZWxlY3RGcm9tUmVzdWx0KSA6IHNlbGVjdERlZmF1bHRSZXN1bHQsIFtzZWxlY3RGcm9tUmVzdWx0LCBzZWxlY3REZWZhdWx0UmVzdWx0XSk7XG4gICAgICBjb25zdCBjdXJyZW50U3RhdGUgPSB1c2VTZWxlY3RvcihtdXRhdGlvblNlbGVjdG9yLCBzaGFsbG93RXF1YWwyKTtcbiAgICAgIGNvbnN0IG9yaWdpbmFsQXJncyA9IGZpeGVkQ2FjaGVLZXkgPT0gbnVsbCA/IHByb21pc2U/LmFyZy5vcmlnaW5hbEFyZ3MgOiB2b2lkIDA7XG4gICAgICBjb25zdCByZXNldCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgYmF0Y2goKCkgPT4ge1xuICAgICAgICAgIGlmIChwcm9taXNlKSB7XG4gICAgICAgICAgICBzZXRQcm9taXNlKHZvaWQgMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmaXhlZENhY2hlS2V5KSB7XG4gICAgICAgICAgICBkaXNwYXRjaChhcGkuaW50ZXJuYWxBY3Rpb25zLnJlbW92ZU11dGF0aW9uUmVzdWx0KHtcbiAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgICBmaXhlZENhY2hlS2V5XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sIFtkaXNwYXRjaCwgZml4ZWRDYWNoZUtleSwgcHJvbWlzZSwgcmVxdWVzdElkXSk7XG4gICAgICBjb25zdCBkZWJ1Z1ZhbHVlID0gcGljayhjdXJyZW50U3RhdGUsIC4uLkNPTU1PTl9IT09LX0RFQlVHX0ZJRUxEUywgXCJlbmRwb2ludE5hbWVcIik7XG4gICAgICB1c2VEZWJ1Z1ZhbHVlKGRlYnVnVmFsdWUpO1xuICAgICAgY29uc3QgZmluYWxTdGF0ZSA9IHVzZU1lbW8yKCgpID0+ICh7XG4gICAgICAgIC4uLmN1cnJlbnRTdGF0ZSxcbiAgICAgICAgb3JpZ2luYWxBcmdzLFxuICAgICAgICByZXNldFxuICAgICAgfSksIFtjdXJyZW50U3RhdGUsIG9yaWdpbmFsQXJncywgcmVzZXRdKTtcbiAgICAgIHJldHVybiB1c2VNZW1vMigoKSA9PiBbdHJpZ2dlck11dGF0aW9uLCBmaW5hbFN0YXRlXSwgW3RyaWdnZXJNdXRhdGlvbiwgZmluYWxTdGF0ZV0pO1xuICAgIH07XG4gIH1cbn1cblxuLy8gc3JjL3F1ZXJ5L3JlYWN0L21vZHVsZS50c1xudmFyIHJlYWN0SG9va3NNb2R1bGVOYW1lID0gLyogQF9fUFVSRV9fICovIFN5bWJvbCgpO1xudmFyIHJlYWN0SG9va3NNb2R1bGUgPSAoe1xuICBiYXRjaCA9IHJyQmF0Y2gsXG4gIGhvb2tzID0ge1xuICAgIHVzZURpc3BhdGNoOiByclVzZURpc3BhdGNoLFxuICAgIHVzZVNlbGVjdG9yOiByclVzZVNlbGVjdG9yLFxuICAgIHVzZVN0b3JlOiByclVzZVN0b3JlXG4gIH0sXG4gIGNyZWF0ZVNlbGVjdG9yID0gX2NyZWF0ZVNlbGVjdG9yLFxuICB1bnN0YWJsZV9fc2lkZUVmZmVjdHNJblJlbmRlciA9IGZhbHNlLFxuICAuLi5yZXN0XG59ID0ge30pID0+IHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnN0IGhvb2tOYW1lcyA9IFtcInVzZURpc3BhdGNoXCIsIFwidXNlU2VsZWN0b3JcIiwgXCJ1c2VTdG9yZVwiXTtcbiAgICBsZXQgd2FybmVkID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBob29rTmFtZSBvZiBob29rTmFtZXMpIHtcbiAgICAgIGlmIChjb3VudE9iamVjdEtleXMocmVzdCkgPiAwKSB7XG4gICAgICAgIGlmIChyZXN0W2hvb2tOYW1lXSkge1xuICAgICAgICAgIGlmICghd2FybmVkKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJBcyBvZiBSVEsgMi4wLCB0aGUgaG9va3Mgbm93IG5lZWQgdG8gYmUgc3BlY2lmaWVkIGFzIG9uZSBvYmplY3QsIHByb3ZpZGVkIHVuZGVyIGEgYGhvb2tzYCBrZXk6XFxuYHJlYWN0SG9va3NNb2R1bGUoeyBob29rczogeyB1c2VEaXNwYXRjaCwgdXNlU2VsZWN0b3IsIHVzZVN0b3JlIH0gfSlgXCIpO1xuICAgICAgICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaG9va3NbaG9va05hbWVdID0gcmVzdFtob29rTmFtZV07XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGhvb2tzW2hvb2tOYW1lXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTMoMzYpIDogYFdoZW4gdXNpbmcgY3VzdG9tIGhvb2tzIGZvciBjb250ZXh0LCBhbGwgJHtob29rTmFtZXMubGVuZ3RofSBob29rcyBuZWVkIHRvIGJlIHByb3ZpZGVkOiAke2hvb2tOYW1lcy5qb2luKFwiLCBcIil9LlxuSG9vayAke2hvb2tOYW1lfSB3YXMgZWl0aGVyIG5vdCBwcm92aWRlZCBvciBub3QgYSBmdW5jdGlvbi5gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiByZWFjdEhvb2tzTW9kdWxlTmFtZSxcbiAgICBpbml0KGFwaSwge1xuICAgICAgc2VyaWFsaXplUXVlcnlBcmdzXG4gICAgfSwgY29udGV4dCkge1xuICAgICAgY29uc3QgYW55QXBpID0gYXBpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBidWlsZFF1ZXJ5SG9va3MsXG4gICAgICAgIGJ1aWxkSW5maW5pdGVRdWVyeUhvb2tzLFxuICAgICAgICBidWlsZE11dGF0aW9uSG9vayxcbiAgICAgICAgdXNlUHJlZmV0Y2hcbiAgICAgIH0gPSBidWlsZEhvb2tzKHtcbiAgICAgICAgYXBpLFxuICAgICAgICBtb2R1bGVPcHRpb25zOiB7XG4gICAgICAgICAgYmF0Y2gsXG4gICAgICAgICAgaG9va3MsXG4gICAgICAgICAgdW5zdGFibGVfX3NpZGVFZmZlY3RzSW5SZW5kZXIsXG4gICAgICAgICAgY3JlYXRlU2VsZWN0b3JcbiAgICAgICAgfSxcbiAgICAgICAgc2VyaWFsaXplUXVlcnlBcmdzLFxuICAgICAgICBjb250ZXh0XG4gICAgICB9KTtcbiAgICAgIHNhZmVBc3NpZ24oYW55QXBpLCB7XG4gICAgICAgIHVzZVByZWZldGNoXG4gICAgICB9KTtcbiAgICAgIHNhZmVBc3NpZ24oY29udGV4dCwge1xuICAgICAgICBiYXRjaFxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbmplY3RFbmRwb2ludChlbmRwb2ludE5hbWUsIGRlZmluaXRpb24pIHtcbiAgICAgICAgICBpZiAoaXNRdWVyeURlZmluaXRpb24oZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgdXNlUXVlcnksXG4gICAgICAgICAgICAgIHVzZUxhenlRdWVyeSxcbiAgICAgICAgICAgICAgdXNlTGF6eVF1ZXJ5U3Vic2NyaXB0aW9uLFxuICAgICAgICAgICAgICB1c2VRdWVyeVN0YXRlLFxuICAgICAgICAgICAgICB1c2VRdWVyeVN1YnNjcmlwdGlvblxuICAgICAgICAgICAgfSA9IGJ1aWxkUXVlcnlIb29rcyhlbmRwb2ludE5hbWUpO1xuICAgICAgICAgICAgc2FmZUFzc2lnbihhbnlBcGkuZW5kcG9pbnRzW2VuZHBvaW50TmFtZV0sIHtcbiAgICAgICAgICAgICAgdXNlUXVlcnksXG4gICAgICAgICAgICAgIHVzZUxhenlRdWVyeSxcbiAgICAgICAgICAgICAgdXNlTGF6eVF1ZXJ5U3Vic2NyaXB0aW9uLFxuICAgICAgICAgICAgICB1c2VRdWVyeVN0YXRlLFxuICAgICAgICAgICAgICB1c2VRdWVyeVN1YnNjcmlwdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhcGlbYHVzZSR7Y2FwaXRhbGl6ZShlbmRwb2ludE5hbWUpfVF1ZXJ5YF0gPSB1c2VRdWVyeTtcbiAgICAgICAgICAgIGFwaVtgdXNlTGF6eSR7Y2FwaXRhbGl6ZShlbmRwb2ludE5hbWUpfVF1ZXJ5YF0gPSB1c2VMYXp5UXVlcnk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc011dGF0aW9uRGVmaW5pdGlvbihkZWZpbml0aW9uKSkge1xuICAgICAgICAgICAgY29uc3QgdXNlTXV0YXRpb24gPSBidWlsZE11dGF0aW9uSG9vayhlbmRwb2ludE5hbWUpO1xuICAgICAgICAgICAgc2FmZUFzc2lnbihhbnlBcGkuZW5kcG9pbnRzW2VuZHBvaW50TmFtZV0sIHtcbiAgICAgICAgICAgICAgdXNlTXV0YXRpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXBpW2B1c2Uke2NhcGl0YWxpemUoZW5kcG9pbnROYW1lKX1NdXRhdGlvbmBdID0gdXNlTXV0YXRpb247XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0luZmluaXRlUXVlcnlEZWZpbml0aW9uKGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIHVzZUluZmluaXRlUXVlcnksXG4gICAgICAgICAgICAgIHVzZUluZmluaXRlUXVlcnlTdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgIHVzZUluZmluaXRlUXVlcnlTdGF0ZVxuICAgICAgICAgICAgfSA9IGJ1aWxkSW5maW5pdGVRdWVyeUhvb2tzKGVuZHBvaW50TmFtZSk7XG4gICAgICAgICAgICBzYWZlQXNzaWduKGFueUFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXSwge1xuICAgICAgICAgICAgICB1c2VJbmZpbml0ZVF1ZXJ5LFxuICAgICAgICAgICAgICB1c2VJbmZpbml0ZVF1ZXJ5U3Vic2NyaXB0aW9uLFxuICAgICAgICAgICAgICB1c2VJbmZpbml0ZVF1ZXJ5U3RhdGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXBpW2B1c2Uke2NhcGl0YWxpemUoZW5kcG9pbnROYW1lKX1JbmZpbml0ZVF1ZXJ5YF0gPSB1c2VJbmZpbml0ZVF1ZXJ5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59O1xuXG4vLyBzcmMvcXVlcnkvcmVhY3QvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJAcmVkdXhqcy90b29sa2l0L3F1ZXJ5XCI7XG5cbi8vIHNyYy9xdWVyeS9yZWFjdC9BcGlQcm92aWRlci50c3hcbmltcG9ydCB7IGNvbmZpZ3VyZVN0b3JlLCBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlNCB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XG5pbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0NCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBQcm92aWRlciwgUmVhY3RSZWR1eENvbnRleHQgfSBmcm9tIFwicmVhY3QtcmVkdXhcIjtcbmltcG9ydCB7IHNldHVwTGlzdGVuZXJzIH0gZnJvbSBcIkByZWR1eGpzL3Rvb2xraXQvcXVlcnlcIjtcbmZ1bmN0aW9uIEFwaVByb3ZpZGVyKHByb3BzKSB7XG4gIGNvbnN0IGNvbnRleHQgPSBwcm9wcy5jb250ZXh0IHx8IFJlYWN0UmVkdXhDb250ZXh0O1xuICBjb25zdCBleGlzdGluZ0NvbnRleHQgPSB1c2VDb250ZXh0KGNvbnRleHQpO1xuICBpZiAoZXhpc3RpbmdDb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlNCgzNSkgOiBcIkV4aXN0aW5nIFJlZHV4IGNvbnRleHQgZGV0ZWN0ZWQuIElmIHlvdSBhbHJlYWR5IGhhdmUgYSBzdG9yZSBzZXQgdXAsIHBsZWFzZSB1c2UgdGhlIHRyYWRpdGlvbmFsIFJlZHV4IHNldHVwLlwiKTtcbiAgfVxuICBjb25zdCBbc3RvcmVdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gY29uZmlndXJlU3RvcmUoe1xuICAgIHJlZHVjZXI6IHtcbiAgICAgIFtwcm9wcy5hcGkucmVkdWNlclBhdGhdOiBwcm9wcy5hcGkucmVkdWNlclxuICAgIH0sXG4gICAgbWlkZGxld2FyZTogKGdETSkgPT4gZ0RNKCkuY29uY2F0KHByb3BzLmFwaS5taWRkbGV3YXJlKVxuICB9KSk7XG4gIHVzZUVmZmVjdDQoKCkgPT4gcHJvcHMuc2V0dXBMaXN0ZW5lcnMgPT09IGZhbHNlID8gdm9pZCAwIDogc2V0dXBMaXN0ZW5lcnMoc3RvcmUuZGlzcGF0Y2gsIHByb3BzLnNldHVwTGlzdGVuZXJzKSwgW3Byb3BzLnNldHVwTGlzdGVuZXJzLCBzdG9yZS5kaXNwYXRjaF0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUHJvdmlkZXIsIHsgc3RvcmUsIGNvbnRleHQgfSwgcHJvcHMuY2hpbGRyZW4pO1xufVxuXG4vLyBzcmMvcXVlcnkvcmVhY3QvaW5kZXgudHNcbnZhciBjcmVhdGVBcGkgPSAvKiBAX19QVVJFX18gKi8gYnVpbGRDcmVhdGVBcGkoY29yZU1vZHVsZSgpLCByZWFjdEhvb2tzTW9kdWxlKCkpO1xuZXhwb3J0IHtcbiAgQXBpUHJvdmlkZXIsXG4gIFVOSU5JVElBTElaRURfVkFMVUUsXG4gIGNyZWF0ZUFwaSxcbiAgcmVhY3RIb29rc01vZHVsZSxcbiAgcmVhY3RIb29rc01vZHVsZU5hbWVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ydGstcXVlcnktcmVhY3QubW9kZXJuLm1qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reduxjs/toolkit/dist/query/react/rtk-query-react.modern.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@reduxjs/toolkit/dist/query/rtk-query.modern.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/dist/query/rtk-query.modern.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NamedSchemaError: () => (/* binding */ NamedSchemaError),\n/* harmony export */   QueryStatus: () => (/* binding */ QueryStatus),\n/* harmony export */   _NEVER: () => (/* binding */ _NEVER),\n/* harmony export */   buildCreateApi: () => (/* binding */ buildCreateApi),\n/* harmony export */   copyWithStructuralSharing: () => (/* binding */ copyWithStructuralSharing),\n/* harmony export */   coreModule: () => (/* binding */ coreModule),\n/* harmony export */   coreModuleName: () => (/* binding */ coreModuleName),\n/* harmony export */   createApi: () => (/* binding */ createApi),\n/* harmony export */   defaultSerializeQueryArgs: () => (/* binding */ defaultSerializeQueryArgs),\n/* harmony export */   fakeBaseQuery: () => (/* binding */ fakeBaseQuery),\n/* harmony export */   fetchBaseQuery: () => (/* binding */ fetchBaseQuery),\n/* harmony export */   retry: () => (/* binding */ retry),\n/* harmony export */   setupListeners: () => (/* binding */ setupListeners),\n/* harmony export */   skipToken: () => (/* binding */ skipToken)\n/* harmony export */ });\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(ssr)/./node_modules/redux/dist/redux.mjs\");\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\");\n/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/immer.mjs\");\n/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! reselect */ \"(ssr)/./node_modules/reselect/dist/reselect.mjs\");\n/* harmony import */ var _standard_schema_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @standard-schema/utils */ \"(ssr)/./node_modules/@standard-schema/utils/dist/index.js\");\n// src/query/core/apiState.ts\nvar QueryStatus = /* @__PURE__ */ ((QueryStatus2) => {\n  QueryStatus2[\"uninitialized\"] = \"uninitialized\";\n  QueryStatus2[\"pending\"] = \"pending\";\n  QueryStatus2[\"fulfilled\"] = \"fulfilled\";\n  QueryStatus2[\"rejected\"] = \"rejected\";\n  return QueryStatus2;\n})(QueryStatus || {});\nfunction getRequestStatusFlags(status) {\n  return {\n    status,\n    isUninitialized: status === \"uninitialized\" /* uninitialized */,\n    isLoading: status === \"pending\" /* pending */,\n    isSuccess: status === \"fulfilled\" /* fulfilled */,\n    isError: status === \"rejected\" /* rejected */\n  };\n}\n\n// src/query/core/rtkImports.ts\n\n\n// src/query/utils/copyWithStructuralSharing.ts\nvar isPlainObject2 = _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPlainObject;\nfunction copyWithStructuralSharing(oldObj, newObj) {\n  if (oldObj === newObj || !(isPlainObject2(oldObj) && isPlainObject2(newObj) || Array.isArray(oldObj) && Array.isArray(newObj))) {\n    return newObj;\n  }\n  const newKeys = Object.keys(newObj);\n  const oldKeys = Object.keys(oldObj);\n  let isSameObject = newKeys.length === oldKeys.length;\n  const mergeObj = Array.isArray(newObj) ? [] : {};\n  for (const key of newKeys) {\n    mergeObj[key] = copyWithStructuralSharing(oldObj[key], newObj[key]);\n    if (isSameObject) isSameObject = oldObj[key] === mergeObj[key];\n  }\n  return isSameObject ? oldObj : mergeObj;\n}\n\n// src/query/utils/flatten.ts\nvar flatten = (arr) => [].concat(...arr);\n\n// src/query/utils/isAbsoluteUrl.ts\nfunction isAbsoluteUrl(url) {\n  return new RegExp(`(^|:)//`).test(url);\n}\n\n// src/query/utils/isDocumentVisible.ts\nfunction isDocumentVisible() {\n  if (typeof document === \"undefined\") {\n    return true;\n  }\n  return document.visibilityState !== \"hidden\";\n}\n\n// src/query/utils/isNotNullish.ts\nfunction isNotNullish(v) {\n  return v != null;\n}\nfunction filterNullishValues(map) {\n  return [...map?.values() ?? []].filter(isNotNullish);\n}\n\n// src/query/utils/isOnline.ts\nfunction isOnline() {\n  return typeof navigator === \"undefined\" ? true : navigator.onLine === void 0 ? true : navigator.onLine;\n}\n\n// src/query/utils/joinUrls.ts\nvar withoutTrailingSlash = (url) => url.replace(/\\/$/, \"\");\nvar withoutLeadingSlash = (url) => url.replace(/^\\//, \"\");\nfunction joinUrls(base, url) {\n  if (!base) {\n    return url;\n  }\n  if (!url) {\n    return base;\n  }\n  if (isAbsoluteUrl(url)) {\n    return url;\n  }\n  const delimiter = base.endsWith(\"/\") || !url.startsWith(\"?\") ? \"/\" : \"\";\n  base = withoutTrailingSlash(base);\n  url = withoutLeadingSlash(url);\n  return `${base}${delimiter}${url}`;\n}\n\n// src/query/utils/getOrInsert.ts\nfunction getOrInsertComputed(map, key, compute) {\n  if (map.has(key)) return map.get(key);\n  return map.set(key, compute(key)).get(key);\n}\nvar createNewMap = () => /* @__PURE__ */ new Map();\n\n// src/query/fetchBaseQuery.ts\nvar defaultFetchFn = (...args) => fetch(...args);\nvar defaultValidateStatus = (response) => response.status >= 200 && response.status <= 299;\nvar defaultIsJsonContentType = (headers) => (\n  /*applicat*/\n  /ion\\/(vnd\\.api\\+)?json/.test(headers.get(\"content-type\") || \"\")\n);\nfunction stripUndefined(obj) {\n  if (!(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(obj)) {\n    return obj;\n  }\n  const copy = {\n    ...obj\n  };\n  for (const [k, v] of Object.entries(copy)) {\n    if (v === void 0) delete copy[k];\n  }\n  return copy;\n}\nvar isJsonifiable = (body) => typeof body === \"object\" && ((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(body) || Array.isArray(body) || typeof body.toJSON === \"function\");\nfunction fetchBaseQuery({\n  baseUrl,\n  prepareHeaders = (x) => x,\n  fetchFn = defaultFetchFn,\n  paramsSerializer,\n  isJsonContentType = defaultIsJsonContentType,\n  jsonContentType = \"application/json\",\n  jsonReplacer,\n  timeout: defaultTimeout,\n  responseHandler: globalResponseHandler,\n  validateStatus: globalValidateStatus,\n  ...baseFetchOptions\n} = {}) {\n  if (typeof fetch === \"undefined\" && fetchFn === defaultFetchFn) {\n    console.warn(\"Warning: `fetch` is not available. Please supply a custom `fetchFn` property to use `fetchBaseQuery` on SSR environments.\");\n  }\n  return async (arg, api, extraOptions) => {\n    const {\n      getState,\n      extra,\n      endpoint,\n      forced,\n      type\n    } = api;\n    let meta;\n    let {\n      url,\n      headers = new Headers(baseFetchOptions.headers),\n      params = void 0,\n      responseHandler = globalResponseHandler ?? \"json\",\n      validateStatus = globalValidateStatus ?? defaultValidateStatus,\n      timeout = defaultTimeout,\n      ...rest\n    } = typeof arg == \"string\" ? {\n      url: arg\n    } : arg;\n    let abortController, signal = api.signal;\n    if (timeout) {\n      abortController = new AbortController();\n      api.signal.addEventListener(\"abort\", abortController.abort);\n      signal = abortController.signal;\n    }\n    let config = {\n      ...baseFetchOptions,\n      signal,\n      ...rest\n    };\n    headers = new Headers(stripUndefined(headers));\n    config.headers = await prepareHeaders(headers, {\n      getState,\n      arg,\n      extra,\n      endpoint,\n      forced,\n      type,\n      extraOptions\n    }) || headers;\n    const bodyIsJsonifiable = isJsonifiable(config.body);\n    if (config.body != null && !bodyIsJsonifiable && typeof config.body !== \"string\") {\n      config.headers.delete(\"content-type\");\n    }\n    if (!config.headers.has(\"content-type\") && bodyIsJsonifiable) {\n      config.headers.set(\"content-type\", jsonContentType);\n    }\n    if (bodyIsJsonifiable && isJsonContentType(config.headers)) {\n      config.body = JSON.stringify(config.body, jsonReplacer);\n    }\n    if (!config.headers.has(\"accept\")) {\n      if (responseHandler === \"json\") {\n        config.headers.set(\"accept\", \"application/json\");\n      } else if (responseHandler === \"text\") {\n        config.headers.set(\"accept\", \"text/plain, text/html, */*\");\n      }\n    }\n    if (params) {\n      const divider = ~url.indexOf(\"?\") ? \"&\" : \"?\";\n      const query = paramsSerializer ? paramsSerializer(params) : new URLSearchParams(stripUndefined(params));\n      url += divider + query;\n    }\n    url = joinUrls(baseUrl, url);\n    const request = new Request(url, config);\n    const requestClone = new Request(url, config);\n    meta = {\n      request: requestClone\n    };\n    let response, timedOut = false, timeoutId = abortController && setTimeout(() => {\n      timedOut = true;\n      abortController.abort();\n    }, timeout);\n    try {\n      response = await fetchFn(request);\n    } catch (e) {\n      return {\n        error: {\n          status: timedOut ? \"TIMEOUT_ERROR\" : \"FETCH_ERROR\",\n          error: String(e)\n        },\n        meta\n      };\n    } finally {\n      if (timeoutId) clearTimeout(timeoutId);\n      abortController?.signal.removeEventListener(\"abort\", abortController.abort);\n    }\n    const responseClone = response.clone();\n    meta.response = responseClone;\n    let resultData;\n    let responseText = \"\";\n    try {\n      let handleResponseError;\n      await Promise.all([\n        handleResponse(response, responseHandler).then((r) => resultData = r, (e) => handleResponseError = e),\n        // see https://github.com/node-fetch/node-fetch/issues/665#issuecomment-538995182\n        // we *have* to \"use up\" both streams at the same time or they will stop running in node-fetch scenarios\n        responseClone.text().then((r) => responseText = r, () => {\n        })\n      ]);\n      if (handleResponseError) throw handleResponseError;\n    } catch (e) {\n      return {\n        error: {\n          status: \"PARSING_ERROR\",\n          originalStatus: response.status,\n          data: responseText,\n          error: String(e)\n        },\n        meta\n      };\n    }\n    return validateStatus(response, resultData) ? {\n      data: resultData,\n      meta\n    } : {\n      error: {\n        status: response.status,\n        data: resultData\n      },\n      meta\n    };\n  };\n  async function handleResponse(response, responseHandler) {\n    if (typeof responseHandler === \"function\") {\n      return responseHandler(response);\n    }\n    if (responseHandler === \"content-type\") {\n      responseHandler = isJsonContentType(response.headers) ? \"json\" : \"text\";\n    }\n    if (responseHandler === \"json\") {\n      const text = await response.text();\n      return text.length ? JSON.parse(text) : null;\n    }\n    return response.text();\n  }\n}\n\n// src/query/HandledError.ts\nvar HandledError = class {\n  constructor(value, meta = void 0) {\n    this.value = value;\n    this.meta = meta;\n  }\n};\n\n// src/query/retry.ts\nasync function defaultBackoff(attempt = 0, maxRetries = 5, signal) {\n  const attempts = Math.min(attempt, maxRetries);\n  const timeout = ~~((Math.random() + 0.4) * (300 << attempts));\n  await new Promise((resolve, reject) => {\n    const timeoutId = setTimeout(() => resolve(), timeout);\n    if (signal) {\n      const abortHandler = () => {\n        clearTimeout(timeoutId);\n        reject(new Error(\"Aborted\"));\n      };\n      if (signal.aborted) {\n        clearTimeout(timeoutId);\n        reject(new Error(\"Aborted\"));\n      } else {\n        signal.addEventListener(\"abort\", abortHandler, {\n          once: true\n        });\n      }\n    }\n  });\n}\nfunction fail(error, meta) {\n  throw Object.assign(new HandledError({\n    error,\n    meta\n  }), {\n    throwImmediately: true\n  });\n}\nfunction failIfAborted(signal) {\n  if (signal.aborted) {\n    fail({\n      status: \"CUSTOM_ERROR\",\n      error: \"Aborted\"\n    });\n  }\n}\nvar EMPTY_OPTIONS = {};\nvar retryWithBackoff = (baseQuery, defaultOptions) => async (args, api, extraOptions) => {\n  const possibleMaxRetries = [5, (defaultOptions || EMPTY_OPTIONS).maxRetries, (extraOptions || EMPTY_OPTIONS).maxRetries].filter((x) => x !== void 0);\n  const [maxRetries] = possibleMaxRetries.slice(-1);\n  const defaultRetryCondition = (_, __, {\n    attempt\n  }) => attempt <= maxRetries;\n  const options = {\n    maxRetries,\n    backoff: defaultBackoff,\n    retryCondition: defaultRetryCondition,\n    ...defaultOptions,\n    ...extraOptions\n  };\n  let retry2 = 0;\n  while (true) {\n    failIfAborted(api.signal);\n    try {\n      const result = await baseQuery(args, api, extraOptions);\n      if (result.error) {\n        throw new HandledError(result);\n      }\n      return result;\n    } catch (e) {\n      retry2++;\n      if (e.throwImmediately) {\n        if (e instanceof HandledError) {\n          return e.value;\n        }\n        throw e;\n      }\n      if (e instanceof HandledError) {\n        if (!options.retryCondition(e.value.error, args, {\n          attempt: retry2,\n          baseQueryApi: api,\n          extraOptions\n        })) {\n          return e.value;\n        }\n      } else {\n        if (retry2 > options.maxRetries) {\n          return {\n            error: e\n          };\n        }\n      }\n      failIfAborted(api.signal);\n      try {\n        await options.backoff(retry2, options.maxRetries, api.signal);\n      } catch (backoffError) {\n        failIfAborted(api.signal);\n        throw backoffError;\n      }\n    }\n  }\n};\nvar retry = /* @__PURE__ */ Object.assign(retryWithBackoff, {\n  fail\n});\n\n// src/query/core/setupListeners.ts\nvar onFocus = /* @__PURE__ */ (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAction)(\"__rtkq/focused\");\nvar onFocusLost = /* @__PURE__ */ (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAction)(\"__rtkq/unfocused\");\nvar onOnline = /* @__PURE__ */ (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAction)(\"__rtkq/online\");\nvar onOffline = /* @__PURE__ */ (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAction)(\"__rtkq/offline\");\nvar initialized = false;\nfunction setupListeners(dispatch, customHandler) {\n  function defaultHandler() {\n    const handleFocus = () => dispatch(onFocus());\n    const handleFocusLost = () => dispatch(onFocusLost());\n    const handleOnline = () => dispatch(onOnline());\n    const handleOffline = () => dispatch(onOffline());\n    const handleVisibilityChange = () => {\n      if (window.document.visibilityState === \"visible\") {\n        handleFocus();\n      } else {\n        handleFocusLost();\n      }\n    };\n    if (!initialized) {\n      if (typeof window !== \"undefined\" && window.addEventListener) {\n        window.addEventListener(\"visibilitychange\", handleVisibilityChange, false);\n        window.addEventListener(\"focus\", handleFocus, false);\n        window.addEventListener(\"online\", handleOnline, false);\n        window.addEventListener(\"offline\", handleOffline, false);\n        initialized = true;\n      }\n    }\n    const unsubscribe = () => {\n      window.removeEventListener(\"focus\", handleFocus);\n      window.removeEventListener(\"visibilitychange\", handleVisibilityChange);\n      window.removeEventListener(\"online\", handleOnline);\n      window.removeEventListener(\"offline\", handleOffline);\n      initialized = false;\n    };\n    return unsubscribe;\n  }\n  return customHandler ? customHandler(dispatch, {\n    onFocus,\n    onFocusLost,\n    onOffline,\n    onOnline\n  }) : defaultHandler();\n}\n\n// src/query/endpointDefinitions.ts\nfunction isQueryDefinition(e) {\n  return e.type === \"query\" /* query */;\n}\nfunction isMutationDefinition(e) {\n  return e.type === \"mutation\" /* mutation */;\n}\nfunction isInfiniteQueryDefinition(e) {\n  return e.type === \"infinitequery\" /* infinitequery */;\n}\nfunction isAnyQueryDefinition(e) {\n  return isQueryDefinition(e) || isInfiniteQueryDefinition(e);\n}\nfunction calculateProvidedBy(description, result, error, queryArg, meta, assertTagTypes) {\n  if (isFunction(description)) {\n    return description(result, error, queryArg, meta).filter(isNotNullish).map(expandTagDescription).map(assertTagTypes);\n  }\n  if (Array.isArray(description)) {\n    return description.map(expandTagDescription).map(assertTagTypes);\n  }\n  return [];\n}\nfunction isFunction(t) {\n  return typeof t === \"function\";\n}\nfunction expandTagDescription(description) {\n  return typeof description === \"string\" ? {\n    type: description\n  } : description;\n}\n\n// src/query/core/buildThunks.ts\n\n\n// src/query/core/buildInitiate.ts\n\n\n// src/tsHelpers.ts\nfunction asSafePromise(promise, fallback) {\n  return promise.catch(fallback);\n}\n\n// src/query/core/buildInitiate.ts\nvar forceQueryFnSymbol = Symbol(\"forceQueryFn\");\nvar isUpsertQuery = (arg) => typeof arg[forceQueryFnSymbol] === \"function\";\nfunction buildInitiate({\n  serializeQueryArgs,\n  queryThunk,\n  infiniteQueryThunk,\n  mutationThunk,\n  api,\n  context,\n  getInternalState\n}) {\n  const getRunningQueries = (dispatch) => getInternalState(dispatch)?.runningQueries;\n  const getRunningMutations = (dispatch) => getInternalState(dispatch)?.runningMutations;\n  const {\n    unsubscribeQueryResult,\n    removeMutationResult,\n    updateSubscriptionOptions\n  } = api.internalActions;\n  return {\n    buildInitiateQuery,\n    buildInitiateInfiniteQuery,\n    buildInitiateMutation,\n    getRunningQueryThunk,\n    getRunningMutationThunk,\n    getRunningQueriesThunk,\n    getRunningMutationsThunk\n  };\n  function getRunningQueryThunk(endpointName, queryArgs) {\n    return (dispatch) => {\n      const endpointDefinition = context.endpointDefinitions[endpointName];\n      const queryCacheKey = serializeQueryArgs({\n        queryArgs,\n        endpointDefinition,\n        endpointName\n      });\n      return getRunningQueries(dispatch)?.get(queryCacheKey);\n    };\n  }\n  function getRunningMutationThunk(_endpointName, fixedCacheKeyOrRequestId) {\n    return (dispatch) => {\n      return getRunningMutations(dispatch)?.get(fixedCacheKeyOrRequestId);\n    };\n  }\n  function getRunningQueriesThunk() {\n    return (dispatch) => filterNullishValues(getRunningQueries(dispatch));\n  }\n  function getRunningMutationsThunk() {\n    return (dispatch) => filterNullishValues(getRunningMutations(dispatch));\n  }\n  function middlewareWarning(dispatch) {\n    if (true) {\n      if (middlewareWarning.triggered) return;\n      const returnedValue = dispatch(api.internalActions.internal_getRTKQSubscriptions());\n      middlewareWarning.triggered = true;\n      if (typeof returnedValue !== \"object\" || typeof returnedValue?.type === \"string\") {\n        throw new Error( false ? 0 : `Warning: Middleware for RTK-Query API at reducerPath \"${api.reducerPath}\" has not been added to the store.\nYou must add the middleware for RTK-Query to function correctly!`);\n      }\n    }\n  }\n  function buildInitiateAnyQuery(endpointName, endpointDefinition) {\n    const queryAction = (arg, {\n      subscribe = true,\n      forceRefetch,\n      subscriptionOptions,\n      [forceQueryFnSymbol]: forceQueryFn,\n      ...rest\n    } = {}) => (dispatch, getState) => {\n      const queryCacheKey = serializeQueryArgs({\n        queryArgs: arg,\n        endpointDefinition,\n        endpointName\n      });\n      let thunk;\n      const commonThunkArgs = {\n        ...rest,\n        type: \"query\",\n        subscribe,\n        forceRefetch,\n        subscriptionOptions,\n        endpointName,\n        originalArgs: arg,\n        queryCacheKey,\n        [forceQueryFnSymbol]: forceQueryFn\n      };\n      if (isQueryDefinition(endpointDefinition)) {\n        thunk = queryThunk(commonThunkArgs);\n      } else {\n        const {\n          direction,\n          initialPageParam\n        } = rest;\n        thunk = infiniteQueryThunk({\n          ...commonThunkArgs,\n          // Supply these even if undefined. This helps with a field existence\n          // check over in `buildSlice.ts`\n          direction,\n          initialPageParam\n        });\n      }\n      const selector = api.endpoints[endpointName].select(arg);\n      const thunkResult = dispatch(thunk);\n      const stateAfter = selector(getState());\n      middlewareWarning(dispatch);\n      const {\n        requestId,\n        abort\n      } = thunkResult;\n      const skippedSynchronously = stateAfter.requestId !== requestId;\n      const runningQuery = getRunningQueries(dispatch)?.get(queryCacheKey);\n      const selectFromState = () => selector(getState());\n      const statePromise = Object.assign(forceQueryFn ? (\n        // a query has been forced (upsertQueryData)\n        // -> we want to resolve it once data has been written with the data that will be written\n        thunkResult.then(selectFromState)\n      ) : skippedSynchronously && !runningQuery ? (\n        // a query has been skipped due to a condition and we do not have any currently running query\n        // -> we want to resolve it immediately with the current data\n        Promise.resolve(stateAfter)\n      ) : (\n        // query just started or one is already in flight\n        // -> wait for the running query, then resolve with data from after that\n        Promise.all([runningQuery, thunkResult]).then(selectFromState)\n      ), {\n        arg,\n        requestId,\n        subscriptionOptions,\n        queryCacheKey,\n        abort,\n        async unwrap() {\n          const result = await statePromise;\n          if (result.isError) {\n            throw result.error;\n          }\n          return result.data;\n        },\n        refetch: () => dispatch(queryAction(arg, {\n          subscribe: false,\n          forceRefetch: true\n        })),\n        unsubscribe() {\n          if (subscribe) dispatch(unsubscribeQueryResult({\n            queryCacheKey,\n            requestId\n          }));\n        },\n        updateSubscriptionOptions(options) {\n          statePromise.subscriptionOptions = options;\n          dispatch(updateSubscriptionOptions({\n            endpointName,\n            requestId,\n            queryCacheKey,\n            options\n          }));\n        }\n      });\n      if (!runningQuery && !skippedSynchronously && !forceQueryFn) {\n        const runningQueries = getRunningQueries(dispatch);\n        runningQueries.set(queryCacheKey, statePromise);\n        statePromise.then(() => {\n          runningQueries.delete(queryCacheKey);\n        });\n      }\n      return statePromise;\n    };\n    return queryAction;\n  }\n  function buildInitiateQuery(endpointName, endpointDefinition) {\n    const queryAction = buildInitiateAnyQuery(endpointName, endpointDefinition);\n    return queryAction;\n  }\n  function buildInitiateInfiniteQuery(endpointName, endpointDefinition) {\n    const infiniteQueryAction = buildInitiateAnyQuery(endpointName, endpointDefinition);\n    return infiniteQueryAction;\n  }\n  function buildInitiateMutation(endpointName) {\n    return (arg, {\n      track = true,\n      fixedCacheKey\n    } = {}) => (dispatch, getState) => {\n      const thunk = mutationThunk({\n        type: \"mutation\",\n        endpointName,\n        originalArgs: arg,\n        track,\n        fixedCacheKey\n      });\n      const thunkResult = dispatch(thunk);\n      middlewareWarning(dispatch);\n      const {\n        requestId,\n        abort,\n        unwrap\n      } = thunkResult;\n      const returnValuePromise = asSafePromise(thunkResult.unwrap().then((data) => ({\n        data\n      })), (error) => ({\n        error\n      }));\n      const reset = () => {\n        dispatch(removeMutationResult({\n          requestId,\n          fixedCacheKey\n        }));\n      };\n      const ret = Object.assign(returnValuePromise, {\n        arg: thunkResult.arg,\n        requestId,\n        abort,\n        unwrap,\n        reset\n      });\n      const runningMutations = getRunningMutations(dispatch);\n      runningMutations.set(requestId, ret);\n      ret.then(() => {\n        runningMutations.delete(requestId);\n      });\n      if (fixedCacheKey) {\n        runningMutations.set(fixedCacheKey, ret);\n        ret.then(() => {\n          if (runningMutations.get(fixedCacheKey) === ret) {\n            runningMutations.delete(fixedCacheKey);\n          }\n        });\n      }\n      return ret;\n    };\n  }\n}\n\n// src/query/standardSchema.ts\n\nvar NamedSchemaError = class extends _standard_schema_utils__WEBPACK_IMPORTED_MODULE_2__.SchemaError {\n  constructor(issues, value, schemaName, _bqMeta) {\n    super(issues);\n    this.value = value;\n    this.schemaName = schemaName;\n    this._bqMeta = _bqMeta;\n  }\n};\nvar shouldSkip = (skipSchemaValidation, schemaName) => Array.isArray(skipSchemaValidation) ? skipSchemaValidation.includes(schemaName) : !!skipSchemaValidation;\nasync function parseWithSchema(schema, data, schemaName, bqMeta) {\n  const result = await schema[\"~standard\"].validate(data);\n  if (result.issues) {\n    throw new NamedSchemaError(result.issues, data, schemaName, bqMeta);\n  }\n  return result.value;\n}\n\n// src/query/core/buildThunks.ts\nfunction defaultTransformResponse(baseQueryReturnValue) {\n  return baseQueryReturnValue;\n}\nvar addShouldAutoBatch = (arg = {}) => {\n  return {\n    ...arg,\n    [_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.SHOULD_AUTOBATCH]: true\n  };\n};\nfunction buildThunks({\n  reducerPath,\n  baseQuery,\n  context: {\n    endpointDefinitions\n  },\n  serializeQueryArgs,\n  api,\n  assertTagType,\n  selectors,\n  onSchemaFailure,\n  catchSchemaFailure: globalCatchSchemaFailure,\n  skipSchemaValidation: globalSkipSchemaValidation\n}) {\n  const patchQueryData = (endpointName, arg, patches, updateProvided) => (dispatch, getState) => {\n    const endpointDefinition = endpointDefinitions[endpointName];\n    const queryCacheKey = serializeQueryArgs({\n      queryArgs: arg,\n      endpointDefinition,\n      endpointName\n    });\n    dispatch(api.internalActions.queryResultPatched({\n      queryCacheKey,\n      patches\n    }));\n    if (!updateProvided) {\n      return;\n    }\n    const newValue = api.endpoints[endpointName].select(arg)(\n      // Work around TS 4.1 mismatch\n      getState()\n    );\n    const providedTags = calculateProvidedBy(endpointDefinition.providesTags, newValue.data, void 0, arg, {}, assertTagType);\n    dispatch(api.internalActions.updateProvidedBy([{\n      queryCacheKey,\n      providedTags\n    }]));\n  };\n  function addToStart(items, item, max = 0) {\n    const newItems = [item, ...items];\n    return max && newItems.length > max ? newItems.slice(0, -1) : newItems;\n  }\n  function addToEnd(items, item, max = 0) {\n    const newItems = [...items, item];\n    return max && newItems.length > max ? newItems.slice(1) : newItems;\n  }\n  const updateQueryData = (endpointName, arg, updateRecipe, updateProvided = true) => (dispatch, getState) => {\n    const endpointDefinition = api.endpoints[endpointName];\n    const currentState = endpointDefinition.select(arg)(\n      // Work around TS 4.1 mismatch\n      getState()\n    );\n    const ret = {\n      patches: [],\n      inversePatches: [],\n      undo: () => dispatch(api.util.patchQueryData(endpointName, arg, ret.inversePatches, updateProvided))\n    };\n    if (currentState.status === \"uninitialized\" /* uninitialized */) {\n      return ret;\n    }\n    let newValue;\n    if (\"data\" in currentState) {\n      if ((0,immer__WEBPACK_IMPORTED_MODULE_3__.isDraftable)(currentState.data)) {\n        const [value, patches, inversePatches] = (0,immer__WEBPACK_IMPORTED_MODULE_3__.produceWithPatches)(currentState.data, updateRecipe);\n        ret.patches.push(...patches);\n        ret.inversePatches.push(...inversePatches);\n        newValue = value;\n      } else {\n        newValue = updateRecipe(currentState.data);\n        ret.patches.push({\n          op: \"replace\",\n          path: [],\n          value: newValue\n        });\n        ret.inversePatches.push({\n          op: \"replace\",\n          path: [],\n          value: currentState.data\n        });\n      }\n    }\n    if (ret.patches.length === 0) {\n      return ret;\n    }\n    dispatch(api.util.patchQueryData(endpointName, arg, ret.patches, updateProvided));\n    return ret;\n  };\n  const upsertQueryData = (endpointName, arg, value) => (dispatch) => {\n    const res = dispatch(api.endpoints[endpointName].initiate(arg, {\n      subscribe: false,\n      forceRefetch: true,\n      [forceQueryFnSymbol]: () => ({\n        data: value\n      })\n    }));\n    return res;\n  };\n  const getTransformCallbackForEndpoint = (endpointDefinition, transformFieldName) => {\n    return endpointDefinition.query && endpointDefinition[transformFieldName] ? endpointDefinition[transformFieldName] : defaultTransformResponse;\n  };\n  const executeEndpoint = async (arg, {\n    signal,\n    abort,\n    rejectWithValue,\n    fulfillWithValue,\n    dispatch,\n    getState,\n    extra\n  }) => {\n    const endpointDefinition = endpointDefinitions[arg.endpointName];\n    const {\n      metaSchema,\n      skipSchemaValidation = globalSkipSchemaValidation\n    } = endpointDefinition;\n    try {\n      let transformResponse = defaultTransformResponse;\n      const baseQueryApi = {\n        signal,\n        abort,\n        dispatch,\n        getState,\n        extra,\n        endpoint: arg.endpointName,\n        type: arg.type,\n        forced: arg.type === \"query\" ? isForcedQuery(arg, getState()) : void 0,\n        queryCacheKey: arg.type === \"query\" ? arg.queryCacheKey : void 0\n      };\n      const forceQueryFn = arg.type === \"query\" ? arg[forceQueryFnSymbol] : void 0;\n      let finalQueryReturnValue;\n      const fetchPage = async (data, param, maxPages, previous) => {\n        if (param == null && data.pages.length) {\n          return Promise.resolve({\n            data\n          });\n        }\n        const finalQueryArg = {\n          queryArg: arg.originalArgs,\n          pageParam: param\n        };\n        const pageResponse = await executeRequest(finalQueryArg);\n        const addTo = previous ? addToStart : addToEnd;\n        return {\n          data: {\n            pages: addTo(data.pages, pageResponse.data, maxPages),\n            pageParams: addTo(data.pageParams, param, maxPages)\n          },\n          meta: pageResponse.meta\n        };\n      };\n      async function executeRequest(finalQueryArg) {\n        let result;\n        const {\n          extraOptions,\n          argSchema,\n          rawResponseSchema,\n          responseSchema\n        } = endpointDefinition;\n        if (argSchema && !shouldSkip(skipSchemaValidation, \"arg\")) {\n          finalQueryArg = await parseWithSchema(\n            argSchema,\n            finalQueryArg,\n            \"argSchema\",\n            {}\n            // we don't have a meta yet, so we can't pass it\n          );\n        }\n        if (forceQueryFn) {\n          result = forceQueryFn();\n        } else if (endpointDefinition.query) {\n          transformResponse = getTransformCallbackForEndpoint(endpointDefinition, \"transformResponse\");\n          result = await baseQuery(endpointDefinition.query(finalQueryArg), baseQueryApi, extraOptions);\n        } else {\n          result = await endpointDefinition.queryFn(finalQueryArg, baseQueryApi, extraOptions, (arg2) => baseQuery(arg2, baseQueryApi, extraOptions));\n        }\n        if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n          const what = endpointDefinition.query ? \"`baseQuery`\" : \"`queryFn`\";\n          let err;\n          if (!result) {\n            err = `${what} did not return anything.`;\n          } else if (typeof result !== \"object\") {\n            err = `${what} did not return an object.`;\n          } else if (result.error && result.data) {\n            err = `${what} returned an object containing both \\`error\\` and \\`result\\`.`;\n          } else if (result.error === void 0 && result.data === void 0) {\n            err = `${what} returned an object containing neither a valid \\`error\\` and \\`result\\`. At least one of them should not be \\`undefined\\``;\n          } else {\n            for (const key of Object.keys(result)) {\n              if (key !== \"error\" && key !== \"data\" && key !== \"meta\") {\n                err = `The object returned by ${what} has the unknown property ${key}.`;\n                break;\n              }\n            }\n          }\n          if (err) {\n            console.error(`Error encountered handling the endpoint ${arg.endpointName}.\n                  ${err}\n                  It needs to return an object with either the shape \\`{ data: <value> }\\` or \\`{ error: <value> }\\` that may contain an optional \\`meta\\` property.\n                  Object returned was:`, result);\n          }\n        }\n        if (result.error) throw new HandledError(result.error, result.meta);\n        let {\n          data\n        } = result;\n        if (rawResponseSchema && !shouldSkip(skipSchemaValidation, \"rawResponse\")) {\n          data = await parseWithSchema(rawResponseSchema, result.data, \"rawResponseSchema\", result.meta);\n        }\n        let transformedResponse = await transformResponse(data, result.meta, finalQueryArg);\n        if (responseSchema && !shouldSkip(skipSchemaValidation, \"response\")) {\n          transformedResponse = await parseWithSchema(responseSchema, transformedResponse, \"responseSchema\", result.meta);\n        }\n        return {\n          ...result,\n          data: transformedResponse\n        };\n      }\n      if (arg.type === \"query\" && \"infiniteQueryOptions\" in endpointDefinition) {\n        const {\n          infiniteQueryOptions\n        } = endpointDefinition;\n        const {\n          maxPages = Infinity\n        } = infiniteQueryOptions;\n        let result;\n        const blankData = {\n          pages: [],\n          pageParams: []\n        };\n        const cachedData = selectors.selectQueryEntry(getState(), arg.queryCacheKey)?.data;\n        const isForcedQueryNeedingRefetch = (\n          // arg.forceRefetch\n          isForcedQuery(arg, getState()) && !arg.direction\n        );\n        const existingData = isForcedQueryNeedingRefetch || !cachedData ? blankData : cachedData;\n        if (\"direction\" in arg && arg.direction && existingData.pages.length) {\n          const previous = arg.direction === \"backward\";\n          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;\n          const param = pageParamFn(infiniteQueryOptions, existingData, arg.originalArgs);\n          result = await fetchPage(existingData, param, maxPages, previous);\n        } else {\n          const {\n            initialPageParam = infiniteQueryOptions.initialPageParam\n          } = arg;\n          const cachedPageParams = cachedData?.pageParams ?? [];\n          const firstPageParam = cachedPageParams[0] ?? initialPageParam;\n          const totalPages = cachedPageParams.length;\n          result = await fetchPage(existingData, firstPageParam, maxPages);\n          if (forceQueryFn) {\n            result = {\n              data: result.data.pages[0]\n            };\n          }\n          for (let i = 1; i < totalPages; i++) {\n            const param = getNextPageParam(infiniteQueryOptions, result.data, arg.originalArgs);\n            result = await fetchPage(result.data, param, maxPages);\n          }\n        }\n        finalQueryReturnValue = result;\n      } else {\n        finalQueryReturnValue = await executeRequest(arg.originalArgs);\n      }\n      if (metaSchema && !shouldSkip(skipSchemaValidation, \"meta\") && finalQueryReturnValue.meta) {\n        finalQueryReturnValue.meta = await parseWithSchema(metaSchema, finalQueryReturnValue.meta, \"metaSchema\", finalQueryReturnValue.meta);\n      }\n      return fulfillWithValue(finalQueryReturnValue.data, addShouldAutoBatch({\n        fulfilledTimeStamp: Date.now(),\n        baseQueryMeta: finalQueryReturnValue.meta\n      }));\n    } catch (error) {\n      let caughtError = error;\n      if (caughtError instanceof HandledError) {\n        let transformErrorResponse = getTransformCallbackForEndpoint(endpointDefinition, \"transformErrorResponse\");\n        const {\n          rawErrorResponseSchema,\n          errorResponseSchema\n        } = endpointDefinition;\n        let {\n          value,\n          meta\n        } = caughtError;\n        try {\n          if (rawErrorResponseSchema && !shouldSkip(skipSchemaValidation, \"rawErrorResponse\")) {\n            value = await parseWithSchema(rawErrorResponseSchema, value, \"rawErrorResponseSchema\", meta);\n          }\n          if (metaSchema && !shouldSkip(skipSchemaValidation, \"meta\")) {\n            meta = await parseWithSchema(metaSchema, meta, \"metaSchema\", meta);\n          }\n          let transformedErrorResponse = await transformErrorResponse(value, meta, arg.originalArgs);\n          if (errorResponseSchema && !shouldSkip(skipSchemaValidation, \"errorResponse\")) {\n            transformedErrorResponse = await parseWithSchema(errorResponseSchema, transformedErrorResponse, \"errorResponseSchema\", meta);\n          }\n          return rejectWithValue(transformedErrorResponse, addShouldAutoBatch({\n            baseQueryMeta: meta\n          }));\n        } catch (e) {\n          caughtError = e;\n        }\n      }\n      try {\n        if (caughtError instanceof NamedSchemaError) {\n          const info = {\n            endpoint: arg.endpointName,\n            arg: arg.originalArgs,\n            type: arg.type,\n            queryCacheKey: arg.type === \"query\" ? arg.queryCacheKey : void 0\n          };\n          endpointDefinition.onSchemaFailure?.(caughtError, info);\n          onSchemaFailure?.(caughtError, info);\n          const {\n            catchSchemaFailure = globalCatchSchemaFailure\n          } = endpointDefinition;\n          if (catchSchemaFailure) {\n            return rejectWithValue(catchSchemaFailure(caughtError, info), addShouldAutoBatch({\n              baseQueryMeta: caughtError._bqMeta\n            }));\n          }\n        }\n      } catch (e) {\n        caughtError = e;\n      }\n      if (typeof process !== \"undefined\" && \"development\" !== \"production\") {\n        console.error(`An unhandled error occurred processing a request for the endpoint \"${arg.endpointName}\".\nIn the case of an unhandled error, no tags will be \"provided\" or \"invalidated\".`, caughtError);\n      } else {\n        console.error(caughtError);\n      }\n      throw caughtError;\n    }\n  };\n  function isForcedQuery(arg, state) {\n    const requestState = selectors.selectQueryEntry(state, arg.queryCacheKey);\n    const baseFetchOnMountOrArgChange = selectors.selectConfig(state).refetchOnMountOrArgChange;\n    const fulfilledVal = requestState?.fulfilledTimeStamp;\n    const refetchVal = arg.forceRefetch ?? (arg.subscribe && baseFetchOnMountOrArgChange);\n    if (refetchVal) {\n      return refetchVal === true || (Number(/* @__PURE__ */ new Date()) - Number(fulfilledVal)) / 1e3 >= refetchVal;\n    }\n    return false;\n  }\n  const createQueryThunk = () => {\n    const generatedQueryThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAsyncThunk)(`${reducerPath}/executeQuery`, executeEndpoint, {\n      getPendingMeta({\n        arg\n      }) {\n        const endpointDefinition = endpointDefinitions[arg.endpointName];\n        return addShouldAutoBatch({\n          startedTimeStamp: Date.now(),\n          ...isInfiniteQueryDefinition(endpointDefinition) ? {\n            direction: arg.direction\n          } : {}\n        });\n      },\n      condition(queryThunkArg, {\n        getState\n      }) {\n        const state = getState();\n        const requestState = selectors.selectQueryEntry(state, queryThunkArg.queryCacheKey);\n        const fulfilledVal = requestState?.fulfilledTimeStamp;\n        const currentArg = queryThunkArg.originalArgs;\n        const previousArg = requestState?.originalArgs;\n        const endpointDefinition = endpointDefinitions[queryThunkArg.endpointName];\n        const direction = queryThunkArg.direction;\n        if (isUpsertQuery(queryThunkArg)) {\n          return true;\n        }\n        if (requestState?.status === \"pending\") {\n          return false;\n        }\n        if (isForcedQuery(queryThunkArg, state)) {\n          return true;\n        }\n        if (isQueryDefinition(endpointDefinition) && endpointDefinition?.forceRefetch?.({\n          currentArg,\n          previousArg,\n          endpointState: requestState,\n          state\n        })) {\n          return true;\n        }\n        if (fulfilledVal && !direction) {\n          return false;\n        }\n        return true;\n      },\n      dispatchConditionRejection: true\n    });\n    return generatedQueryThunk;\n  };\n  const queryThunk = createQueryThunk();\n  const infiniteQueryThunk = createQueryThunk();\n  const mutationThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAsyncThunk)(`${reducerPath}/executeMutation`, executeEndpoint, {\n    getPendingMeta() {\n      return addShouldAutoBatch({\n        startedTimeStamp: Date.now()\n      });\n    }\n  });\n  const hasTheForce = (options) => \"force\" in options;\n  const hasMaxAge = (options) => \"ifOlderThan\" in options;\n  const prefetch = (endpointName, arg, options = {}) => (dispatch, getState) => {\n    const force = hasTheForce(options) && options.force;\n    const maxAge = hasMaxAge(options) && options.ifOlderThan;\n    const queryAction = (force2 = true) => {\n      const options2 = {\n        forceRefetch: force2,\n        subscribe: false\n      };\n      return api.endpoints[endpointName].initiate(arg, options2);\n    };\n    const latestStateValue = api.endpoints[endpointName].select(arg)(getState());\n    if (force) {\n      dispatch(queryAction());\n    } else if (maxAge) {\n      const lastFulfilledTs = latestStateValue?.fulfilledTimeStamp;\n      if (!lastFulfilledTs) {\n        dispatch(queryAction());\n        return;\n      }\n      const shouldRetrigger = (Number(/* @__PURE__ */ new Date()) - Number(new Date(lastFulfilledTs))) / 1e3 >= maxAge;\n      if (shouldRetrigger) {\n        dispatch(queryAction());\n      }\n    } else {\n      dispatch(queryAction(false));\n    }\n  };\n  function matchesEndpoint(endpointName) {\n    return (action) => action?.meta?.arg?.endpointName === endpointName;\n  }\n  function buildMatchThunkActions(thunk, endpointName) {\n    return {\n      matchPending: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAllOf)((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isPending)(thunk), matchesEndpoint(endpointName)),\n      matchFulfilled: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAllOf)((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isFulfilled)(thunk), matchesEndpoint(endpointName)),\n      matchRejected: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAllOf)((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isRejected)(thunk), matchesEndpoint(endpointName))\n    };\n  }\n  return {\n    queryThunk,\n    mutationThunk,\n    infiniteQueryThunk,\n    prefetch,\n    updateQueryData,\n    upsertQueryData,\n    patchQueryData,\n    buildMatchThunkActions\n  };\n}\nfunction getNextPageParam(options, {\n  pages,\n  pageParams\n}, queryArg) {\n  const lastIndex = pages.length - 1;\n  return options.getNextPageParam(pages[lastIndex], pages, pageParams[lastIndex], pageParams, queryArg);\n}\nfunction getPreviousPageParam(options, {\n  pages,\n  pageParams\n}, queryArg) {\n  return options.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams, queryArg);\n}\nfunction calculateProvidedByThunk(action, type, endpointDefinitions, assertTagType) {\n  return calculateProvidedBy(endpointDefinitions[action.meta.arg.endpointName][type], (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isFulfilled)(action) ? action.payload : void 0, (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isRejectedWithValue)(action) ? action.payload : void 0, action.meta.arg.originalArgs, \"baseQueryMeta\" in action.meta ? action.meta.baseQueryMeta : void 0, assertTagType);\n}\n\n// src/query/core/buildSlice.ts\n\n\nfunction updateQuerySubstateIfExists(state, queryCacheKey, update) {\n  const substate = state[queryCacheKey];\n  if (substate) {\n    update(substate);\n  }\n}\nfunction getMutationCacheKey(id) {\n  return (\"arg\" in id ? id.arg.fixedCacheKey : id.fixedCacheKey) ?? id.requestId;\n}\nfunction updateMutationSubstateIfExists(state, id, update) {\n  const substate = state[getMutationCacheKey(id)];\n  if (substate) {\n    update(substate);\n  }\n}\nvar initialState = {};\nfunction buildSlice({\n  reducerPath,\n  queryThunk,\n  mutationThunk,\n  serializeQueryArgs,\n  context: {\n    endpointDefinitions: definitions,\n    apiUid,\n    extractRehydrationInfo,\n    hasRehydrationInfo\n  },\n  assertTagType,\n  config\n}) {\n  const resetApiState = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAction)(`${reducerPath}/resetApiState`);\n  function writePendingCacheEntry(draft, arg, upserting, meta) {\n    draft[arg.queryCacheKey] ??= {\n      status: \"uninitialized\" /* uninitialized */,\n      endpointName: arg.endpointName\n    };\n    updateQuerySubstateIfExists(draft, arg.queryCacheKey, (substate) => {\n      substate.status = \"pending\" /* pending */;\n      substate.requestId = upserting && substate.requestId ? (\n        // for `upsertQuery` **updates**, keep the current `requestId`\n        substate.requestId\n      ) : (\n        // for normal queries or `upsertQuery` **inserts** always update the `requestId`\n        meta.requestId\n      );\n      if (arg.originalArgs !== void 0) {\n        substate.originalArgs = arg.originalArgs;\n      }\n      substate.startedTimeStamp = meta.startedTimeStamp;\n      const endpointDefinition = definitions[meta.arg.endpointName];\n      if (isInfiniteQueryDefinition(endpointDefinition) && \"direction\" in arg) {\n        ;\n        substate.direction = arg.direction;\n      }\n    });\n  }\n  function writeFulfilledCacheEntry(draft, meta, payload, upserting) {\n    updateQuerySubstateIfExists(draft, meta.arg.queryCacheKey, (substate) => {\n      if (substate.requestId !== meta.requestId && !upserting) return;\n      const {\n        merge\n      } = definitions[meta.arg.endpointName];\n      substate.status = \"fulfilled\" /* fulfilled */;\n      if (merge) {\n        if (substate.data !== void 0) {\n          const {\n            fulfilledTimeStamp,\n            arg,\n            baseQueryMeta,\n            requestId\n          } = meta;\n          let newData = (0,immer__WEBPACK_IMPORTED_MODULE_3__.produce)(substate.data, (draftSubstateData) => {\n            return merge(draftSubstateData, payload, {\n              arg: arg.originalArgs,\n              baseQueryMeta,\n              fulfilledTimeStamp,\n              requestId\n            });\n          });\n          substate.data = newData;\n        } else {\n          substate.data = payload;\n        }\n      } else {\n        substate.data = definitions[meta.arg.endpointName].structuralSharing ?? true ? copyWithStructuralSharing((0,immer__WEBPACK_IMPORTED_MODULE_3__.isDraft)(substate.data) ? (0,immer__WEBPACK_IMPORTED_MODULE_3__.original)(substate.data) : substate.data, payload) : payload;\n      }\n      delete substate.error;\n      substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;\n    });\n  }\n  const querySlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createSlice)({\n    name: `${reducerPath}/queries`,\n    initialState,\n    reducers: {\n      removeQueryResult: {\n        reducer(draft, {\n          payload: {\n            queryCacheKey\n          }\n        }) {\n          delete draft[queryCacheKey];\n        },\n        prepare: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.prepareAutoBatched)()\n      },\n      cacheEntriesUpserted: {\n        reducer(draft, action) {\n          for (const entry of action.payload) {\n            const {\n              queryDescription: arg,\n              value\n            } = entry;\n            writePendingCacheEntry(draft, arg, true, {\n              arg,\n              requestId: action.meta.requestId,\n              startedTimeStamp: action.meta.timestamp\n            });\n            writeFulfilledCacheEntry(\n              draft,\n              {\n                arg,\n                requestId: action.meta.requestId,\n                fulfilledTimeStamp: action.meta.timestamp,\n                baseQueryMeta: {}\n              },\n              value,\n              // We know we're upserting here\n              true\n            );\n          }\n        },\n        prepare: (payload) => {\n          const queryDescriptions = payload.map((entry) => {\n            const {\n              endpointName,\n              arg,\n              value\n            } = entry;\n            const endpointDefinition = definitions[endpointName];\n            const queryDescription = {\n              type: \"query\",\n              endpointName,\n              originalArgs: entry.arg,\n              queryCacheKey: serializeQueryArgs({\n                queryArgs: arg,\n                endpointDefinition,\n                endpointName\n              })\n            };\n            return {\n              queryDescription,\n              value\n            };\n          });\n          const result = {\n            payload: queryDescriptions,\n            meta: {\n              [_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.SHOULD_AUTOBATCH]: true,\n              requestId: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.nanoid)(),\n              timestamp: Date.now()\n            }\n          };\n          return result;\n        }\n      },\n      queryResultPatched: {\n        reducer(draft, {\n          payload: {\n            queryCacheKey,\n            patches\n          }\n        }) {\n          updateQuerySubstateIfExists(draft, queryCacheKey, (substate) => {\n            substate.data = (0,immer__WEBPACK_IMPORTED_MODULE_3__.applyPatches)(substate.data, patches.concat());\n          });\n        },\n        prepare: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.prepareAutoBatched)()\n      }\n    },\n    extraReducers(builder) {\n      builder.addCase(queryThunk.pending, (draft, {\n        meta,\n        meta: {\n          arg\n        }\n      }) => {\n        const upserting = isUpsertQuery(arg);\n        writePendingCacheEntry(draft, arg, upserting, meta);\n      }).addCase(queryThunk.fulfilled, (draft, {\n        meta,\n        payload\n      }) => {\n        const upserting = isUpsertQuery(meta.arg);\n        writeFulfilledCacheEntry(draft, meta, payload, upserting);\n      }).addCase(queryThunk.rejected, (draft, {\n        meta: {\n          condition,\n          arg,\n          requestId\n        },\n        error,\n        payload\n      }) => {\n        updateQuerySubstateIfExists(draft, arg.queryCacheKey, (substate) => {\n          if (condition) {\n          } else {\n            if (substate.requestId !== requestId) return;\n            substate.status = \"rejected\" /* rejected */;\n            substate.error = payload ?? error;\n          }\n        });\n      }).addMatcher(hasRehydrationInfo, (draft, action) => {\n        const {\n          queries\n        } = extractRehydrationInfo(action);\n        for (const [key, entry] of Object.entries(queries)) {\n          if (\n            // do not rehydrate entries that were currently in flight.\n            entry?.status === \"fulfilled\" /* fulfilled */ || entry?.status === \"rejected\" /* rejected */\n          ) {\n            draft[key] = entry;\n          }\n        }\n      });\n    }\n  });\n  const mutationSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createSlice)({\n    name: `${reducerPath}/mutations`,\n    initialState,\n    reducers: {\n      removeMutationResult: {\n        reducer(draft, {\n          payload\n        }) {\n          const cacheKey = getMutationCacheKey(payload);\n          if (cacheKey in draft) {\n            delete draft[cacheKey];\n          }\n        },\n        prepare: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.prepareAutoBatched)()\n      }\n    },\n    extraReducers(builder) {\n      builder.addCase(mutationThunk.pending, (draft, {\n        meta,\n        meta: {\n          requestId,\n          arg,\n          startedTimeStamp\n        }\n      }) => {\n        if (!arg.track) return;\n        draft[getMutationCacheKey(meta)] = {\n          requestId,\n          status: \"pending\" /* pending */,\n          endpointName: arg.endpointName,\n          startedTimeStamp\n        };\n      }).addCase(mutationThunk.fulfilled, (draft, {\n        payload,\n        meta\n      }) => {\n        if (!meta.arg.track) return;\n        updateMutationSubstateIfExists(draft, meta, (substate) => {\n          if (substate.requestId !== meta.requestId) return;\n          substate.status = \"fulfilled\" /* fulfilled */;\n          substate.data = payload;\n          substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;\n        });\n      }).addCase(mutationThunk.rejected, (draft, {\n        payload,\n        error,\n        meta\n      }) => {\n        if (!meta.arg.track) return;\n        updateMutationSubstateIfExists(draft, meta, (substate) => {\n          if (substate.requestId !== meta.requestId) return;\n          substate.status = \"rejected\" /* rejected */;\n          substate.error = payload ?? error;\n        });\n      }).addMatcher(hasRehydrationInfo, (draft, action) => {\n        const {\n          mutations\n        } = extractRehydrationInfo(action);\n        for (const [key, entry] of Object.entries(mutations)) {\n          if (\n            // do not rehydrate entries that were currently in flight.\n            (entry?.status === \"fulfilled\" /* fulfilled */ || entry?.status === \"rejected\" /* rejected */) && // only rehydrate endpoints that were persisted using a `fixedCacheKey`\n            key !== entry?.requestId\n          ) {\n            draft[key] = entry;\n          }\n        }\n      });\n    }\n  });\n  const initialInvalidationState = {\n    tags: {},\n    keys: {}\n  };\n  const invalidationSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createSlice)({\n    name: `${reducerPath}/invalidation`,\n    initialState: initialInvalidationState,\n    reducers: {\n      updateProvidedBy: {\n        reducer(draft, action) {\n          for (const {\n            queryCacheKey,\n            providedTags\n          } of action.payload) {\n            removeCacheKeyFromTags(draft, queryCacheKey);\n            for (const {\n              type,\n              id\n            } of providedTags) {\n              const subscribedQueries = (draft.tags[type] ??= {})[id || \"__internal_without_id\"] ??= [];\n              const alreadySubscribed = subscribedQueries.includes(queryCacheKey);\n              if (!alreadySubscribed) {\n                subscribedQueries.push(queryCacheKey);\n              }\n            }\n            draft.keys[queryCacheKey] = providedTags;\n          }\n        },\n        prepare: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.prepareAutoBatched)()\n      }\n    },\n    extraReducers(builder) {\n      builder.addCase(querySlice.actions.removeQueryResult, (draft, {\n        payload: {\n          queryCacheKey\n        }\n      }) => {\n        removeCacheKeyFromTags(draft, queryCacheKey);\n      }).addMatcher(hasRehydrationInfo, (draft, action) => {\n        const {\n          provided\n        } = extractRehydrationInfo(action);\n        for (const [type, incomingTags] of Object.entries(provided.tags ?? {})) {\n          for (const [id, cacheKeys] of Object.entries(incomingTags)) {\n            const subscribedQueries = (draft.tags[type] ??= {})[id || \"__internal_without_id\"] ??= [];\n            for (const queryCacheKey of cacheKeys) {\n              const alreadySubscribed = subscribedQueries.includes(queryCacheKey);\n              if (!alreadySubscribed) {\n                subscribedQueries.push(queryCacheKey);\n              }\n              draft.keys[queryCacheKey] = provided.keys[queryCacheKey];\n            }\n          }\n        }\n      }).addMatcher((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAnyOf)((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isFulfilled)(queryThunk), (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isRejectedWithValue)(queryThunk)), (draft, action) => {\n        writeProvidedTagsForQueries(draft, [action]);\n      }).addMatcher(querySlice.actions.cacheEntriesUpserted.match, (draft, action) => {\n        const mockActions = action.payload.map(({\n          queryDescription,\n          value\n        }) => {\n          return {\n            type: \"UNKNOWN\",\n            payload: value,\n            meta: {\n              requestStatus: \"fulfilled\",\n              requestId: \"UNKNOWN\",\n              arg: queryDescription\n            }\n          };\n        });\n        writeProvidedTagsForQueries(draft, mockActions);\n      });\n    }\n  });\n  function removeCacheKeyFromTags(draft, queryCacheKey) {\n    const existingTags = draft.keys[queryCacheKey] ?? [];\n    for (const tag of existingTags) {\n      const tagType = tag.type;\n      const tagId = tag.id ?? \"__internal_without_id\";\n      const tagSubscriptions = draft.tags[tagType]?.[tagId];\n      if (tagSubscriptions) {\n        draft.tags[tagType][tagId] = tagSubscriptions.filter((qc) => qc !== queryCacheKey);\n      }\n    }\n    delete draft.keys[queryCacheKey];\n  }\n  function writeProvidedTagsForQueries(draft, actions2) {\n    const providedByEntries = actions2.map((action) => {\n      const providedTags = calculateProvidedByThunk(action, \"providesTags\", definitions, assertTagType);\n      const {\n        queryCacheKey\n      } = action.meta.arg;\n      return {\n        queryCacheKey,\n        providedTags\n      };\n    });\n    invalidationSlice.caseReducers.updateProvidedBy(draft, invalidationSlice.actions.updateProvidedBy(providedByEntries));\n  }\n  const subscriptionSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createSlice)({\n    name: `${reducerPath}/subscriptions`,\n    initialState,\n    reducers: {\n      updateSubscriptionOptions(d, a) {\n      },\n      unsubscribeQueryResult(d, a) {\n      },\n      internal_getRTKQSubscriptions() {\n      }\n    }\n  });\n  const internalSubscriptionsSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createSlice)({\n    name: `${reducerPath}/internalSubscriptions`,\n    initialState,\n    reducers: {\n      subscriptionsUpdated: {\n        reducer(state, action) {\n          return (0,immer__WEBPACK_IMPORTED_MODULE_3__.applyPatches)(state, action.payload);\n        },\n        prepare: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.prepareAutoBatched)()\n      }\n    }\n  });\n  const configSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createSlice)({\n    name: `${reducerPath}/config`,\n    initialState: {\n      online: isOnline(),\n      focused: isDocumentVisible(),\n      middlewareRegistered: false,\n      ...config\n    },\n    reducers: {\n      middlewareRegistered(state, {\n        payload\n      }) {\n        state.middlewareRegistered = state.middlewareRegistered === \"conflict\" || apiUid !== payload ? \"conflict\" : true;\n      }\n    },\n    extraReducers: (builder) => {\n      builder.addCase(onOnline, (state) => {\n        state.online = true;\n      }).addCase(onOffline, (state) => {\n        state.online = false;\n      }).addCase(onFocus, (state) => {\n        state.focused = true;\n      }).addCase(onFocusLost, (state) => {\n        state.focused = false;\n      }).addMatcher(hasRehydrationInfo, (draft) => ({\n        ...draft\n      }));\n    }\n  });\n  const combinedReducer = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.combineReducers)({\n    queries: querySlice.reducer,\n    mutations: mutationSlice.reducer,\n    provided: invalidationSlice.reducer,\n    subscriptions: internalSubscriptionsSlice.reducer,\n    config: configSlice.reducer\n  });\n  const reducer = (state, action) => combinedReducer(resetApiState.match(action) ? void 0 : state, action);\n  const actions = {\n    ...configSlice.actions,\n    ...querySlice.actions,\n    ...subscriptionSlice.actions,\n    ...internalSubscriptionsSlice.actions,\n    ...mutationSlice.actions,\n    ...invalidationSlice.actions,\n    resetApiState\n  };\n  return {\n    reducer,\n    actions\n  };\n}\n\n// src/query/core/buildSelectors.ts\nvar skipToken = /* @__PURE__ */ Symbol.for(\"RTKQ/skipToken\");\nvar initialSubState = {\n  status: \"uninitialized\" /* uninitialized */\n};\nvar defaultQuerySubState = /* @__PURE__ */ (0,immer__WEBPACK_IMPORTED_MODULE_3__.produce)(initialSubState, () => {\n});\nvar defaultMutationSubState = /* @__PURE__ */ (0,immer__WEBPACK_IMPORTED_MODULE_3__.produce)(initialSubState, () => {\n});\nfunction buildSelectors({\n  serializeQueryArgs,\n  reducerPath,\n  createSelector: createSelector2\n}) {\n  const selectSkippedQuery = (state) => defaultQuerySubState;\n  const selectSkippedMutation = (state) => defaultMutationSubState;\n  return {\n    buildQuerySelector,\n    buildInfiniteQuerySelector,\n    buildMutationSelector,\n    selectInvalidatedBy,\n    selectCachedArgsForQuery,\n    selectApiState,\n    selectQueries,\n    selectMutations,\n    selectQueryEntry,\n    selectConfig\n  };\n  function withRequestFlags(substate) {\n    return {\n      ...substate,\n      ...getRequestStatusFlags(substate.status)\n    };\n  }\n  function selectApiState(rootState) {\n    const state = rootState[reducerPath];\n    if (true) {\n      if (!state) {\n        if (selectApiState.triggered) return state;\n        selectApiState.triggered = true;\n        console.error(`Error: No data found at \\`state.${reducerPath}\\`. Did you forget to add the reducer to the store?`);\n      }\n    }\n    return state;\n  }\n  function selectQueries(rootState) {\n    return selectApiState(rootState)?.queries;\n  }\n  function selectQueryEntry(rootState, cacheKey) {\n    return selectQueries(rootState)?.[cacheKey];\n  }\n  function selectMutations(rootState) {\n    return selectApiState(rootState)?.mutations;\n  }\n  function selectConfig(rootState) {\n    return selectApiState(rootState)?.config;\n  }\n  function buildAnyQuerySelector(endpointName, endpointDefinition, combiner) {\n    return (queryArgs) => {\n      if (queryArgs === skipToken) {\n        return createSelector2(selectSkippedQuery, combiner);\n      }\n      const serializedArgs = serializeQueryArgs({\n        queryArgs,\n        endpointDefinition,\n        endpointName\n      });\n      const selectQuerySubstate = (state) => selectQueryEntry(state, serializedArgs) ?? defaultQuerySubState;\n      return createSelector2(selectQuerySubstate, combiner);\n    };\n  }\n  function buildQuerySelector(endpointName, endpointDefinition) {\n    return buildAnyQuerySelector(endpointName, endpointDefinition, withRequestFlags);\n  }\n  function buildInfiniteQuerySelector(endpointName, endpointDefinition) {\n    const {\n      infiniteQueryOptions\n    } = endpointDefinition;\n    function withInfiniteQueryResultFlags(substate) {\n      const stateWithRequestFlags = {\n        ...substate,\n        ...getRequestStatusFlags(substate.status)\n      };\n      const {\n        isLoading,\n        isError,\n        direction\n      } = stateWithRequestFlags;\n      const isForward = direction === \"forward\";\n      const isBackward = direction === \"backward\";\n      return {\n        ...stateWithRequestFlags,\n        hasNextPage: getHasNextPage(infiniteQueryOptions, stateWithRequestFlags.data, stateWithRequestFlags.originalArgs),\n        hasPreviousPage: getHasPreviousPage(infiniteQueryOptions, stateWithRequestFlags.data, stateWithRequestFlags.originalArgs),\n        isFetchingNextPage: isLoading && isForward,\n        isFetchingPreviousPage: isLoading && isBackward,\n        isFetchNextPageError: isError && isForward,\n        isFetchPreviousPageError: isError && isBackward\n      };\n    }\n    return buildAnyQuerySelector(endpointName, endpointDefinition, withInfiniteQueryResultFlags);\n  }\n  function buildMutationSelector() {\n    return (id) => {\n      let mutationId;\n      if (typeof id === \"object\") {\n        mutationId = getMutationCacheKey(id) ?? skipToken;\n      } else {\n        mutationId = id;\n      }\n      const selectMutationSubstate = (state) => selectApiState(state)?.mutations?.[mutationId] ?? defaultMutationSubState;\n      const finalSelectMutationSubstate = mutationId === skipToken ? selectSkippedMutation : selectMutationSubstate;\n      return createSelector2(finalSelectMutationSubstate, withRequestFlags);\n    };\n  }\n  function selectInvalidatedBy(state, tags) {\n    const apiState = state[reducerPath];\n    const toInvalidate = /* @__PURE__ */ new Set();\n    for (const tag of tags.filter(isNotNullish).map(expandTagDescription)) {\n      const provided = apiState.provided.tags[tag.type];\n      if (!provided) {\n        continue;\n      }\n      let invalidateSubscriptions = (tag.id !== void 0 ? (\n        // id given: invalidate all queries that provide this type & id\n        provided[tag.id]\n      ) : (\n        // no id: invalidate all queries that provide this type\n        flatten(Object.values(provided))\n      )) ?? [];\n      for (const invalidate of invalidateSubscriptions) {\n        toInvalidate.add(invalidate);\n      }\n    }\n    return flatten(Array.from(toInvalidate.values()).map((queryCacheKey) => {\n      const querySubState = apiState.queries[queryCacheKey];\n      return querySubState ? [{\n        queryCacheKey,\n        endpointName: querySubState.endpointName,\n        originalArgs: querySubState.originalArgs\n      }] : [];\n    }));\n  }\n  function selectCachedArgsForQuery(state, queryName) {\n    return Object.values(selectQueries(state)).filter((entry) => entry?.endpointName === queryName && entry.status !== \"uninitialized\" /* uninitialized */).map((entry) => entry.originalArgs);\n  }\n  function getHasNextPage(options, data, queryArg) {\n    if (!data) return false;\n    return getNextPageParam(options, data, queryArg) != null;\n  }\n  function getHasPreviousPage(options, data, queryArg) {\n    if (!data || !options.getPreviousPageParam) return false;\n    return getPreviousPageParam(options, data, queryArg) != null;\n  }\n}\n\n// src/query/createApi.ts\n\n\n// src/query/defaultSerializeQueryArgs.ts\nvar cache = WeakMap ? /* @__PURE__ */ new WeakMap() : void 0;\nvar defaultSerializeQueryArgs = ({\n  endpointName,\n  queryArgs\n}) => {\n  let serialized = \"\";\n  const cached = cache?.get(queryArgs);\n  if (typeof cached === \"string\") {\n    serialized = cached;\n  } else {\n    const stringified = JSON.stringify(queryArgs, (key, value) => {\n      value = typeof value === \"bigint\" ? {\n        $bigint: value.toString()\n      } : value;\n      value = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) ? Object.keys(value).sort().reduce((acc, key2) => {\n        acc[key2] = value[key2];\n        return acc;\n      }, {}) : value;\n      return value;\n    });\n    if ((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(queryArgs)) {\n      cache?.set(queryArgs, stringified);\n    }\n    serialized = stringified;\n  }\n  return `${endpointName}(${serialized})`;\n};\n\n// src/query/createApi.ts\n\nfunction buildCreateApi(...modules) {\n  return function baseCreateApi(options) {\n    const extractRehydrationInfo = (0,reselect__WEBPACK_IMPORTED_MODULE_4__.weakMapMemoize)((action) => options.extractRehydrationInfo?.(action, {\n      reducerPath: options.reducerPath ?? \"api\"\n    }));\n    const optionsWithDefaults = {\n      reducerPath: \"api\",\n      keepUnusedDataFor: 60,\n      refetchOnMountOrArgChange: false,\n      refetchOnFocus: false,\n      refetchOnReconnect: false,\n      invalidationBehavior: \"delayed\",\n      ...options,\n      extractRehydrationInfo,\n      serializeQueryArgs(queryArgsApi) {\n        let finalSerializeQueryArgs = defaultSerializeQueryArgs;\n        if (\"serializeQueryArgs\" in queryArgsApi.endpointDefinition) {\n          const endpointSQA = queryArgsApi.endpointDefinition.serializeQueryArgs;\n          finalSerializeQueryArgs = (queryArgsApi2) => {\n            const initialResult = endpointSQA(queryArgsApi2);\n            if (typeof initialResult === \"string\") {\n              return initialResult;\n            } else {\n              return defaultSerializeQueryArgs({\n                ...queryArgsApi2,\n                queryArgs: initialResult\n              });\n            }\n          };\n        } else if (options.serializeQueryArgs) {\n          finalSerializeQueryArgs = options.serializeQueryArgs;\n        }\n        return finalSerializeQueryArgs(queryArgsApi);\n      },\n      tagTypes: [...options.tagTypes || []]\n    };\n    const context = {\n      endpointDefinitions: {},\n      batch(fn) {\n        fn();\n      },\n      apiUid: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.nanoid)(),\n      extractRehydrationInfo,\n      hasRehydrationInfo: (0,reselect__WEBPACK_IMPORTED_MODULE_4__.weakMapMemoize)((action) => extractRehydrationInfo(action) != null)\n    };\n    const api = {\n      injectEndpoints,\n      enhanceEndpoints({\n        addTagTypes,\n        endpoints\n      }) {\n        if (addTagTypes) {\n          for (const eT of addTagTypes) {\n            if (!optionsWithDefaults.tagTypes.includes(eT)) {\n              ;\n              optionsWithDefaults.tagTypes.push(eT);\n            }\n          }\n        }\n        if (endpoints) {\n          for (const [endpointName, partialDefinition] of Object.entries(endpoints)) {\n            if (typeof partialDefinition === \"function\") {\n              partialDefinition(context.endpointDefinitions[endpointName]);\n            } else {\n              Object.assign(context.endpointDefinitions[endpointName] || {}, partialDefinition);\n            }\n          }\n        }\n        return api;\n      }\n    };\n    const initializedModules = modules.map((m) => m.init(api, optionsWithDefaults, context));\n    function injectEndpoints(inject) {\n      const evaluatedEndpoints = inject.endpoints({\n        query: (x) => ({\n          ...x,\n          type: \"query\" /* query */\n        }),\n        mutation: (x) => ({\n          ...x,\n          type: \"mutation\" /* mutation */\n        }),\n        infiniteQuery: (x) => ({\n          ...x,\n          type: \"infinitequery\" /* infinitequery */\n        })\n      });\n      for (const [endpointName, definition] of Object.entries(evaluatedEndpoints)) {\n        if (inject.overrideExisting !== true && endpointName in context.endpointDefinitions) {\n          if (inject.overrideExisting === \"throw\") {\n            throw new Error( false ? 0 : `called \\`injectEndpoints\\` to override already-existing endpointName ${endpointName} without specifying \\`overrideExisting: true\\``);\n          } else if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n            console.error(`called \\`injectEndpoints\\` to override already-existing endpointName ${endpointName} without specifying \\`overrideExisting: true\\``);\n          }\n          continue;\n        }\n        if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n          if (isInfiniteQueryDefinition(definition)) {\n            const {\n              infiniteQueryOptions\n            } = definition;\n            const {\n              maxPages,\n              getPreviousPageParam: getPreviousPageParam2\n            } = infiniteQueryOptions;\n            if (typeof maxPages === \"number\") {\n              if (maxPages < 1) {\n                throw new Error( false ? 0 : `maxPages for endpoint '${endpointName}' must be a number greater than 0`);\n              }\n              if (typeof getPreviousPageParam2 !== \"function\") {\n                throw new Error( false ? 0 : `getPreviousPageParam for endpoint '${endpointName}' must be a function if maxPages is used`);\n              }\n            }\n          }\n        }\n        context.endpointDefinitions[endpointName] = definition;\n        for (const m of initializedModules) {\n          m.injectEndpoint(endpointName, definition);\n        }\n      }\n      return api;\n    }\n    return api.injectEndpoints({\n      endpoints: options.endpoints\n    });\n  };\n}\n\n// src/query/fakeBaseQuery.ts\n\nvar _NEVER = /* @__PURE__ */ Symbol();\nfunction fakeBaseQuery() {\n  return function() {\n    throw new Error( false ? 0 : \"When using `fakeBaseQuery`, all queries & mutations must use the `queryFn` definition syntax.\");\n  };\n}\n\n// src/query/core/module.ts\n\n\n// src/query/tsHelpers.ts\nfunction assertCast(v) {\n}\nfunction safeAssign(target, ...args) {\n  return Object.assign(target, ...args);\n}\n\n// src/query/core/buildMiddleware/batchActions.ts\n\nvar buildBatchedActionsHandler = ({\n  api,\n  queryThunk,\n  internalState,\n  mwApi\n}) => {\n  const subscriptionsPrefix = `${api.reducerPath}/subscriptions`;\n  let previousSubscriptions = null;\n  let updateSyncTimer = null;\n  const {\n    updateSubscriptionOptions,\n    unsubscribeQueryResult\n  } = api.internalActions;\n  const actuallyMutateSubscriptions = (currentSubscriptions, action) => {\n    if (updateSubscriptionOptions.match(action)) {\n      const {\n        queryCacheKey,\n        requestId,\n        options\n      } = action.payload;\n      const sub = currentSubscriptions.get(queryCacheKey);\n      if (sub?.has(requestId)) {\n        sub.set(requestId, options);\n      }\n      return true;\n    }\n    if (unsubscribeQueryResult.match(action)) {\n      const {\n        queryCacheKey,\n        requestId\n      } = action.payload;\n      const sub = currentSubscriptions.get(queryCacheKey);\n      if (sub) {\n        sub.delete(requestId);\n      }\n      return true;\n    }\n    if (api.internalActions.removeQueryResult.match(action)) {\n      currentSubscriptions.delete(action.payload.queryCacheKey);\n      return true;\n    }\n    if (queryThunk.pending.match(action)) {\n      const {\n        meta: {\n          arg,\n          requestId\n        }\n      } = action;\n      const substate = getOrInsertComputed(currentSubscriptions, arg.queryCacheKey, createNewMap);\n      if (arg.subscribe) {\n        substate.set(requestId, arg.subscriptionOptions ?? substate.get(requestId) ?? {});\n      }\n      return true;\n    }\n    let mutated = false;\n    if (queryThunk.rejected.match(action)) {\n      const {\n        meta: {\n          condition,\n          arg,\n          requestId\n        }\n      } = action;\n      if (condition && arg.subscribe) {\n        const substate = getOrInsertComputed(currentSubscriptions, arg.queryCacheKey, createNewMap);\n        substate.set(requestId, arg.subscriptionOptions ?? substate.get(requestId) ?? {});\n        mutated = true;\n      }\n    }\n    return mutated;\n  };\n  const getSubscriptions = () => internalState.currentSubscriptions;\n  const getSubscriptionCount = (queryCacheKey) => {\n    const subscriptions = getSubscriptions();\n    const subscriptionsForQueryArg = subscriptions.get(queryCacheKey);\n    return subscriptionsForQueryArg?.size ?? 0;\n  };\n  const isRequestSubscribed = (queryCacheKey, requestId) => {\n    const subscriptions = getSubscriptions();\n    return !!subscriptions?.get(queryCacheKey)?.get(requestId);\n  };\n  const subscriptionSelectors = {\n    getSubscriptions,\n    getSubscriptionCount,\n    isRequestSubscribed\n  };\n  function serializeSubscriptions(currentSubscriptions) {\n    return JSON.parse(JSON.stringify(Object.fromEntries([...currentSubscriptions].map(([k, v]) => [k, Object.fromEntries(v)]))));\n  }\n  return (action, mwApi2) => {\n    if (!previousSubscriptions) {\n      previousSubscriptions = serializeSubscriptions(internalState.currentSubscriptions);\n    }\n    if (api.util.resetApiState.match(action)) {\n      previousSubscriptions = {};\n      internalState.currentSubscriptions.clear();\n      updateSyncTimer = null;\n      return [true, false];\n    }\n    if (api.internalActions.internal_getRTKQSubscriptions.match(action)) {\n      return [false, subscriptionSelectors];\n    }\n    const didMutate = actuallyMutateSubscriptions(internalState.currentSubscriptions, action);\n    let actionShouldContinue = true;\n    if (false) {}\n    if (didMutate) {\n      if (!updateSyncTimer) {\n        updateSyncTimer = setTimeout(() => {\n          const newSubscriptions = serializeSubscriptions(internalState.currentSubscriptions);\n          const [, patches] = (0,immer__WEBPACK_IMPORTED_MODULE_3__.produceWithPatches)(previousSubscriptions, () => newSubscriptions);\n          mwApi2.next(api.internalActions.subscriptionsUpdated(patches));\n          previousSubscriptions = newSubscriptions;\n          updateSyncTimer = null;\n        }, 500);\n      }\n      const isSubscriptionSliceAction = typeof action.type == \"string\" && !!action.type.startsWith(subscriptionsPrefix);\n      const isAdditionalSubscriptionAction = queryThunk.rejected.match(action) && action.meta.condition && !!action.meta.arg.subscribe;\n      actionShouldContinue = !isSubscriptionSliceAction && !isAdditionalSubscriptionAction;\n    }\n    return [actionShouldContinue, false];\n  };\n};\n\n// src/query/core/buildMiddleware/cacheCollection.ts\nvar THIRTY_TWO_BIT_MAX_TIMER_SECONDS = 2147483647 / 1e3 - 1;\nvar buildCacheCollectionHandler = ({\n  reducerPath,\n  api,\n  queryThunk,\n  context,\n  internalState,\n  selectors: {\n    selectQueryEntry,\n    selectConfig\n  },\n  getRunningQueryThunk,\n  mwApi\n}) => {\n  const {\n    removeQueryResult,\n    unsubscribeQueryResult,\n    cacheEntriesUpserted\n  } = api.internalActions;\n  const canTriggerUnsubscribe = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAnyOf)(unsubscribeQueryResult.match, queryThunk.fulfilled, queryThunk.rejected, cacheEntriesUpserted.match);\n  function anySubscriptionsRemainingForKey(queryCacheKey) {\n    const subscriptions = internalState.currentSubscriptions.get(queryCacheKey);\n    if (!subscriptions) {\n      return false;\n    }\n    const hasSubscriptions = subscriptions.size > 0;\n    return hasSubscriptions;\n  }\n  const currentRemovalTimeouts = {};\n  function abortAllPromises(promiseMap) {\n    for (const promise of promiseMap.values()) {\n      promise?.abort?.();\n    }\n  }\n  const handler = (action, mwApi2) => {\n    const state = mwApi2.getState();\n    const config = selectConfig(state);\n    if (canTriggerUnsubscribe(action)) {\n      let queryCacheKeys;\n      if (cacheEntriesUpserted.match(action)) {\n        queryCacheKeys = action.payload.map((entry) => entry.queryDescription.queryCacheKey);\n      } else {\n        const {\n          queryCacheKey\n        } = unsubscribeQueryResult.match(action) ? action.payload : action.meta.arg;\n        queryCacheKeys = [queryCacheKey];\n      }\n      handleUnsubscribeMany(queryCacheKeys, mwApi2, config);\n    }\n    if (api.util.resetApiState.match(action)) {\n      for (const [key, timeout] of Object.entries(currentRemovalTimeouts)) {\n        if (timeout) clearTimeout(timeout);\n        delete currentRemovalTimeouts[key];\n      }\n      abortAllPromises(internalState.runningQueries);\n      abortAllPromises(internalState.runningMutations);\n    }\n    if (context.hasRehydrationInfo(action)) {\n      const {\n        queries\n      } = context.extractRehydrationInfo(action);\n      handleUnsubscribeMany(Object.keys(queries), mwApi2, config);\n    }\n  };\n  function handleUnsubscribeMany(cacheKeys, api2, config) {\n    const state = api2.getState();\n    for (const queryCacheKey of cacheKeys) {\n      const entry = selectQueryEntry(state, queryCacheKey);\n      if (entry?.endpointName) {\n        handleUnsubscribe(queryCacheKey, entry.endpointName, api2, config);\n      }\n    }\n  }\n  function handleUnsubscribe(queryCacheKey, endpointName, api2, config) {\n    const endpointDefinition = context.endpointDefinitions[endpointName];\n    const keepUnusedDataFor = endpointDefinition?.keepUnusedDataFor ?? config.keepUnusedDataFor;\n    if (keepUnusedDataFor === Infinity) {\n      return;\n    }\n    const finalKeepUnusedDataFor = Math.max(0, Math.min(keepUnusedDataFor, THIRTY_TWO_BIT_MAX_TIMER_SECONDS));\n    if (!anySubscriptionsRemainingForKey(queryCacheKey)) {\n      const currentTimeout = currentRemovalTimeouts[queryCacheKey];\n      if (currentTimeout) {\n        clearTimeout(currentTimeout);\n      }\n      currentRemovalTimeouts[queryCacheKey] = setTimeout(() => {\n        if (!anySubscriptionsRemainingForKey(queryCacheKey)) {\n          const entry = selectQueryEntry(api2.getState(), queryCacheKey);\n          if (entry?.endpointName) {\n            const runningQuery = api2.dispatch(getRunningQueryThunk(entry.endpointName, entry.originalArgs));\n            runningQuery?.abort();\n          }\n          api2.dispatch(removeQueryResult({\n            queryCacheKey\n          }));\n        }\n        delete currentRemovalTimeouts[queryCacheKey];\n      }, finalKeepUnusedDataFor * 1e3);\n    }\n  }\n  return handler;\n};\n\n// src/query/core/buildMiddleware/cacheLifecycle.ts\nvar neverResolvedError = new Error(\"Promise never resolved before cacheEntryRemoved.\");\nvar buildCacheLifecycleHandler = ({\n  api,\n  reducerPath,\n  context,\n  queryThunk,\n  mutationThunk,\n  internalState,\n  selectors: {\n    selectQueryEntry,\n    selectApiState\n  }\n}) => {\n  const isQueryThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAsyncThunkAction)(queryThunk);\n  const isMutationThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAsyncThunkAction)(mutationThunk);\n  const isFulfilledThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isFulfilled)(queryThunk, mutationThunk);\n  const lifecycleMap = {};\n  function resolveLifecycleEntry(cacheKey, data, meta) {\n    const lifecycle = lifecycleMap[cacheKey];\n    if (lifecycle?.valueResolved) {\n      lifecycle.valueResolved({\n        data,\n        meta\n      });\n      delete lifecycle.valueResolved;\n    }\n  }\n  function removeLifecycleEntry(cacheKey) {\n    const lifecycle = lifecycleMap[cacheKey];\n    if (lifecycle) {\n      delete lifecycleMap[cacheKey];\n      lifecycle.cacheEntryRemoved();\n    }\n  }\n  const handler = (action, mwApi, stateBefore) => {\n    const cacheKey = getCacheKey(action);\n    function checkForNewCacheKey(endpointName, cacheKey2, requestId, originalArgs) {\n      const oldEntry = selectQueryEntry(stateBefore, cacheKey2);\n      const newEntry = selectQueryEntry(mwApi.getState(), cacheKey2);\n      if (!oldEntry && newEntry) {\n        handleNewKey(endpointName, originalArgs, cacheKey2, mwApi, requestId);\n      }\n    }\n    if (queryThunk.pending.match(action)) {\n      checkForNewCacheKey(action.meta.arg.endpointName, cacheKey, action.meta.requestId, action.meta.arg.originalArgs);\n    } else if (api.internalActions.cacheEntriesUpserted.match(action)) {\n      for (const {\n        queryDescription,\n        value\n      } of action.payload) {\n        const {\n          endpointName,\n          originalArgs,\n          queryCacheKey\n        } = queryDescription;\n        checkForNewCacheKey(endpointName, queryCacheKey, action.meta.requestId, originalArgs);\n        resolveLifecycleEntry(queryCacheKey, value, {});\n      }\n    } else if (mutationThunk.pending.match(action)) {\n      const state = mwApi.getState()[reducerPath].mutations[cacheKey];\n      if (state) {\n        handleNewKey(action.meta.arg.endpointName, action.meta.arg.originalArgs, cacheKey, mwApi, action.meta.requestId);\n      }\n    } else if (isFulfilledThunk(action)) {\n      resolveLifecycleEntry(cacheKey, action.payload, action.meta.baseQueryMeta);\n    } else if (api.internalActions.removeQueryResult.match(action) || api.internalActions.removeMutationResult.match(action)) {\n      removeLifecycleEntry(cacheKey);\n    } else if (api.util.resetApiState.match(action)) {\n      for (const cacheKey2 of Object.keys(lifecycleMap)) {\n        removeLifecycleEntry(cacheKey2);\n      }\n    }\n  };\n  function getCacheKey(action) {\n    if (isQueryThunk(action)) return action.meta.arg.queryCacheKey;\n    if (isMutationThunk(action)) {\n      return action.meta.arg.fixedCacheKey ?? action.meta.requestId;\n    }\n    if (api.internalActions.removeQueryResult.match(action)) return action.payload.queryCacheKey;\n    if (api.internalActions.removeMutationResult.match(action)) return getMutationCacheKey(action.payload);\n    return \"\";\n  }\n  function handleNewKey(endpointName, originalArgs, queryCacheKey, mwApi, requestId) {\n    const endpointDefinition = context.endpointDefinitions[endpointName];\n    const onCacheEntryAdded = endpointDefinition?.onCacheEntryAdded;\n    if (!onCacheEntryAdded) return;\n    const lifecycle = {};\n    const cacheEntryRemoved = new Promise((resolve) => {\n      lifecycle.cacheEntryRemoved = resolve;\n    });\n    const cacheDataLoaded = Promise.race([new Promise((resolve) => {\n      lifecycle.valueResolved = resolve;\n    }), cacheEntryRemoved.then(() => {\n      throw neverResolvedError;\n    })]);\n    cacheDataLoaded.catch(() => {\n    });\n    lifecycleMap[queryCacheKey] = lifecycle;\n    const selector = api.endpoints[endpointName].select(isAnyQueryDefinition(endpointDefinition) ? originalArgs : queryCacheKey);\n    const extra = mwApi.dispatch((_, __, extra2) => extra2);\n    const lifecycleApi = {\n      ...mwApi,\n      getCacheEntry: () => selector(mwApi.getState()),\n      requestId,\n      extra,\n      updateCachedData: isAnyQueryDefinition(endpointDefinition) ? (updateRecipe) => mwApi.dispatch(api.util.updateQueryData(endpointName, originalArgs, updateRecipe)) : void 0,\n      cacheDataLoaded,\n      cacheEntryRemoved\n    };\n    const runningHandler = onCacheEntryAdded(originalArgs, lifecycleApi);\n    Promise.resolve(runningHandler).catch((e) => {\n      if (e === neverResolvedError) return;\n      throw e;\n    });\n  }\n  return handler;\n};\n\n// src/query/core/buildMiddleware/devMiddleware.ts\nvar buildDevCheckHandler = ({\n  api,\n  context: {\n    apiUid\n  },\n  reducerPath\n}) => {\n  return (action, mwApi) => {\n    if (api.util.resetApiState.match(action)) {\n      mwApi.dispatch(api.internalActions.middlewareRegistered(apiUid));\n    }\n    if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n      if (api.internalActions.middlewareRegistered.match(action) && action.payload === apiUid && mwApi.getState()[reducerPath]?.config?.middlewareRegistered === \"conflict\") {\n        console.warn(`There is a mismatch between slice and middleware for the reducerPath \"${reducerPath}\".\nYou can only have one api per reducer path, this will lead to crashes in various situations!${reducerPath === \"api\" ? `\nIf you have multiple apis, you *have* to specify the reducerPath option when using createApi!` : \"\"}`);\n      }\n    }\n  };\n};\n\n// src/query/core/buildMiddleware/invalidationByTags.ts\nvar buildInvalidationByTagsHandler = ({\n  reducerPath,\n  context,\n  context: {\n    endpointDefinitions\n  },\n  mutationThunk,\n  queryThunk,\n  api,\n  assertTagType,\n  refetchQuery,\n  internalState\n}) => {\n  const {\n    removeQueryResult\n  } = api.internalActions;\n  const isThunkActionWithTags = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAnyOf)((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isFulfilled)(mutationThunk), (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isRejectedWithValue)(mutationThunk));\n  const isQueryEnd = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAnyOf)((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isFulfilled)(mutationThunk, queryThunk), (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isRejected)(mutationThunk, queryThunk));\n  let pendingTagInvalidations = [];\n  const handler = (action, mwApi) => {\n    if (isThunkActionWithTags(action)) {\n      invalidateTags(calculateProvidedByThunk(action, \"invalidatesTags\", endpointDefinitions, assertTagType), mwApi);\n    } else if (isQueryEnd(action)) {\n      invalidateTags([], mwApi);\n    } else if (api.util.invalidateTags.match(action)) {\n      invalidateTags(calculateProvidedBy(action.payload, void 0, void 0, void 0, void 0, assertTagType), mwApi);\n    }\n  };\n  function hasPendingRequests(state) {\n    const {\n      queries,\n      mutations\n    } = state;\n    for (const cacheRecord of [queries, mutations]) {\n      for (const key in cacheRecord) {\n        if (cacheRecord[key]?.status === \"pending\" /* pending */) return true;\n      }\n    }\n    return false;\n  }\n  function invalidateTags(newTags, mwApi) {\n    const rootState = mwApi.getState();\n    const state = rootState[reducerPath];\n    pendingTagInvalidations.push(...newTags);\n    if (state.config.invalidationBehavior === \"delayed\" && hasPendingRequests(state)) {\n      return;\n    }\n    const tags = pendingTagInvalidations;\n    pendingTagInvalidations = [];\n    if (tags.length === 0) return;\n    const toInvalidate = api.util.selectInvalidatedBy(rootState, tags);\n    context.batch(() => {\n      const valuesArray = Array.from(toInvalidate.values());\n      for (const {\n        queryCacheKey\n      } of valuesArray) {\n        const querySubState = state.queries[queryCacheKey];\n        const subscriptionSubState = getOrInsertComputed(internalState.currentSubscriptions, queryCacheKey, createNewMap);\n        if (querySubState) {\n          if (subscriptionSubState.size === 0) {\n            mwApi.dispatch(removeQueryResult({\n              queryCacheKey\n            }));\n          } else if (querySubState.status !== \"uninitialized\" /* uninitialized */) {\n            mwApi.dispatch(refetchQuery(querySubState));\n          }\n        }\n      }\n    });\n  }\n  return handler;\n};\n\n// src/query/core/buildMiddleware/polling.ts\nvar buildPollingHandler = ({\n  reducerPath,\n  queryThunk,\n  api,\n  refetchQuery,\n  internalState\n}) => {\n  const {\n    currentPolls,\n    currentSubscriptions\n  } = internalState;\n  const pendingPollingUpdates = /* @__PURE__ */ new Set();\n  let pollingUpdateTimer = null;\n  const handler = (action, mwApi) => {\n    if (api.internalActions.updateSubscriptionOptions.match(action) || api.internalActions.unsubscribeQueryResult.match(action)) {\n      schedulePollingUpdate(action.payload.queryCacheKey, mwApi);\n    }\n    if (queryThunk.pending.match(action) || queryThunk.rejected.match(action) && action.meta.condition) {\n      schedulePollingUpdate(action.meta.arg.queryCacheKey, mwApi);\n    }\n    if (queryThunk.fulfilled.match(action) || queryThunk.rejected.match(action) && !action.meta.condition) {\n      startNextPoll(action.meta.arg, mwApi);\n    }\n    if (api.util.resetApiState.match(action)) {\n      clearPolls();\n      if (pollingUpdateTimer) {\n        clearTimeout(pollingUpdateTimer);\n        pollingUpdateTimer = null;\n      }\n      pendingPollingUpdates.clear();\n    }\n  };\n  function schedulePollingUpdate(queryCacheKey, api2) {\n    pendingPollingUpdates.add(queryCacheKey);\n    if (!pollingUpdateTimer) {\n      pollingUpdateTimer = setTimeout(() => {\n        for (const key of pendingPollingUpdates) {\n          updatePollingInterval({\n            queryCacheKey: key\n          }, api2);\n        }\n        pendingPollingUpdates.clear();\n        pollingUpdateTimer = null;\n      }, 0);\n    }\n  }\n  function getCacheEntrySubscriptions(queryCacheKey, api2) {\n    const state = api2.getState()[reducerPath];\n    const querySubState = state.queries[queryCacheKey];\n    const subscriptions = currentSubscriptions.get(queryCacheKey);\n    if (!querySubState || querySubState.status === \"uninitialized\" /* uninitialized */) return;\n    return subscriptions;\n  }\n  function startNextPoll({\n    queryCacheKey\n  }, api2) {\n    const state = api2.getState()[reducerPath];\n    const querySubState = state.queries[queryCacheKey];\n    const subscriptions = currentSubscriptions.get(queryCacheKey);\n    if (!querySubState || querySubState.status === \"uninitialized\" /* uninitialized */) return;\n    const {\n      lowestPollingInterval,\n      skipPollingIfUnfocused\n    } = findLowestPollingInterval(subscriptions);\n    if (!Number.isFinite(lowestPollingInterval)) return;\n    const currentPoll = currentPolls.get(queryCacheKey);\n    if (currentPoll?.timeout) {\n      clearTimeout(currentPoll.timeout);\n      currentPoll.timeout = void 0;\n    }\n    const nextPollTimestamp = Date.now() + lowestPollingInterval;\n    currentPolls.set(queryCacheKey, {\n      nextPollTimestamp,\n      pollingInterval: lowestPollingInterval,\n      timeout: setTimeout(() => {\n        if (state.config.focused || !skipPollingIfUnfocused) {\n          api2.dispatch(refetchQuery(querySubState));\n        }\n        startNextPoll({\n          queryCacheKey\n        }, api2);\n      }, lowestPollingInterval)\n    });\n  }\n  function updatePollingInterval({\n    queryCacheKey\n  }, api2) {\n    const state = api2.getState()[reducerPath];\n    const querySubState = state.queries[queryCacheKey];\n    const subscriptions = currentSubscriptions.get(queryCacheKey);\n    if (!querySubState || querySubState.status === \"uninitialized\" /* uninitialized */) {\n      return;\n    }\n    const {\n      lowestPollingInterval\n    } = findLowestPollingInterval(subscriptions);\n    if (false) {}\n    if (!Number.isFinite(lowestPollingInterval)) {\n      cleanupPollForKey(queryCacheKey);\n      return;\n    }\n    const currentPoll = currentPolls.get(queryCacheKey);\n    const nextPollTimestamp = Date.now() + lowestPollingInterval;\n    if (!currentPoll || nextPollTimestamp < currentPoll.nextPollTimestamp) {\n      startNextPoll({\n        queryCacheKey\n      }, api2);\n    }\n  }\n  function cleanupPollForKey(key) {\n    const existingPoll = currentPolls.get(key);\n    if (existingPoll?.timeout) {\n      clearTimeout(existingPoll.timeout);\n    }\n    currentPolls.delete(key);\n  }\n  function clearPolls() {\n    for (const key of currentPolls.keys()) {\n      cleanupPollForKey(key);\n    }\n  }\n  function findLowestPollingInterval(subscribers = /* @__PURE__ */ new Map()) {\n    let skipPollingIfUnfocused = false;\n    let lowestPollingInterval = Number.POSITIVE_INFINITY;\n    for (const entry of subscribers.values()) {\n      if (!!entry.pollingInterval) {\n        lowestPollingInterval = Math.min(entry.pollingInterval, lowestPollingInterval);\n        skipPollingIfUnfocused = entry.skipPollingIfUnfocused || skipPollingIfUnfocused;\n      }\n    }\n    return {\n      lowestPollingInterval,\n      skipPollingIfUnfocused\n    };\n  }\n  return handler;\n};\n\n// src/query/core/buildMiddleware/queryLifecycle.ts\nvar buildQueryLifecycleHandler = ({\n  api,\n  context,\n  queryThunk,\n  mutationThunk\n}) => {\n  const isPendingThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isPending)(queryThunk, mutationThunk);\n  const isRejectedThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isRejected)(queryThunk, mutationThunk);\n  const isFullfilledThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isFulfilled)(queryThunk, mutationThunk);\n  const lifecycleMap = {};\n  const handler = (action, mwApi) => {\n    if (isPendingThunk(action)) {\n      const {\n        requestId,\n        arg: {\n          endpointName,\n          originalArgs\n        }\n      } = action.meta;\n      const endpointDefinition = context.endpointDefinitions[endpointName];\n      const onQueryStarted = endpointDefinition?.onQueryStarted;\n      if (onQueryStarted) {\n        const lifecycle = {};\n        const queryFulfilled = new Promise((resolve, reject) => {\n          lifecycle.resolve = resolve;\n          lifecycle.reject = reject;\n        });\n        queryFulfilled.catch(() => {\n        });\n        lifecycleMap[requestId] = lifecycle;\n        const selector = api.endpoints[endpointName].select(isAnyQueryDefinition(endpointDefinition) ? originalArgs : requestId);\n        const extra = mwApi.dispatch((_, __, extra2) => extra2);\n        const lifecycleApi = {\n          ...mwApi,\n          getCacheEntry: () => selector(mwApi.getState()),\n          requestId,\n          extra,\n          updateCachedData: isAnyQueryDefinition(endpointDefinition) ? (updateRecipe) => mwApi.dispatch(api.util.updateQueryData(endpointName, originalArgs, updateRecipe)) : void 0,\n          queryFulfilled\n        };\n        onQueryStarted(originalArgs, lifecycleApi);\n      }\n    } else if (isFullfilledThunk(action)) {\n      const {\n        requestId,\n        baseQueryMeta\n      } = action.meta;\n      lifecycleMap[requestId]?.resolve({\n        data: action.payload,\n        meta: baseQueryMeta\n      });\n      delete lifecycleMap[requestId];\n    } else if (isRejectedThunk(action)) {\n      const {\n        requestId,\n        rejectedWithValue,\n        baseQueryMeta\n      } = action.meta;\n      lifecycleMap[requestId]?.reject({\n        error: action.payload ?? action.error,\n        isUnhandledError: !rejectedWithValue,\n        meta: baseQueryMeta\n      });\n      delete lifecycleMap[requestId];\n    }\n  };\n  return handler;\n};\n\n// src/query/core/buildMiddleware/windowEventHandling.ts\nvar buildWindowEventHandler = ({\n  reducerPath,\n  context,\n  api,\n  refetchQuery,\n  internalState\n}) => {\n  const {\n    removeQueryResult\n  } = api.internalActions;\n  const handler = (action, mwApi) => {\n    if (onFocus.match(action)) {\n      refetchValidQueries(mwApi, \"refetchOnFocus\");\n    }\n    if (onOnline.match(action)) {\n      refetchValidQueries(mwApi, \"refetchOnReconnect\");\n    }\n  };\n  function refetchValidQueries(api2, type) {\n    const state = api2.getState()[reducerPath];\n    const queries = state.queries;\n    const subscriptions = internalState.currentSubscriptions;\n    context.batch(() => {\n      for (const queryCacheKey of subscriptions.keys()) {\n        const querySubState = queries[queryCacheKey];\n        const subscriptionSubState = subscriptions.get(queryCacheKey);\n        if (!subscriptionSubState || !querySubState) continue;\n        const values = [...subscriptionSubState.values()];\n        const shouldRefetch = values.some((sub) => sub[type] === true) || values.every((sub) => sub[type] === void 0) && state.config[type];\n        if (shouldRefetch) {\n          if (subscriptionSubState.size === 0) {\n            api2.dispatch(removeQueryResult({\n              queryCacheKey\n            }));\n          } else if (querySubState.status !== \"uninitialized\" /* uninitialized */) {\n            api2.dispatch(refetchQuery(querySubState));\n          }\n        }\n      }\n    });\n  }\n  return handler;\n};\n\n// src/query/core/buildMiddleware/index.ts\nfunction buildMiddleware(input) {\n  const {\n    reducerPath,\n    queryThunk,\n    api,\n    context,\n    getInternalState\n  } = input;\n  const {\n    apiUid\n  } = context;\n  const actions = {\n    invalidateTags: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAction)(`${reducerPath}/invalidateTags`)\n  };\n  const isThisApiSliceAction = (action) => action.type.startsWith(`${reducerPath}/`);\n  const handlerBuilders = [buildDevCheckHandler, buildCacheCollectionHandler, buildInvalidationByTagsHandler, buildPollingHandler, buildCacheLifecycleHandler, buildQueryLifecycleHandler];\n  const middleware = (mwApi) => {\n    let initialized2 = false;\n    const internalState = getInternalState(mwApi.dispatch);\n    const builderArgs = {\n      ...input,\n      internalState,\n      refetchQuery,\n      isThisApiSliceAction,\n      mwApi\n    };\n    const handlers = handlerBuilders.map((build) => build(builderArgs));\n    const batchedActionsHandler = buildBatchedActionsHandler(builderArgs);\n    const windowEventsHandler = buildWindowEventHandler(builderArgs);\n    return (next) => {\n      return (action) => {\n        if (!(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.isAction)(action)) {\n          return next(action);\n        }\n        if (!initialized2) {\n          initialized2 = true;\n          mwApi.dispatch(api.internalActions.middlewareRegistered(apiUid));\n        }\n        const mwApiWithNext = {\n          ...mwApi,\n          next\n        };\n        const stateBefore = mwApi.getState();\n        const [actionShouldContinue, internalProbeResult] = batchedActionsHandler(action, mwApiWithNext, stateBefore);\n        let res;\n        if (actionShouldContinue) {\n          res = next(action);\n        } else {\n          res = internalProbeResult;\n        }\n        if (!!mwApi.getState()[reducerPath]) {\n          windowEventsHandler(action, mwApiWithNext, stateBefore);\n          if (isThisApiSliceAction(action) || context.hasRehydrationInfo(action)) {\n            for (const handler of handlers) {\n              handler(action, mwApiWithNext, stateBefore);\n            }\n          }\n        }\n        return res;\n      };\n    };\n  };\n  return {\n    middleware,\n    actions\n  };\n  function refetchQuery(querySubState) {\n    return input.api.endpoints[querySubState.endpointName].initiate(querySubState.originalArgs, {\n      subscribe: false,\n      forceRefetch: true\n    });\n  }\n}\n\n// src/query/core/module.ts\nvar coreModuleName = /* @__PURE__ */ Symbol();\nvar coreModule = ({\n  createSelector: createSelector2 = reselect__WEBPACK_IMPORTED_MODULE_4__.createSelector\n} = {}) => ({\n  name: coreModuleName,\n  init(api, {\n    baseQuery,\n    tagTypes,\n    reducerPath,\n    serializeQueryArgs,\n    keepUnusedDataFor,\n    refetchOnMountOrArgChange,\n    refetchOnFocus,\n    refetchOnReconnect,\n    invalidationBehavior,\n    onSchemaFailure,\n    catchSchemaFailure,\n    skipSchemaValidation\n  }, context) {\n    (0,immer__WEBPACK_IMPORTED_MODULE_3__.enablePatches)();\n    assertCast(serializeQueryArgs);\n    const assertTagType = (tag) => {\n      if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n        if (!tagTypes.includes(tag.type)) {\n          console.error(`Tag type '${tag.type}' was used, but not specified in \\`tagTypes\\`!`);\n        }\n      }\n      return tag;\n    };\n    Object.assign(api, {\n      reducerPath,\n      endpoints: {},\n      internalActions: {\n        onOnline,\n        onOffline,\n        onFocus,\n        onFocusLost\n      },\n      util: {}\n    });\n    const selectors = buildSelectors({\n      serializeQueryArgs,\n      reducerPath,\n      createSelector: createSelector2\n    });\n    const {\n      selectInvalidatedBy,\n      selectCachedArgsForQuery,\n      buildQuerySelector,\n      buildInfiniteQuerySelector,\n      buildMutationSelector\n    } = selectors;\n    safeAssign(api.util, {\n      selectInvalidatedBy,\n      selectCachedArgsForQuery\n    });\n    const {\n      queryThunk,\n      infiniteQueryThunk,\n      mutationThunk,\n      patchQueryData,\n      updateQueryData,\n      upsertQueryData,\n      prefetch,\n      buildMatchThunkActions\n    } = buildThunks({\n      baseQuery,\n      reducerPath,\n      context,\n      api,\n      serializeQueryArgs,\n      assertTagType,\n      selectors,\n      onSchemaFailure,\n      catchSchemaFailure,\n      skipSchemaValidation\n    });\n    const {\n      reducer,\n      actions: sliceActions\n    } = buildSlice({\n      context,\n      queryThunk,\n      infiniteQueryThunk,\n      mutationThunk,\n      serializeQueryArgs,\n      reducerPath,\n      assertTagType,\n      config: {\n        refetchOnFocus,\n        refetchOnReconnect,\n        refetchOnMountOrArgChange,\n        keepUnusedDataFor,\n        reducerPath,\n        invalidationBehavior\n      }\n    });\n    safeAssign(api.util, {\n      patchQueryData,\n      updateQueryData,\n      upsertQueryData,\n      prefetch,\n      resetApiState: sliceActions.resetApiState,\n      upsertQueryEntries: sliceActions.cacheEntriesUpserted\n    });\n    safeAssign(api.internalActions, sliceActions);\n    const internalStateMap = /* @__PURE__ */ new WeakMap();\n    const getInternalState = (dispatch) => {\n      const state = getOrInsertComputed(internalStateMap, dispatch, () => ({\n        currentSubscriptions: /* @__PURE__ */ new Map(),\n        currentPolls: /* @__PURE__ */ new Map(),\n        runningQueries: /* @__PURE__ */ new Map(),\n        runningMutations: /* @__PURE__ */ new Map()\n      }));\n      return state;\n    };\n    const {\n      buildInitiateQuery,\n      buildInitiateInfiniteQuery,\n      buildInitiateMutation,\n      getRunningMutationThunk,\n      getRunningMutationsThunk,\n      getRunningQueriesThunk,\n      getRunningQueryThunk\n    } = buildInitiate({\n      queryThunk,\n      mutationThunk,\n      infiniteQueryThunk,\n      api,\n      serializeQueryArgs,\n      context,\n      getInternalState\n    });\n    safeAssign(api.util, {\n      getRunningMutationThunk,\n      getRunningMutationsThunk,\n      getRunningQueryThunk,\n      getRunningQueriesThunk\n    });\n    const {\n      middleware,\n      actions: middlewareActions\n    } = buildMiddleware({\n      reducerPath,\n      context,\n      queryThunk,\n      mutationThunk,\n      infiniteQueryThunk,\n      api,\n      assertTagType,\n      selectors,\n      getRunningQueryThunk,\n      getInternalState\n    });\n    safeAssign(api.util, middlewareActions);\n    safeAssign(api, {\n      reducer,\n      middleware\n    });\n    return {\n      name: coreModuleName,\n      injectEndpoint(endpointName, definition) {\n        const anyApi = api;\n        const endpoint = anyApi.endpoints[endpointName] ??= {};\n        if (isQueryDefinition(definition)) {\n          safeAssign(endpoint, {\n            name: endpointName,\n            select: buildQuerySelector(endpointName, definition),\n            initiate: buildInitiateQuery(endpointName, definition)\n          }, buildMatchThunkActions(queryThunk, endpointName));\n        }\n        if (isMutationDefinition(definition)) {\n          safeAssign(endpoint, {\n            name: endpointName,\n            select: buildMutationSelector(),\n            initiate: buildInitiateMutation(endpointName)\n          }, buildMatchThunkActions(mutationThunk, endpointName));\n        }\n        if (isInfiniteQueryDefinition(definition)) {\n          safeAssign(endpoint, {\n            name: endpointName,\n            select: buildInfiniteQuerySelector(endpointName, definition),\n            initiate: buildInitiateInfiniteQuery(endpointName, definition)\n          }, buildMatchThunkActions(queryThunk, endpointName));\n        }\n      }\n    };\n  }\n});\n\n// src/query/core/index.ts\nvar createApi = /* @__PURE__ */ buildCreateApi(coreModule());\n\n//# sourceMappingURL=rtk-query.modern.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9kaXN0L3F1ZXJ5L3J0ay1xdWVyeS5tb2Rlcm4ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsbUJBQW1CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUN1Uzs7QUFFdlM7QUFDQSxxQkFBcUIsMkRBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLLEVBQUUsVUFBVSxFQUFFLElBQUk7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLCtEQUFhO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELCtEQUFhO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtB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LFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFJO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ3FEO0FBQ3JELHFDQUFxQywrREFBVztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLEtBQUssOERBQWdCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0R0FBNEc7QUFDNUc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQWdCRTtBQUNGIiwic291cmNlcyI6WyIvaG9tZS9wcm9qZWN0L25vZGVfbW9kdWxlcy9AcmVkdXhqcy90b29sa2l0L2Rpc3QvcXVlcnkvcnRrLXF1ZXJ5Lm1vZGVybi5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3F1ZXJ5L2NvcmUvYXBpU3RhdGUudHNcbnZhciBRdWVyeVN0YXR1cyA9IC8qIEBfX1BVUkVfXyAqLyAoKFF1ZXJ5U3RhdHVzMikgPT4ge1xuICBRdWVyeVN0YXR1czJbXCJ1bmluaXRpYWxpemVkXCJdID0gXCJ1bmluaXRpYWxpemVkXCI7XG4gIFF1ZXJ5U3RhdHVzMltcInBlbmRpbmdcIl0gPSBcInBlbmRpbmdcIjtcbiAgUXVlcnlTdGF0dXMyW1wiZnVsZmlsbGVkXCJdID0gXCJmdWxmaWxsZWRcIjtcbiAgUXVlcnlTdGF0dXMyW1wicmVqZWN0ZWRcIl0gPSBcInJlamVjdGVkXCI7XG4gIHJldHVybiBRdWVyeVN0YXR1czI7XG59KShRdWVyeVN0YXR1cyB8fCB7fSk7XG5mdW5jdGlvbiBnZXRSZXF1ZXN0U3RhdHVzRmxhZ3Moc3RhdHVzKSB7XG4gIHJldHVybiB7XG4gICAgc3RhdHVzLFxuICAgIGlzVW5pbml0aWFsaXplZDogc3RhdHVzID09PSBcInVuaW5pdGlhbGl6ZWRcIiAvKiB1bmluaXRpYWxpemVkICovLFxuICAgIGlzTG9hZGluZzogc3RhdHVzID09PSBcInBlbmRpbmdcIiAvKiBwZW5kaW5nICovLFxuICAgIGlzU3VjY2Vzczogc3RhdHVzID09PSBcImZ1bGZpbGxlZFwiIC8qIGZ1bGZpbGxlZCAqLyxcbiAgICBpc0Vycm9yOiBzdGF0dXMgPT09IFwicmVqZWN0ZWRcIiAvKiByZWplY3RlZCAqL1xuICB9O1xufVxuXG4vLyBzcmMvcXVlcnkvY29yZS9ydGtJbXBvcnRzLnRzXG5pbXBvcnQgeyBjcmVhdGVBY3Rpb24sIGNyZWF0ZVNsaWNlLCBjcmVhdGVTZWxlY3RvciwgY3JlYXRlQXN5bmNUaHVuaywgY29tYmluZVJlZHVjZXJzLCBjcmVhdGVOZXh0U3RhdGUsIGlzQW55T2YsIGlzQWxsT2YsIGlzQWN0aW9uLCBpc1BlbmRpbmcsIGlzUmVqZWN0ZWQsIGlzRnVsZmlsbGVkLCBpc1JlamVjdGVkV2l0aFZhbHVlLCBpc0FzeW5jVGh1bmtBY3Rpb24sIHByZXBhcmVBdXRvQmF0Y2hlZCwgU0hPVUxEX0FVVE9CQVRDSCwgaXNQbGFpbk9iamVjdCwgbmFub2lkIH0gZnJvbSBcIkByZWR1eGpzL3Rvb2xraXRcIjtcblxuLy8gc3JjL3F1ZXJ5L3V0aWxzL2NvcHlXaXRoU3RydWN0dXJhbFNoYXJpbmcudHNcbnZhciBpc1BsYWluT2JqZWN0MiA9IGlzUGxhaW5PYmplY3Q7XG5mdW5jdGlvbiBjb3B5V2l0aFN0cnVjdHVyYWxTaGFyaW5nKG9sZE9iaiwgbmV3T2JqKSB7XG4gIGlmIChvbGRPYmogPT09IG5ld09iaiB8fCAhKGlzUGxhaW5PYmplY3QyKG9sZE9iaikgJiYgaXNQbGFpbk9iamVjdDIobmV3T2JqKSB8fCBBcnJheS5pc0FycmF5KG9sZE9iaikgJiYgQXJyYXkuaXNBcnJheShuZXdPYmopKSkge1xuICAgIHJldHVybiBuZXdPYmo7XG4gIH1cbiAgY29uc3QgbmV3S2V5cyA9IE9iamVjdC5rZXlzKG5ld09iaik7XG4gIGNvbnN0IG9sZEtleXMgPSBPYmplY3Qua2V5cyhvbGRPYmopO1xuICBsZXQgaXNTYW1lT2JqZWN0ID0gbmV3S2V5cy5sZW5ndGggPT09IG9sZEtleXMubGVuZ3RoO1xuICBjb25zdCBtZXJnZU9iaiA9IEFycmF5LmlzQXJyYXkobmV3T2JqKSA/IFtdIDoge307XG4gIGZvciAoY29uc3Qga2V5IG9mIG5ld0tleXMpIHtcbiAgICBtZXJnZU9ialtrZXldID0gY29weVdpdGhTdHJ1Y3R1cmFsU2hhcmluZyhvbGRPYmpba2V5XSwgbmV3T2JqW2tleV0pO1xuICAgIGlmIChpc1NhbWVPYmplY3QpIGlzU2FtZU9iamVjdCA9IG9sZE9ialtrZXldID09PSBtZXJnZU9ialtrZXldO1xuICB9XG4gIHJldHVybiBpc1NhbWVPYmplY3QgPyBvbGRPYmogOiBtZXJnZU9iajtcbn1cblxuLy8gc3JjL3F1ZXJ5L3V0aWxzL2ZsYXR0ZW4udHNcbnZhciBmbGF0dGVuID0gKGFycikgPT4gW10uY29uY2F0KC4uLmFycik7XG5cbi8vIHNyYy9xdWVyeS91dGlscy9pc0Fic29sdXRlVXJsLnRzXG5mdW5jdGlvbiBpc0Fic29sdXRlVXJsKHVybCkge1xuICByZXR1cm4gbmV3IFJlZ0V4cChgKF58OikvL2ApLnRlc3QodXJsKTtcbn1cblxuLy8gc3JjL3F1ZXJ5L3V0aWxzL2lzRG9jdW1lbnRWaXNpYmxlLnRzXG5mdW5jdGlvbiBpc0RvY3VtZW50VmlzaWJsZSgpIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgIT09IFwiaGlkZGVuXCI7XG59XG5cbi8vIHNyYy9xdWVyeS91dGlscy9pc05vdE51bGxpc2gudHNcbmZ1bmN0aW9uIGlzTm90TnVsbGlzaCh2KSB7XG4gIHJldHVybiB2ICE9IG51bGw7XG59XG5mdW5jdGlvbiBmaWx0ZXJOdWxsaXNoVmFsdWVzKG1hcCkge1xuICByZXR1cm4gWy4uLm1hcD8udmFsdWVzKCkgPz8gW11dLmZpbHRlcihpc05vdE51bGxpc2gpO1xufVxuXG4vLyBzcmMvcXVlcnkvdXRpbHMvaXNPbmxpbmUudHNcbmZ1bmN0aW9uIGlzT25saW5lKCkge1xuICByZXR1cm4gdHlwZW9mIG5hdmlnYXRvciA9PT0gXCJ1bmRlZmluZWRcIiA/IHRydWUgOiBuYXZpZ2F0b3Iub25MaW5lID09PSB2b2lkIDAgPyB0cnVlIDogbmF2aWdhdG9yLm9uTGluZTtcbn1cblxuLy8gc3JjL3F1ZXJ5L3V0aWxzL2pvaW5VcmxzLnRzXG52YXIgd2l0aG91dFRyYWlsaW5nU2xhc2ggPSAodXJsKSA9PiB1cmwucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xudmFyIHdpdGhvdXRMZWFkaW5nU2xhc2ggPSAodXJsKSA9PiB1cmwucmVwbGFjZSgvXlxcLy8sIFwiXCIpO1xuZnVuY3Rpb24gam9pblVybHMoYmFzZSwgdXJsKSB7XG4gIGlmICghYmFzZSkge1xuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgaWYgKCF1cmwpIHtcbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuICBpZiAoaXNBYnNvbHV0ZVVybCh1cmwpKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICBjb25zdCBkZWxpbWl0ZXIgPSBiYXNlLmVuZHNXaXRoKFwiL1wiKSB8fCAhdXJsLnN0YXJ0c1dpdGgoXCI/XCIpID8gXCIvXCIgOiBcIlwiO1xuICBiYXNlID0gd2l0aG91dFRyYWlsaW5nU2xhc2goYmFzZSk7XG4gIHVybCA9IHdpdGhvdXRMZWFkaW5nU2xhc2godXJsKTtcbiAgcmV0dXJuIGAke2Jhc2V9JHtkZWxpbWl0ZXJ9JHt1cmx9YDtcbn1cblxuLy8gc3JjL3F1ZXJ5L3V0aWxzL2dldE9ySW5zZXJ0LnRzXG5mdW5jdGlvbiBnZXRPckluc2VydENvbXB1dGVkKG1hcCwga2V5LCBjb21wdXRlKSB7XG4gIGlmIChtYXAuaGFzKGtleSkpIHJldHVybiBtYXAuZ2V0KGtleSk7XG4gIHJldHVybiBtYXAuc2V0KGtleSwgY29tcHV0ZShrZXkpKS5nZXQoa2V5KTtcbn1cbnZhciBjcmVhdGVOZXdNYXAgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuXG4vLyBzcmMvcXVlcnkvZmV0Y2hCYXNlUXVlcnkudHNcbnZhciBkZWZhdWx0RmV0Y2hGbiA9ICguLi5hcmdzKSA9PiBmZXRjaCguLi5hcmdzKTtcbnZhciBkZWZhdWx0VmFsaWRhdGVTdGF0dXMgPSAocmVzcG9uc2UpID0+IHJlc3BvbnNlLnN0YXR1cyA+PSAyMDAgJiYgcmVzcG9uc2Uuc3RhdHVzIDw9IDI5OTtcbnZhciBkZWZhdWx0SXNKc29uQ29udGVudFR5cGUgPSAoaGVhZGVycykgPT4gKFxuICAvKmFwcGxpY2F0Ki9cbiAgL2lvblxcLyh2bmRcXC5hcGlcXCspP2pzb24vLnRlc3QoaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIikgfHwgXCJcIilcbik7XG5mdW5jdGlvbiBzdHJpcFVuZGVmaW5lZChvYmopIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KG9iaikpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIGNvbnN0IGNvcHkgPSB7XG4gICAgLi4ub2JqXG4gIH07XG4gIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKGNvcHkpKSB7XG4gICAgaWYgKHYgPT09IHZvaWQgMCkgZGVsZXRlIGNvcHlba107XG4gIH1cbiAgcmV0dXJuIGNvcHk7XG59XG52YXIgaXNKc29uaWZpYWJsZSA9IChib2R5KSA9PiB0eXBlb2YgYm9keSA9PT0gXCJvYmplY3RcIiAmJiAoaXNQbGFpbk9iamVjdChib2R5KSB8fCBBcnJheS5pc0FycmF5KGJvZHkpIHx8IHR5cGVvZiBib2R5LnRvSlNPTiA9PT0gXCJmdW5jdGlvblwiKTtcbmZ1bmN0aW9uIGZldGNoQmFzZVF1ZXJ5KHtcbiAgYmFzZVVybCxcbiAgcHJlcGFyZUhlYWRlcnMgPSAoeCkgPT4geCxcbiAgZmV0Y2hGbiA9IGRlZmF1bHRGZXRjaEZuLFxuICBwYXJhbXNTZXJpYWxpemVyLFxuICBpc0pzb25Db250ZW50VHlwZSA9IGRlZmF1bHRJc0pzb25Db250ZW50VHlwZSxcbiAganNvbkNvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gIGpzb25SZXBsYWNlcixcbiAgdGltZW91dDogZGVmYXVsdFRpbWVvdXQsXG4gIHJlc3BvbnNlSGFuZGxlcjogZ2xvYmFsUmVzcG9uc2VIYW5kbGVyLFxuICB2YWxpZGF0ZVN0YXR1czogZ2xvYmFsVmFsaWRhdGVTdGF0dXMsXG4gIC4uLmJhc2VGZXRjaE9wdGlvbnNcbn0gPSB7fSkge1xuICBpZiAodHlwZW9mIGZldGNoID09PSBcInVuZGVmaW5lZFwiICYmIGZldGNoRm4gPT09IGRlZmF1bHRGZXRjaEZuKSB7XG4gICAgY29uc29sZS53YXJuKFwiV2FybmluZzogYGZldGNoYCBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2Ugc3VwcGx5IGEgY3VzdG9tIGBmZXRjaEZuYCBwcm9wZXJ0eSB0byB1c2UgYGZldGNoQmFzZVF1ZXJ5YCBvbiBTU1IgZW52aXJvbm1lbnRzLlwiKTtcbiAgfVxuICByZXR1cm4gYXN5bmMgKGFyZywgYXBpLCBleHRyYU9wdGlvbnMpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBnZXRTdGF0ZSxcbiAgICAgIGV4dHJhLFxuICAgICAgZW5kcG9pbnQsXG4gICAgICBmb3JjZWQsXG4gICAgICB0eXBlXG4gICAgfSA9IGFwaTtcbiAgICBsZXQgbWV0YTtcbiAgICBsZXQge1xuICAgICAgdXJsLFxuICAgICAgaGVhZGVycyA9IG5ldyBIZWFkZXJzKGJhc2VGZXRjaE9wdGlvbnMuaGVhZGVycyksXG4gICAgICBwYXJhbXMgPSB2b2lkIDAsXG4gICAgICByZXNwb25zZUhhbmRsZXIgPSBnbG9iYWxSZXNwb25zZUhhbmRsZXIgPz8gXCJqc29uXCIsXG4gICAgICB2YWxpZGF0ZVN0YXR1cyA9IGdsb2JhbFZhbGlkYXRlU3RhdHVzID8/IGRlZmF1bHRWYWxpZGF0ZVN0YXR1cyxcbiAgICAgIHRpbWVvdXQgPSBkZWZhdWx0VGltZW91dCxcbiAgICAgIC4uLnJlc3RcbiAgICB9ID0gdHlwZW9mIGFyZyA9PSBcInN0cmluZ1wiID8ge1xuICAgICAgdXJsOiBhcmdcbiAgICB9IDogYXJnO1xuICAgIGxldCBhYm9ydENvbnRyb2xsZXIsIHNpZ25hbCA9IGFwaS5zaWduYWw7XG4gICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgIGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIGFwaS5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0Q29udHJvbGxlci5hYm9ydCk7XG4gICAgICBzaWduYWwgPSBhYm9ydENvbnRyb2xsZXIuc2lnbmFsO1xuICAgIH1cbiAgICBsZXQgY29uZmlnID0ge1xuICAgICAgLi4uYmFzZUZldGNoT3B0aW9ucyxcbiAgICAgIHNpZ25hbCxcbiAgICAgIC4uLnJlc3RcbiAgICB9O1xuICAgIGhlYWRlcnMgPSBuZXcgSGVhZGVycyhzdHJpcFVuZGVmaW5lZChoZWFkZXJzKSk7XG4gICAgY29uZmlnLmhlYWRlcnMgPSBhd2FpdCBwcmVwYXJlSGVhZGVycyhoZWFkZXJzLCB7XG4gICAgICBnZXRTdGF0ZSxcbiAgICAgIGFyZyxcbiAgICAgIGV4dHJhLFxuICAgICAgZW5kcG9pbnQsXG4gICAgICBmb3JjZWQsXG4gICAgICB0eXBlLFxuICAgICAgZXh0cmFPcHRpb25zXG4gICAgfSkgfHwgaGVhZGVycztcbiAgICBjb25zdCBib2R5SXNKc29uaWZpYWJsZSA9IGlzSnNvbmlmaWFibGUoY29uZmlnLmJvZHkpO1xuICAgIGlmIChjb25maWcuYm9keSAhPSBudWxsICYmICFib2R5SXNKc29uaWZpYWJsZSAmJiB0eXBlb2YgY29uZmlnLmJvZHkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbmZpZy5oZWFkZXJzLmRlbGV0ZShcImNvbnRlbnQtdHlwZVwiKTtcbiAgICB9XG4gICAgaWYgKCFjb25maWcuaGVhZGVycy5oYXMoXCJjb250ZW50LXR5cGVcIikgJiYgYm9keUlzSnNvbmlmaWFibGUpIHtcbiAgICAgIGNvbmZpZy5oZWFkZXJzLnNldChcImNvbnRlbnQtdHlwZVwiLCBqc29uQ29udGVudFR5cGUpO1xuICAgIH1cbiAgICBpZiAoYm9keUlzSnNvbmlmaWFibGUgJiYgaXNKc29uQ29udGVudFR5cGUoY29uZmlnLmhlYWRlcnMpKSB7XG4gICAgICBjb25maWcuYm9keSA9IEpTT04uc3RyaW5naWZ5KGNvbmZpZy5ib2R5LCBqc29uUmVwbGFjZXIpO1xuICAgIH1cbiAgICBpZiAoIWNvbmZpZy5oZWFkZXJzLmhhcyhcImFjY2VwdFwiKSkge1xuICAgICAgaWYgKHJlc3BvbnNlSGFuZGxlciA9PT0gXCJqc29uXCIpIHtcbiAgICAgICAgY29uZmlnLmhlYWRlcnMuc2V0KFwiYWNjZXB0XCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2VIYW5kbGVyID09PSBcInRleHRcIikge1xuICAgICAgICBjb25maWcuaGVhZGVycy5zZXQoXCJhY2NlcHRcIiwgXCJ0ZXh0L3BsYWluLCB0ZXh0L2h0bWwsICovKlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhcmFtcykge1xuICAgICAgY29uc3QgZGl2aWRlciA9IH51cmwuaW5kZXhPZihcIj9cIikgPyBcIiZcIiA6IFwiP1wiO1xuICAgICAgY29uc3QgcXVlcnkgPSBwYXJhbXNTZXJpYWxpemVyID8gcGFyYW1zU2VyaWFsaXplcihwYXJhbXMpIDogbmV3IFVSTFNlYXJjaFBhcmFtcyhzdHJpcFVuZGVmaW5lZChwYXJhbXMpKTtcbiAgICAgIHVybCArPSBkaXZpZGVyICsgcXVlcnk7XG4gICAgfVxuICAgIHVybCA9IGpvaW5VcmxzKGJhc2VVcmwsIHVybCk7XG4gICAgY29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHVybCwgY29uZmlnKTtcbiAgICBjb25zdCByZXF1ZXN0Q2xvbmUgPSBuZXcgUmVxdWVzdCh1cmwsIGNvbmZpZyk7XG4gICAgbWV0YSA9IHtcbiAgICAgIHJlcXVlc3Q6IHJlcXVlc3RDbG9uZVxuICAgIH07XG4gICAgbGV0IHJlc3BvbnNlLCB0aW1lZE91dCA9IGZhbHNlLCB0aW1lb3V0SWQgPSBhYm9ydENvbnRyb2xsZXIgJiYgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aW1lZE91dCA9IHRydWU7XG4gICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICB9LCB0aW1lb3V0KTtcbiAgICB0cnkge1xuICAgICAgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaEZuKHJlcXVlc3QpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgc3RhdHVzOiB0aW1lZE91dCA/IFwiVElNRU9VVF9FUlJPUlwiIDogXCJGRVRDSF9FUlJPUlwiLFxuICAgICAgICAgIGVycm9yOiBTdHJpbmcoZSlcbiAgICAgICAgfSxcbiAgICAgICAgbWV0YVxuICAgICAgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHRpbWVvdXRJZCkgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICBhYm9ydENvbnRyb2xsZXI/LnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgYWJvcnRDb250cm9sbGVyLmFib3J0KTtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2VDbG9uZSA9IHJlc3BvbnNlLmNsb25lKCk7XG4gICAgbWV0YS5yZXNwb25zZSA9IHJlc3BvbnNlQ2xvbmU7XG4gICAgbGV0IHJlc3VsdERhdGE7XG4gICAgbGV0IHJlc3BvbnNlVGV4dCA9IFwiXCI7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBoYW5kbGVSZXNwb25zZUVycm9yO1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICBoYW5kbGVSZXNwb25zZShyZXNwb25zZSwgcmVzcG9uc2VIYW5kbGVyKS50aGVuKChyKSA9PiByZXN1bHREYXRhID0gciwgKGUpID0+IGhhbmRsZVJlc3BvbnNlRXJyb3IgPSBlKSxcbiAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlLWZldGNoL25vZGUtZmV0Y2gvaXNzdWVzLzY2NSNpc3N1ZWNvbW1lbnQtNTM4OTk1MTgyXG4gICAgICAgIC8vIHdlICpoYXZlKiB0byBcInVzZSB1cFwiIGJvdGggc3RyZWFtcyBhdCB0aGUgc2FtZSB0aW1lIG9yIHRoZXkgd2lsbCBzdG9wIHJ1bm5pbmcgaW4gbm9kZS1mZXRjaCBzY2VuYXJpb3NcbiAgICAgICAgcmVzcG9uc2VDbG9uZS50ZXh0KCkudGhlbigocikgPT4gcmVzcG9uc2VUZXh0ID0gciwgKCkgPT4ge1xuICAgICAgICB9KVxuICAgICAgXSk7XG4gICAgICBpZiAoaGFuZGxlUmVzcG9uc2VFcnJvcikgdGhyb3cgaGFuZGxlUmVzcG9uc2VFcnJvcjtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlcnJvcjoge1xuICAgICAgICAgIHN0YXR1czogXCJQQVJTSU5HX0VSUk9SXCIsXG4gICAgICAgICAgb3JpZ2luYWxTdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICBkYXRhOiByZXNwb25zZVRleHQsXG4gICAgICAgICAgZXJyb3I6IFN0cmluZyhlKVxuICAgICAgICB9LFxuICAgICAgICBtZXRhXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdmFsaWRhdGVTdGF0dXMocmVzcG9uc2UsIHJlc3VsdERhdGEpID8ge1xuICAgICAgZGF0YTogcmVzdWx0RGF0YSxcbiAgICAgIG1ldGFcbiAgICB9IDoge1xuICAgICAgZXJyb3I6IHtcbiAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIGRhdGE6IHJlc3VsdERhdGFcbiAgICAgIH0sXG4gICAgICBtZXRhXG4gICAgfTtcbiAgfTtcbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UsIHJlc3BvbnNlSGFuZGxlcikge1xuICAgIGlmICh0eXBlb2YgcmVzcG9uc2VIYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiByZXNwb25zZUhhbmRsZXIocmVzcG9uc2UpO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2VIYW5kbGVyID09PSBcImNvbnRlbnQtdHlwZVwiKSB7XG4gICAgICByZXNwb25zZUhhbmRsZXIgPSBpc0pzb25Db250ZW50VHlwZShyZXNwb25zZS5oZWFkZXJzKSA/IFwianNvblwiIDogXCJ0ZXh0XCI7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZUhhbmRsZXIgPT09IFwianNvblwiKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgcmV0dXJuIHRleHQubGVuZ3RoID8gSlNPTi5wYXJzZSh0ZXh0KSA6IG51bGw7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gIH1cbn1cblxuLy8gc3JjL3F1ZXJ5L0hhbmRsZWRFcnJvci50c1xudmFyIEhhbmRsZWRFcnJvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodmFsdWUsIG1ldGEgPSB2b2lkIDApIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5tZXRhID0gbWV0YTtcbiAgfVxufTtcblxuLy8gc3JjL3F1ZXJ5L3JldHJ5LnRzXG5hc3luYyBmdW5jdGlvbiBkZWZhdWx0QmFja29mZihhdHRlbXB0ID0gMCwgbWF4UmV0cmllcyA9IDUsIHNpZ25hbCkge1xuICBjb25zdCBhdHRlbXB0cyA9IE1hdGgubWluKGF0dGVtcHQsIG1heFJldHJpZXMpO1xuICBjb25zdCB0aW1lb3V0ID0gfn4oKE1hdGgucmFuZG9tKCkgKyAwLjQpICogKDMwMCA8PCBhdHRlbXB0cykpO1xuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKCksIHRpbWVvdXQpO1xuICAgIGlmIChzaWduYWwpIHtcbiAgICAgIGNvbnN0IGFib3J0SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJBYm9ydGVkXCIpKTtcbiAgICAgIH07XG4gICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJBYm9ydGVkXCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgYWJvcnRIYW5kbGVyLCB7XG4gICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZmFpbChlcnJvciwgbWV0YSkge1xuICB0aHJvdyBPYmplY3QuYXNzaWduKG5ldyBIYW5kbGVkRXJyb3Ioe1xuICAgIGVycm9yLFxuICAgIG1ldGFcbiAgfSksIHtcbiAgICB0aHJvd0ltbWVkaWF0ZWx5OiB0cnVlXG4gIH0pO1xufVxuZnVuY3Rpb24gZmFpbElmQWJvcnRlZChzaWduYWwpIHtcbiAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgZmFpbCh7XG4gICAgICBzdGF0dXM6IFwiQ1VTVE9NX0VSUk9SXCIsXG4gICAgICBlcnJvcjogXCJBYm9ydGVkXCJcbiAgICB9KTtcbiAgfVxufVxudmFyIEVNUFRZX09QVElPTlMgPSB7fTtcbnZhciByZXRyeVdpdGhCYWNrb2ZmID0gKGJhc2VRdWVyeSwgZGVmYXVsdE9wdGlvbnMpID0+IGFzeW5jIChhcmdzLCBhcGksIGV4dHJhT3B0aW9ucykgPT4ge1xuICBjb25zdCBwb3NzaWJsZU1heFJldHJpZXMgPSBbNSwgKGRlZmF1bHRPcHRpb25zIHx8IEVNUFRZX09QVElPTlMpLm1heFJldHJpZXMsIChleHRyYU9wdGlvbnMgfHwgRU1QVFlfT1BUSU9OUykubWF4UmV0cmllc10uZmlsdGVyKCh4KSA9PiB4ICE9PSB2b2lkIDApO1xuICBjb25zdCBbbWF4UmV0cmllc10gPSBwb3NzaWJsZU1heFJldHJpZXMuc2xpY2UoLTEpO1xuICBjb25zdCBkZWZhdWx0UmV0cnlDb25kaXRpb24gPSAoXywgX18sIHtcbiAgICBhdHRlbXB0XG4gIH0pID0+IGF0dGVtcHQgPD0gbWF4UmV0cmllcztcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICBtYXhSZXRyaWVzLFxuICAgIGJhY2tvZmY6IGRlZmF1bHRCYWNrb2ZmLFxuICAgIHJldHJ5Q29uZGl0aW9uOiBkZWZhdWx0UmV0cnlDb25kaXRpb24sXG4gICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgLi4uZXh0cmFPcHRpb25zXG4gIH07XG4gIGxldCByZXRyeTIgPSAwO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGZhaWxJZkFib3J0ZWQoYXBpLnNpZ25hbCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGJhc2VRdWVyeShhcmdzLCBhcGksIGV4dHJhT3B0aW9ucyk7XG4gICAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBIYW5kbGVkRXJyb3IocmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0cnkyKys7XG4gICAgICBpZiAoZS50aHJvd0ltbWVkaWF0ZWx5KSB7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgSGFuZGxlZEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGUudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICAgIGlmIChlIGluc3RhbmNlb2YgSGFuZGxlZEVycm9yKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5yZXRyeUNvbmRpdGlvbihlLnZhbHVlLmVycm9yLCBhcmdzLCB7XG4gICAgICAgICAgYXR0ZW1wdDogcmV0cnkyLFxuICAgICAgICAgIGJhc2VRdWVyeUFwaTogYXBpLFxuICAgICAgICAgIGV4dHJhT3B0aW9uc1xuICAgICAgICB9KSkge1xuICAgICAgICAgIHJldHVybiBlLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmV0cnkyID4gb3B0aW9ucy5tYXhSZXRyaWVzKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmFpbElmQWJvcnRlZChhcGkuc2lnbmFsKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IG9wdGlvbnMuYmFja29mZihyZXRyeTIsIG9wdGlvbnMubWF4UmV0cmllcywgYXBpLnNpZ25hbCk7XG4gICAgICB9IGNhdGNoIChiYWNrb2ZmRXJyb3IpIHtcbiAgICAgICAgZmFpbElmQWJvcnRlZChhcGkuc2lnbmFsKTtcbiAgICAgICAgdGhyb3cgYmFja29mZkVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbnZhciByZXRyeSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuYXNzaWduKHJldHJ5V2l0aEJhY2tvZmYsIHtcbiAgZmFpbFxufSk7XG5cbi8vIHNyYy9xdWVyeS9jb3JlL3NldHVwTGlzdGVuZXJzLnRzXG52YXIgb25Gb2N1cyA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVBY3Rpb24oXCJfX3J0a3EvZm9jdXNlZFwiKTtcbnZhciBvbkZvY3VzTG9zdCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVBY3Rpb24oXCJfX3J0a3EvdW5mb2N1c2VkXCIpO1xudmFyIG9uT25saW5lID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUFjdGlvbihcIl9fcnRrcS9vbmxpbmVcIik7XG52YXIgb25PZmZsaW5lID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUFjdGlvbihcIl9fcnRrcS9vZmZsaW5lXCIpO1xudmFyIGluaXRpYWxpemVkID0gZmFsc2U7XG5mdW5jdGlvbiBzZXR1cExpc3RlbmVycyhkaXNwYXRjaCwgY3VzdG9tSGFuZGxlcikge1xuICBmdW5jdGlvbiBkZWZhdWx0SGFuZGxlcigpIHtcbiAgICBjb25zdCBoYW5kbGVGb2N1cyA9ICgpID0+IGRpc3BhdGNoKG9uRm9jdXMoKSk7XG4gICAgY29uc3QgaGFuZGxlRm9jdXNMb3N0ID0gKCkgPT4gZGlzcGF0Y2gob25Gb2N1c0xvc3QoKSk7XG4gICAgY29uc3QgaGFuZGxlT25saW5lID0gKCkgPT4gZGlzcGF0Y2gob25PbmxpbmUoKSk7XG4gICAgY29uc3QgaGFuZGxlT2ZmbGluZSA9ICgpID0+IGRpc3BhdGNoKG9uT2ZmbGluZSgpKTtcbiAgICBjb25zdCBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlID0gKCkgPT4ge1xuICAgICAgaWYgKHdpbmRvdy5kb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09IFwidmlzaWJsZVwiKSB7XG4gICAgICAgIGhhbmRsZUZvY3VzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kbGVGb2N1c0xvc3QoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmICghaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlLCBmYWxzZSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgaGFuZGxlRm9jdXMsIGZhbHNlKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgaGFuZGxlT25saW5lLCBmYWxzZSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib2ZmbGluZVwiLCBoYW5kbGVPZmZsaW5lLCBmYWxzZSk7XG4gICAgICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIGhhbmRsZUZvY3VzKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwib25saW5lXCIsIGhhbmRsZU9ubGluZSk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9mZmxpbmVcIiwgaGFuZGxlT2ZmbGluZSk7XG4gICAgICBpbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIH07XG4gICAgcmV0dXJuIHVuc3Vic2NyaWJlO1xuICB9XG4gIHJldHVybiBjdXN0b21IYW5kbGVyID8gY3VzdG9tSGFuZGxlcihkaXNwYXRjaCwge1xuICAgIG9uRm9jdXMsXG4gICAgb25Gb2N1c0xvc3QsXG4gICAgb25PZmZsaW5lLFxuICAgIG9uT25saW5lXG4gIH0pIDogZGVmYXVsdEhhbmRsZXIoKTtcbn1cblxuLy8gc3JjL3F1ZXJ5L2VuZHBvaW50RGVmaW5pdGlvbnMudHNcbmZ1bmN0aW9uIGlzUXVlcnlEZWZpbml0aW9uKGUpIHtcbiAgcmV0dXJuIGUudHlwZSA9PT0gXCJxdWVyeVwiIC8qIHF1ZXJ5ICovO1xufVxuZnVuY3Rpb24gaXNNdXRhdGlvbkRlZmluaXRpb24oZSkge1xuICByZXR1cm4gZS50eXBlID09PSBcIm11dGF0aW9uXCIgLyogbXV0YXRpb24gKi87XG59XG5mdW5jdGlvbiBpc0luZmluaXRlUXVlcnlEZWZpbml0aW9uKGUpIHtcbiAgcmV0dXJuIGUudHlwZSA9PT0gXCJpbmZpbml0ZXF1ZXJ5XCIgLyogaW5maW5pdGVxdWVyeSAqLztcbn1cbmZ1bmN0aW9uIGlzQW55UXVlcnlEZWZpbml0aW9uKGUpIHtcbiAgcmV0dXJuIGlzUXVlcnlEZWZpbml0aW9uKGUpIHx8IGlzSW5maW5pdGVRdWVyeURlZmluaXRpb24oZSk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVQcm92aWRlZEJ5KGRlc2NyaXB0aW9uLCByZXN1bHQsIGVycm9yLCBxdWVyeUFyZywgbWV0YSwgYXNzZXJ0VGFnVHlwZXMpIHtcbiAgaWYgKGlzRnVuY3Rpb24oZGVzY3JpcHRpb24pKSB7XG4gICAgcmV0dXJuIGRlc2NyaXB0aW9uKHJlc3VsdCwgZXJyb3IsIHF1ZXJ5QXJnLCBtZXRhKS5maWx0ZXIoaXNOb3ROdWxsaXNoKS5tYXAoZXhwYW5kVGFnRGVzY3JpcHRpb24pLm1hcChhc3NlcnRUYWdUeXBlcyk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGVzY3JpcHRpb24pKSB7XG4gICAgcmV0dXJuIGRlc2NyaXB0aW9uLm1hcChleHBhbmRUYWdEZXNjcmlwdGlvbikubWFwKGFzc2VydFRhZ1R5cGVzKTtcbiAgfVxuICByZXR1cm4gW107XG59XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIHR5cGVvZiB0ID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBleHBhbmRUYWdEZXNjcmlwdGlvbihkZXNjcmlwdGlvbikge1xuICByZXR1cm4gdHlwZW9mIGRlc2NyaXB0aW9uID09PSBcInN0cmluZ1wiID8ge1xuICAgIHR5cGU6IGRlc2NyaXB0aW9uXG4gIH0gOiBkZXNjcmlwdGlvbjtcbn1cblxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRUaHVua3MudHNcbmltcG9ydCB7IGlzRHJhZnRhYmxlLCBwcm9kdWNlV2l0aFBhdGNoZXMgfSBmcm9tIFwiaW1tZXJcIjtcblxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRJbml0aWF0ZS50c1xuaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XG5cbi8vIHNyYy90c0hlbHBlcnMudHNcbmZ1bmN0aW9uIGFzU2FmZVByb21pc2UocHJvbWlzZSwgZmFsbGJhY2spIHtcbiAgcmV0dXJuIHByb21pc2UuY2F0Y2goZmFsbGJhY2spO1xufVxuXG4vLyBzcmMvcXVlcnkvY29yZS9idWlsZEluaXRpYXRlLnRzXG52YXIgZm9yY2VRdWVyeUZuU3ltYm9sID0gU3ltYm9sKFwiZm9yY2VRdWVyeUZuXCIpO1xudmFyIGlzVXBzZXJ0UXVlcnkgPSAoYXJnKSA9PiB0eXBlb2YgYXJnW2ZvcmNlUXVlcnlGblN5bWJvbF0gPT09IFwiZnVuY3Rpb25cIjtcbmZ1bmN0aW9uIGJ1aWxkSW5pdGlhdGUoe1xuICBzZXJpYWxpemVRdWVyeUFyZ3MsXG4gIHF1ZXJ5VGh1bmssXG4gIGluZmluaXRlUXVlcnlUaHVuayxcbiAgbXV0YXRpb25UaHVuayxcbiAgYXBpLFxuICBjb250ZXh0LFxuICBnZXRJbnRlcm5hbFN0YXRlXG59KSB7XG4gIGNvbnN0IGdldFJ1bm5pbmdRdWVyaWVzID0gKGRpc3BhdGNoKSA9PiBnZXRJbnRlcm5hbFN0YXRlKGRpc3BhdGNoKT8ucnVubmluZ1F1ZXJpZXM7XG4gIGNvbnN0IGdldFJ1bm5pbmdNdXRhdGlvbnMgPSAoZGlzcGF0Y2gpID0+IGdldEludGVybmFsU3RhdGUoZGlzcGF0Y2gpPy5ydW5uaW5nTXV0YXRpb25zO1xuICBjb25zdCB7XG4gICAgdW5zdWJzY3JpYmVRdWVyeVJlc3VsdCxcbiAgICByZW1vdmVNdXRhdGlvblJlc3VsdCxcbiAgICB1cGRhdGVTdWJzY3JpcHRpb25PcHRpb25zXG4gIH0gPSBhcGkuaW50ZXJuYWxBY3Rpb25zO1xuICByZXR1cm4ge1xuICAgIGJ1aWxkSW5pdGlhdGVRdWVyeSxcbiAgICBidWlsZEluaXRpYXRlSW5maW5pdGVRdWVyeSxcbiAgICBidWlsZEluaXRpYXRlTXV0YXRpb24sXG4gICAgZ2V0UnVubmluZ1F1ZXJ5VGh1bmssXG4gICAgZ2V0UnVubmluZ011dGF0aW9uVGh1bmssXG4gICAgZ2V0UnVubmluZ1F1ZXJpZXNUaHVuayxcbiAgICBnZXRSdW5uaW5nTXV0YXRpb25zVGh1bmtcbiAgfTtcbiAgZnVuY3Rpb24gZ2V0UnVubmluZ1F1ZXJ5VGh1bmsoZW5kcG9pbnROYW1lLCBxdWVyeUFyZ3MpIHtcbiAgICByZXR1cm4gKGRpc3BhdGNoKSA9PiB7XG4gICAgICBjb25zdCBlbmRwb2ludERlZmluaXRpb24gPSBjb250ZXh0LmVuZHBvaW50RGVmaW5pdGlvbnNbZW5kcG9pbnROYW1lXTtcbiAgICAgIGNvbnN0IHF1ZXJ5Q2FjaGVLZXkgPSBzZXJpYWxpemVRdWVyeUFyZ3Moe1xuICAgICAgICBxdWVyeUFyZ3MsXG4gICAgICAgIGVuZHBvaW50RGVmaW5pdGlvbixcbiAgICAgICAgZW5kcG9pbnROYW1lXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBnZXRSdW5uaW5nUXVlcmllcyhkaXNwYXRjaCk/LmdldChxdWVyeUNhY2hlS2V5KTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGdldFJ1bm5pbmdNdXRhdGlvblRodW5rKF9lbmRwb2ludE5hbWUsIGZpeGVkQ2FjaGVLZXlPclJlcXVlc3RJZCkge1xuICAgIHJldHVybiAoZGlzcGF0Y2gpID0+IHtcbiAgICAgIHJldHVybiBnZXRSdW5uaW5nTXV0YXRpb25zKGRpc3BhdGNoKT8uZ2V0KGZpeGVkQ2FjaGVLZXlPclJlcXVlc3RJZCk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBnZXRSdW5uaW5nUXVlcmllc1RodW5rKCkge1xuICAgIHJldHVybiAoZGlzcGF0Y2gpID0+IGZpbHRlck51bGxpc2hWYWx1ZXMoZ2V0UnVubmluZ1F1ZXJpZXMoZGlzcGF0Y2gpKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRSdW5uaW5nTXV0YXRpb25zVGh1bmsoKSB7XG4gICAgcmV0dXJuIChkaXNwYXRjaCkgPT4gZmlsdGVyTnVsbGlzaFZhbHVlcyhnZXRSdW5uaW5nTXV0YXRpb25zKGRpc3BhdGNoKSk7XG4gIH1cbiAgZnVuY3Rpb24gbWlkZGxld2FyZVdhcm5pbmcoZGlzcGF0Y2gpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBpZiAobWlkZGxld2FyZVdhcm5pbmcudHJpZ2dlcmVkKSByZXR1cm47XG4gICAgICBjb25zdCByZXR1cm5lZFZhbHVlID0gZGlzcGF0Y2goYXBpLmludGVybmFsQWN0aW9ucy5pbnRlcm5hbF9nZXRSVEtRU3Vic2NyaXB0aW9ucygpKTtcbiAgICAgIG1pZGRsZXdhcmVXYXJuaW5nLnRyaWdnZXJlZCA9IHRydWU7XG4gICAgICBpZiAodHlwZW9mIHJldHVybmVkVmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHJldHVybmVkVmFsdWU/LnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDM0KSA6IGBXYXJuaW5nOiBNaWRkbGV3YXJlIGZvciBSVEstUXVlcnkgQVBJIGF0IHJlZHVjZXJQYXRoIFwiJHthcGkucmVkdWNlclBhdGh9XCIgaGFzIG5vdCBiZWVuIGFkZGVkIHRvIHRoZSBzdG9yZS5cbllvdSBtdXN0IGFkZCB0aGUgbWlkZGxld2FyZSBmb3IgUlRLLVF1ZXJ5IHRvIGZ1bmN0aW9uIGNvcnJlY3RseSFgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYnVpbGRJbml0aWF0ZUFueVF1ZXJ5KGVuZHBvaW50TmFtZSwgZW5kcG9pbnREZWZpbml0aW9uKSB7XG4gICAgY29uc3QgcXVlcnlBY3Rpb24gPSAoYXJnLCB7XG4gICAgICBzdWJzY3JpYmUgPSB0cnVlLFxuICAgICAgZm9yY2VSZWZldGNoLFxuICAgICAgc3Vic2NyaXB0aW9uT3B0aW9ucyxcbiAgICAgIFtmb3JjZVF1ZXJ5Rm5TeW1ib2xdOiBmb3JjZVF1ZXJ5Rm4sXG4gICAgICAuLi5yZXN0XG4gICAgfSA9IHt9KSA9PiAoZGlzcGF0Y2gsIGdldFN0YXRlKSA9PiB7XG4gICAgICBjb25zdCBxdWVyeUNhY2hlS2V5ID0gc2VyaWFsaXplUXVlcnlBcmdzKHtcbiAgICAgICAgcXVlcnlBcmdzOiBhcmcsXG4gICAgICAgIGVuZHBvaW50RGVmaW5pdGlvbixcbiAgICAgICAgZW5kcG9pbnROYW1lXG4gICAgICB9KTtcbiAgICAgIGxldCB0aHVuaztcbiAgICAgIGNvbnN0IGNvbW1vblRodW5rQXJncyA9IHtcbiAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgdHlwZTogXCJxdWVyeVwiLFxuICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgIGZvcmNlUmVmZXRjaCxcbiAgICAgICAgc3Vic2NyaXB0aW9uT3B0aW9ucyxcbiAgICAgICAgZW5kcG9pbnROYW1lLFxuICAgICAgICBvcmlnaW5hbEFyZ3M6IGFyZyxcbiAgICAgICAgcXVlcnlDYWNoZUtleSxcbiAgICAgICAgW2ZvcmNlUXVlcnlGblN5bWJvbF06IGZvcmNlUXVlcnlGblxuICAgICAgfTtcbiAgICAgIGlmIChpc1F1ZXJ5RGVmaW5pdGlvbihlbmRwb2ludERlZmluaXRpb24pKSB7XG4gICAgICAgIHRodW5rID0gcXVlcnlUaHVuayhjb21tb25UaHVua0FyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgICBpbml0aWFsUGFnZVBhcmFtXG4gICAgICAgIH0gPSByZXN0O1xuICAgICAgICB0aHVuayA9IGluZmluaXRlUXVlcnlUaHVuayh7XG4gICAgICAgICAgLi4uY29tbW9uVGh1bmtBcmdzLFxuICAgICAgICAgIC8vIFN1cHBseSB0aGVzZSBldmVuIGlmIHVuZGVmaW5lZC4gVGhpcyBoZWxwcyB3aXRoIGEgZmllbGQgZXhpc3RlbmNlXG4gICAgICAgICAgLy8gY2hlY2sgb3ZlciBpbiBgYnVpbGRTbGljZS50c2BcbiAgICAgICAgICBkaXJlY3Rpb24sXG4gICAgICAgICAgaW5pdGlhbFBhZ2VQYXJhbVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlbGVjdG9yID0gYXBpLmVuZHBvaW50c1tlbmRwb2ludE5hbWVdLnNlbGVjdChhcmcpO1xuICAgICAgY29uc3QgdGh1bmtSZXN1bHQgPSBkaXNwYXRjaCh0aHVuayk7XG4gICAgICBjb25zdCBzdGF0ZUFmdGVyID0gc2VsZWN0b3IoZ2V0U3RhdGUoKSk7XG4gICAgICBtaWRkbGV3YXJlV2FybmluZyhkaXNwYXRjaCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgYWJvcnRcbiAgICAgIH0gPSB0aHVua1Jlc3VsdDtcbiAgICAgIGNvbnN0IHNraXBwZWRTeW5jaHJvbm91c2x5ID0gc3RhdGVBZnRlci5yZXF1ZXN0SWQgIT09IHJlcXVlc3RJZDtcbiAgICAgIGNvbnN0IHJ1bm5pbmdRdWVyeSA9IGdldFJ1bm5pbmdRdWVyaWVzKGRpc3BhdGNoKT8uZ2V0KHF1ZXJ5Q2FjaGVLZXkpO1xuICAgICAgY29uc3Qgc2VsZWN0RnJvbVN0YXRlID0gKCkgPT4gc2VsZWN0b3IoZ2V0U3RhdGUoKSk7XG4gICAgICBjb25zdCBzdGF0ZVByb21pc2UgPSBPYmplY3QuYXNzaWduKGZvcmNlUXVlcnlGbiA/IChcbiAgICAgICAgLy8gYSBxdWVyeSBoYXMgYmVlbiBmb3JjZWQgKHVwc2VydFF1ZXJ5RGF0YSlcbiAgICAgICAgLy8gLT4gd2Ugd2FudCB0byByZXNvbHZlIGl0IG9uY2UgZGF0YSBoYXMgYmVlbiB3cml0dGVuIHdpdGggdGhlIGRhdGEgdGhhdCB3aWxsIGJlIHdyaXR0ZW5cbiAgICAgICAgdGh1bmtSZXN1bHQudGhlbihzZWxlY3RGcm9tU3RhdGUpXG4gICAgICApIDogc2tpcHBlZFN5bmNocm9ub3VzbHkgJiYgIXJ1bm5pbmdRdWVyeSA/IChcbiAgICAgICAgLy8gYSBxdWVyeSBoYXMgYmVlbiBza2lwcGVkIGR1ZSB0byBhIGNvbmRpdGlvbiBhbmQgd2UgZG8gbm90IGhhdmUgYW55IGN1cnJlbnRseSBydW5uaW5nIHF1ZXJ5XG4gICAgICAgIC8vIC0+IHdlIHdhbnQgdG8gcmVzb2x2ZSBpdCBpbW1lZGlhdGVseSB3aXRoIHRoZSBjdXJyZW50IGRhdGFcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHN0YXRlQWZ0ZXIpXG4gICAgICApIDogKFxuICAgICAgICAvLyBxdWVyeSBqdXN0IHN0YXJ0ZWQgb3Igb25lIGlzIGFscmVhZHkgaW4gZmxpZ2h0XG4gICAgICAgIC8vIC0+IHdhaXQgZm9yIHRoZSBydW5uaW5nIHF1ZXJ5LCB0aGVuIHJlc29sdmUgd2l0aCBkYXRhIGZyb20gYWZ0ZXIgdGhhdFxuICAgICAgICBQcm9taXNlLmFsbChbcnVubmluZ1F1ZXJ5LCB0aHVua1Jlc3VsdF0pLnRoZW4oc2VsZWN0RnJvbVN0YXRlKVxuICAgICAgKSwge1xuICAgICAgICBhcmcsXG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgc3Vic2NyaXB0aW9uT3B0aW9ucyxcbiAgICAgICAgcXVlcnlDYWNoZUtleSxcbiAgICAgICAgYWJvcnQsXG4gICAgICAgIGFzeW5jIHVud3JhcCgpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdGF0ZVByb21pc2U7XG4gICAgICAgICAgaWYgKHJlc3VsdC5pc0Vycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVmZXRjaDogKCkgPT4gZGlzcGF0Y2gocXVlcnlBY3Rpb24oYXJnLCB7XG4gICAgICAgICAgc3Vic2NyaWJlOiBmYWxzZSxcbiAgICAgICAgICBmb3JjZVJlZmV0Y2g6IHRydWVcbiAgICAgICAgfSkpLFxuICAgICAgICB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgICBpZiAoc3Vic2NyaWJlKSBkaXNwYXRjaCh1bnN1YnNjcmliZVF1ZXJ5UmVzdWx0KHtcbiAgICAgICAgICAgIHF1ZXJ5Q2FjaGVLZXksXG4gICAgICAgICAgICByZXF1ZXN0SWRcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZVN1YnNjcmlwdGlvbk9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICAgIHN0YXRlUHJvbWlzZS5zdWJzY3JpcHRpb25PcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICBkaXNwYXRjaCh1cGRhdGVTdWJzY3JpcHRpb25PcHRpb25zKHtcbiAgICAgICAgICAgIGVuZHBvaW50TmFtZSxcbiAgICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICAgIHF1ZXJ5Q2FjaGVLZXksXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICghcnVubmluZ1F1ZXJ5ICYmICFza2lwcGVkU3luY2hyb25vdXNseSAmJiAhZm9yY2VRdWVyeUZuKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5pbmdRdWVyaWVzID0gZ2V0UnVubmluZ1F1ZXJpZXMoZGlzcGF0Y2gpO1xuICAgICAgICBydW5uaW5nUXVlcmllcy5zZXQocXVlcnlDYWNoZUtleSwgc3RhdGVQcm9taXNlKTtcbiAgICAgICAgc3RhdGVQcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHJ1bm5pbmdRdWVyaWVzLmRlbGV0ZShxdWVyeUNhY2hlS2V5KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhdGVQcm9taXNlO1xuICAgIH07XG4gICAgcmV0dXJuIHF1ZXJ5QWN0aW9uO1xuICB9XG4gIGZ1bmN0aW9uIGJ1aWxkSW5pdGlhdGVRdWVyeShlbmRwb2ludE5hbWUsIGVuZHBvaW50RGVmaW5pdGlvbikge1xuICAgIGNvbnN0IHF1ZXJ5QWN0aW9uID0gYnVpbGRJbml0aWF0ZUFueVF1ZXJ5KGVuZHBvaW50TmFtZSwgZW5kcG9pbnREZWZpbml0aW9uKTtcbiAgICByZXR1cm4gcXVlcnlBY3Rpb247XG4gIH1cbiAgZnVuY3Rpb24gYnVpbGRJbml0aWF0ZUluZmluaXRlUXVlcnkoZW5kcG9pbnROYW1lLCBlbmRwb2ludERlZmluaXRpb24pIHtcbiAgICBjb25zdCBpbmZpbml0ZVF1ZXJ5QWN0aW9uID0gYnVpbGRJbml0aWF0ZUFueVF1ZXJ5KGVuZHBvaW50TmFtZSwgZW5kcG9pbnREZWZpbml0aW9uKTtcbiAgICByZXR1cm4gaW5maW5pdGVRdWVyeUFjdGlvbjtcbiAgfVxuICBmdW5jdGlvbiBidWlsZEluaXRpYXRlTXV0YXRpb24oZW5kcG9pbnROYW1lKSB7XG4gICAgcmV0dXJuIChhcmcsIHtcbiAgICAgIHRyYWNrID0gdHJ1ZSxcbiAgICAgIGZpeGVkQ2FjaGVLZXlcbiAgICB9ID0ge30pID0+IChkaXNwYXRjaCwgZ2V0U3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IHRodW5rID0gbXV0YXRpb25UaHVuayh7XG4gICAgICAgIHR5cGU6IFwibXV0YXRpb25cIixcbiAgICAgICAgZW5kcG9pbnROYW1lLFxuICAgICAgICBvcmlnaW5hbEFyZ3M6IGFyZyxcbiAgICAgICAgdHJhY2ssXG4gICAgICAgIGZpeGVkQ2FjaGVLZXlcbiAgICAgIH0pO1xuICAgICAgY29uc3QgdGh1bmtSZXN1bHQgPSBkaXNwYXRjaCh0aHVuayk7XG4gICAgICBtaWRkbGV3YXJlV2FybmluZyhkaXNwYXRjaCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgYWJvcnQsXG4gICAgICAgIHVud3JhcFxuICAgICAgfSA9IHRodW5rUmVzdWx0O1xuICAgICAgY29uc3QgcmV0dXJuVmFsdWVQcm9taXNlID0gYXNTYWZlUHJvbWlzZSh0aHVua1Jlc3VsdC51bndyYXAoKS50aGVuKChkYXRhKSA9PiAoe1xuICAgICAgICBkYXRhXG4gICAgICB9KSksIChlcnJvcikgPT4gKHtcbiAgICAgICAgZXJyb3JcbiAgICAgIH0pKTtcbiAgICAgIGNvbnN0IHJlc2V0ID0gKCkgPT4ge1xuICAgICAgICBkaXNwYXRjaChyZW1vdmVNdXRhdGlvblJlc3VsdCh7XG4gICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgIGZpeGVkQ2FjaGVLZXlcbiAgICAgICAgfSkpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHJldCA9IE9iamVjdC5hc3NpZ24ocmV0dXJuVmFsdWVQcm9taXNlLCB7XG4gICAgICAgIGFyZzogdGh1bmtSZXN1bHQuYXJnLFxuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIGFib3J0LFxuICAgICAgICB1bndyYXAsXG4gICAgICAgIHJlc2V0XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJ1bm5pbmdNdXRhdGlvbnMgPSBnZXRSdW5uaW5nTXV0YXRpb25zKGRpc3BhdGNoKTtcbiAgICAgIHJ1bm5pbmdNdXRhdGlvbnMuc2V0KHJlcXVlc3RJZCwgcmV0KTtcbiAgICAgIHJldC50aGVuKCgpID0+IHtcbiAgICAgICAgcnVubmluZ011dGF0aW9ucy5kZWxldGUocmVxdWVzdElkKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGZpeGVkQ2FjaGVLZXkpIHtcbiAgICAgICAgcnVubmluZ011dGF0aW9ucy5zZXQoZml4ZWRDYWNoZUtleSwgcmV0KTtcbiAgICAgICAgcmV0LnRoZW4oKCkgPT4ge1xuICAgICAgICAgIGlmIChydW5uaW5nTXV0YXRpb25zLmdldChmaXhlZENhY2hlS2V5KSA9PT0gcmV0KSB7XG4gICAgICAgICAgICBydW5uaW5nTXV0YXRpb25zLmRlbGV0ZShmaXhlZENhY2hlS2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICB9XG59XG5cbi8vIHNyYy9xdWVyeS9zdGFuZGFyZFNjaGVtYS50c1xuaW1wb3J0IHsgU2NoZW1hRXJyb3IgfSBmcm9tIFwiQHN0YW5kYXJkLXNjaGVtYS91dGlsc1wiO1xudmFyIE5hbWVkU2NoZW1hRXJyb3IgPSBjbGFzcyBleHRlbmRzIFNjaGVtYUVycm9yIHtcbiAgY29uc3RydWN0b3IoaXNzdWVzLCB2YWx1ZSwgc2NoZW1hTmFtZSwgX2JxTWV0YSkge1xuICAgIHN1cGVyKGlzc3Vlcyk7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuc2NoZW1hTmFtZSA9IHNjaGVtYU5hbWU7XG4gICAgdGhpcy5fYnFNZXRhID0gX2JxTWV0YTtcbiAgfVxufTtcbnZhciBzaG91bGRTa2lwID0gKHNraXBTY2hlbWFWYWxpZGF0aW9uLCBzY2hlbWFOYW1lKSA9PiBBcnJheS5pc0FycmF5KHNraXBTY2hlbWFWYWxpZGF0aW9uKSA/IHNraXBTY2hlbWFWYWxpZGF0aW9uLmluY2x1ZGVzKHNjaGVtYU5hbWUpIDogISFza2lwU2NoZW1hVmFsaWRhdGlvbjtcbmFzeW5jIGZ1bmN0aW9uIHBhcnNlV2l0aFNjaGVtYShzY2hlbWEsIGRhdGEsIHNjaGVtYU5hbWUsIGJxTWV0YSkge1xuICBjb25zdCByZXN1bHQgPSBhd2FpdCBzY2hlbWFbXCJ+c3RhbmRhcmRcIl0udmFsaWRhdGUoZGF0YSk7XG4gIGlmIChyZXN1bHQuaXNzdWVzKSB7XG4gICAgdGhyb3cgbmV3IE5hbWVkU2NoZW1hRXJyb3IocmVzdWx0Lmlzc3VlcywgZGF0YSwgc2NoZW1hTmFtZSwgYnFNZXRhKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0LnZhbHVlO1xufVxuXG4vLyBzcmMvcXVlcnkvY29yZS9idWlsZFRodW5rcy50c1xuZnVuY3Rpb24gZGVmYXVsdFRyYW5zZm9ybVJlc3BvbnNlKGJhc2VRdWVyeVJldHVyblZhbHVlKSB7XG4gIHJldHVybiBiYXNlUXVlcnlSZXR1cm5WYWx1ZTtcbn1cbnZhciBhZGRTaG91bGRBdXRvQmF0Y2ggPSAoYXJnID0ge30pID0+IHtcbiAgcmV0dXJuIHtcbiAgICAuLi5hcmcsXG4gICAgW1NIT1VMRF9BVVRPQkFUQ0hdOiB0cnVlXG4gIH07XG59O1xuZnVuY3Rpb24gYnVpbGRUaHVua3Moe1xuICByZWR1Y2VyUGF0aCxcbiAgYmFzZVF1ZXJ5LFxuICBjb250ZXh0OiB7XG4gICAgZW5kcG9pbnREZWZpbml0aW9uc1xuICB9LFxuICBzZXJpYWxpemVRdWVyeUFyZ3MsXG4gIGFwaSxcbiAgYXNzZXJ0VGFnVHlwZSxcbiAgc2VsZWN0b3JzLFxuICBvblNjaGVtYUZhaWx1cmUsXG4gIGNhdGNoU2NoZW1hRmFpbHVyZTogZ2xvYmFsQ2F0Y2hTY2hlbWFGYWlsdXJlLFxuICBza2lwU2NoZW1hVmFsaWRhdGlvbjogZ2xvYmFsU2tpcFNjaGVtYVZhbGlkYXRpb25cbn0pIHtcbiAgY29uc3QgcGF0Y2hRdWVyeURhdGEgPSAoZW5kcG9pbnROYW1lLCBhcmcsIHBhdGNoZXMsIHVwZGF0ZVByb3ZpZGVkKSA9PiAoZGlzcGF0Y2gsIGdldFN0YXRlKSA9PiB7XG4gICAgY29uc3QgZW5kcG9pbnREZWZpbml0aW9uID0gZW5kcG9pbnREZWZpbml0aW9uc1tlbmRwb2ludE5hbWVdO1xuICAgIGNvbnN0IHF1ZXJ5Q2FjaGVLZXkgPSBzZXJpYWxpemVRdWVyeUFyZ3Moe1xuICAgICAgcXVlcnlBcmdzOiBhcmcsXG4gICAgICBlbmRwb2ludERlZmluaXRpb24sXG4gICAgICBlbmRwb2ludE5hbWVcbiAgICB9KTtcbiAgICBkaXNwYXRjaChhcGkuaW50ZXJuYWxBY3Rpb25zLnF1ZXJ5UmVzdWx0UGF0Y2hlZCh7XG4gICAgICBxdWVyeUNhY2hlS2V5LFxuICAgICAgcGF0Y2hlc1xuICAgIH0pKTtcbiAgICBpZiAoIXVwZGF0ZVByb3ZpZGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5ld1ZhbHVlID0gYXBpLmVuZHBvaW50c1tlbmRwb2ludE5hbWVdLnNlbGVjdChhcmcpKFxuICAgICAgLy8gV29yayBhcm91bmQgVFMgNC4xIG1pc21hdGNoXG4gICAgICBnZXRTdGF0ZSgpXG4gICAgKTtcbiAgICBjb25zdCBwcm92aWRlZFRhZ3MgPSBjYWxjdWxhdGVQcm92aWRlZEJ5KGVuZHBvaW50RGVmaW5pdGlvbi5wcm92aWRlc1RhZ3MsIG5ld1ZhbHVlLmRhdGEsIHZvaWQgMCwgYXJnLCB7fSwgYXNzZXJ0VGFnVHlwZSk7XG4gICAgZGlzcGF0Y2goYXBpLmludGVybmFsQWN0aW9ucy51cGRhdGVQcm92aWRlZEJ5KFt7XG4gICAgICBxdWVyeUNhY2hlS2V5LFxuICAgICAgcHJvdmlkZWRUYWdzXG4gICAgfV0pKTtcbiAgfTtcbiAgZnVuY3Rpb24gYWRkVG9TdGFydChpdGVtcywgaXRlbSwgbWF4ID0gMCkge1xuICAgIGNvbnN0IG5ld0l0ZW1zID0gW2l0ZW0sIC4uLml0ZW1zXTtcbiAgICByZXR1cm4gbWF4ICYmIG5ld0l0ZW1zLmxlbmd0aCA+IG1heCA/IG5ld0l0ZW1zLnNsaWNlKDAsIC0xKSA6IG5ld0l0ZW1zO1xuICB9XG4gIGZ1bmN0aW9uIGFkZFRvRW5kKGl0ZW1zLCBpdGVtLCBtYXggPSAwKSB7XG4gICAgY29uc3QgbmV3SXRlbXMgPSBbLi4uaXRlbXMsIGl0ZW1dO1xuICAgIHJldHVybiBtYXggJiYgbmV3SXRlbXMubGVuZ3RoID4gbWF4ID8gbmV3SXRlbXMuc2xpY2UoMSkgOiBuZXdJdGVtcztcbiAgfVxuICBjb25zdCB1cGRhdGVRdWVyeURhdGEgPSAoZW5kcG9pbnROYW1lLCBhcmcsIHVwZGF0ZVJlY2lwZSwgdXBkYXRlUHJvdmlkZWQgPSB0cnVlKSA9PiAoZGlzcGF0Y2gsIGdldFN0YXRlKSA9PiB7XG4gICAgY29uc3QgZW5kcG9pbnREZWZpbml0aW9uID0gYXBpLmVuZHBvaW50c1tlbmRwb2ludE5hbWVdO1xuICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IGVuZHBvaW50RGVmaW5pdGlvbi5zZWxlY3QoYXJnKShcbiAgICAgIC8vIFdvcmsgYXJvdW5kIFRTIDQuMSBtaXNtYXRjaFxuICAgICAgZ2V0U3RhdGUoKVxuICAgICk7XG4gICAgY29uc3QgcmV0ID0ge1xuICAgICAgcGF0Y2hlczogW10sXG4gICAgICBpbnZlcnNlUGF0Y2hlczogW10sXG4gICAgICB1bmRvOiAoKSA9PiBkaXNwYXRjaChhcGkudXRpbC5wYXRjaFF1ZXJ5RGF0YShlbmRwb2ludE5hbWUsIGFyZywgcmV0LmludmVyc2VQYXRjaGVzLCB1cGRhdGVQcm92aWRlZCkpXG4gICAgfTtcbiAgICBpZiAoY3VycmVudFN0YXRlLnN0YXR1cyA9PT0gXCJ1bmluaXRpYWxpemVkXCIgLyogdW5pbml0aWFsaXplZCAqLykge1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgbGV0IG5ld1ZhbHVlO1xuICAgIGlmIChcImRhdGFcIiBpbiBjdXJyZW50U3RhdGUpIHtcbiAgICAgIGlmIChpc0RyYWZ0YWJsZShjdXJyZW50U3RhdGUuZGF0YSkpIHtcbiAgICAgICAgY29uc3QgW3ZhbHVlLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlc10gPSBwcm9kdWNlV2l0aFBhdGNoZXMoY3VycmVudFN0YXRlLmRhdGEsIHVwZGF0ZVJlY2lwZSk7XG4gICAgICAgIHJldC5wYXRjaGVzLnB1c2goLi4ucGF0Y2hlcyk7XG4gICAgICAgIHJldC5pbnZlcnNlUGF0Y2hlcy5wdXNoKC4uLmludmVyc2VQYXRjaGVzKTtcbiAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld1ZhbHVlID0gdXBkYXRlUmVjaXBlKGN1cnJlbnRTdGF0ZS5kYXRhKTtcbiAgICAgICAgcmV0LnBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgb3A6IFwicmVwbGFjZVwiLFxuICAgICAgICAgIHBhdGg6IFtdLFxuICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0LmludmVyc2VQYXRjaGVzLnB1c2goe1xuICAgICAgICAgIG9wOiBcInJlcGxhY2VcIixcbiAgICAgICAgICBwYXRoOiBbXSxcbiAgICAgICAgICB2YWx1ZTogY3VycmVudFN0YXRlLmRhdGFcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZXQucGF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGRpc3BhdGNoKGFwaS51dGlsLnBhdGNoUXVlcnlEYXRhKGVuZHBvaW50TmFtZSwgYXJnLCByZXQucGF0Y2hlcywgdXBkYXRlUHJvdmlkZWQpKTtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xuICBjb25zdCB1cHNlcnRRdWVyeURhdGEgPSAoZW5kcG9pbnROYW1lLCBhcmcsIHZhbHVlKSA9PiAoZGlzcGF0Y2gpID0+IHtcbiAgICBjb25zdCByZXMgPSBkaXNwYXRjaChhcGkuZW5kcG9pbnRzW2VuZHBvaW50TmFtZV0uaW5pdGlhdGUoYXJnLCB7XG4gICAgICBzdWJzY3JpYmU6IGZhbHNlLFxuICAgICAgZm9yY2VSZWZldGNoOiB0cnVlLFxuICAgICAgW2ZvcmNlUXVlcnlGblN5bWJvbF06ICgpID0+ICh7XG4gICAgICAgIGRhdGE6IHZhbHVlXG4gICAgICB9KVxuICAgIH0pKTtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuICBjb25zdCBnZXRUcmFuc2Zvcm1DYWxsYmFja0ZvckVuZHBvaW50ID0gKGVuZHBvaW50RGVmaW5pdGlvbiwgdHJhbnNmb3JtRmllbGROYW1lKSA9PiB7XG4gICAgcmV0dXJuIGVuZHBvaW50RGVmaW5pdGlvbi5xdWVyeSAmJiBlbmRwb2ludERlZmluaXRpb25bdHJhbnNmb3JtRmllbGROYW1lXSA/IGVuZHBvaW50RGVmaW5pdGlvblt0cmFuc2Zvcm1GaWVsZE5hbWVdIDogZGVmYXVsdFRyYW5zZm9ybVJlc3BvbnNlO1xuICB9O1xuICBjb25zdCBleGVjdXRlRW5kcG9pbnQgPSBhc3luYyAoYXJnLCB7XG4gICAgc2lnbmFsLFxuICAgIGFib3J0LFxuICAgIHJlamVjdFdpdGhWYWx1ZSxcbiAgICBmdWxmaWxsV2l0aFZhbHVlLFxuICAgIGRpc3BhdGNoLFxuICAgIGdldFN0YXRlLFxuICAgIGV4dHJhXG4gIH0pID0+IHtcbiAgICBjb25zdCBlbmRwb2ludERlZmluaXRpb24gPSBlbmRwb2ludERlZmluaXRpb25zW2FyZy5lbmRwb2ludE5hbWVdO1xuICAgIGNvbnN0IHtcbiAgICAgIG1ldGFTY2hlbWEsXG4gICAgICBza2lwU2NoZW1hVmFsaWRhdGlvbiA9IGdsb2JhbFNraXBTY2hlbWFWYWxpZGF0aW9uXG4gICAgfSA9IGVuZHBvaW50RGVmaW5pdGlvbjtcbiAgICB0cnkge1xuICAgICAgbGV0IHRyYW5zZm9ybVJlc3BvbnNlID0gZGVmYXVsdFRyYW5zZm9ybVJlc3BvbnNlO1xuICAgICAgY29uc3QgYmFzZVF1ZXJ5QXBpID0ge1xuICAgICAgICBzaWduYWwsXG4gICAgICAgIGFib3J0LFxuICAgICAgICBkaXNwYXRjaCxcbiAgICAgICAgZ2V0U3RhdGUsXG4gICAgICAgIGV4dHJhLFxuICAgICAgICBlbmRwb2ludDogYXJnLmVuZHBvaW50TmFtZSxcbiAgICAgICAgdHlwZTogYXJnLnR5cGUsXG4gICAgICAgIGZvcmNlZDogYXJnLnR5cGUgPT09IFwicXVlcnlcIiA/IGlzRm9yY2VkUXVlcnkoYXJnLCBnZXRTdGF0ZSgpKSA6IHZvaWQgMCxcbiAgICAgICAgcXVlcnlDYWNoZUtleTogYXJnLnR5cGUgPT09IFwicXVlcnlcIiA/IGFyZy5xdWVyeUNhY2hlS2V5IDogdm9pZCAwXG4gICAgICB9O1xuICAgICAgY29uc3QgZm9yY2VRdWVyeUZuID0gYXJnLnR5cGUgPT09IFwicXVlcnlcIiA/IGFyZ1tmb3JjZVF1ZXJ5Rm5TeW1ib2xdIDogdm9pZCAwO1xuICAgICAgbGV0IGZpbmFsUXVlcnlSZXR1cm5WYWx1ZTtcbiAgICAgIGNvbnN0IGZldGNoUGFnZSA9IGFzeW5jIChkYXRhLCBwYXJhbSwgbWF4UGFnZXMsIHByZXZpb3VzKSA9PiB7XG4gICAgICAgIGlmIChwYXJhbSA9PSBudWxsICYmIGRhdGEucGFnZXMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICBkYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmluYWxRdWVyeUFyZyA9IHtcbiAgICAgICAgICBxdWVyeUFyZzogYXJnLm9yaWdpbmFsQXJncyxcbiAgICAgICAgICBwYWdlUGFyYW06IHBhcmFtXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHBhZ2VSZXNwb25zZSA9IGF3YWl0IGV4ZWN1dGVSZXF1ZXN0KGZpbmFsUXVlcnlBcmcpO1xuICAgICAgICBjb25zdCBhZGRUbyA9IHByZXZpb3VzID8gYWRkVG9TdGFydCA6IGFkZFRvRW5kO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHBhZ2VzOiBhZGRUbyhkYXRhLnBhZ2VzLCBwYWdlUmVzcG9uc2UuZGF0YSwgbWF4UGFnZXMpLFxuICAgICAgICAgICAgcGFnZVBhcmFtczogYWRkVG8oZGF0YS5wYWdlUGFyYW1zLCBwYXJhbSwgbWF4UGFnZXMpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBtZXRhOiBwYWdlUmVzcG9uc2UubWV0YVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIGFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGVSZXF1ZXN0KGZpbmFsUXVlcnlBcmcpIHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGV4dHJhT3B0aW9ucyxcbiAgICAgICAgICBhcmdTY2hlbWEsXG4gICAgICAgICAgcmF3UmVzcG9uc2VTY2hlbWEsXG4gICAgICAgICAgcmVzcG9uc2VTY2hlbWFcbiAgICAgICAgfSA9IGVuZHBvaW50RGVmaW5pdGlvbjtcbiAgICAgICAgaWYgKGFyZ1NjaGVtYSAmJiAhc2hvdWxkU2tpcChza2lwU2NoZW1hVmFsaWRhdGlvbiwgXCJhcmdcIikpIHtcbiAgICAgICAgICBmaW5hbFF1ZXJ5QXJnID0gYXdhaXQgcGFyc2VXaXRoU2NoZW1hKFxuICAgICAgICAgICAgYXJnU2NoZW1hLFxuICAgICAgICAgICAgZmluYWxRdWVyeUFyZyxcbiAgICAgICAgICAgIFwiYXJnU2NoZW1hXCIsXG4gICAgICAgICAgICB7fVxuICAgICAgICAgICAgLy8gd2UgZG9uJ3QgaGF2ZSBhIG1ldGEgeWV0LCBzbyB3ZSBjYW4ndCBwYXNzIGl0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9yY2VRdWVyeUZuKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZm9yY2VRdWVyeUZuKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZW5kcG9pbnREZWZpbml0aW9uLnF1ZXJ5KSB7XG4gICAgICAgICAgdHJhbnNmb3JtUmVzcG9uc2UgPSBnZXRUcmFuc2Zvcm1DYWxsYmFja0ZvckVuZHBvaW50KGVuZHBvaW50RGVmaW5pdGlvbiwgXCJ0cmFuc2Zvcm1SZXNwb25zZVwiKTtcbiAgICAgICAgICByZXN1bHQgPSBhd2FpdCBiYXNlUXVlcnkoZW5kcG9pbnREZWZpbml0aW9uLnF1ZXJ5KGZpbmFsUXVlcnlBcmcpLCBiYXNlUXVlcnlBcGksIGV4dHJhT3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gYXdhaXQgZW5kcG9pbnREZWZpbml0aW9uLnF1ZXJ5Rm4oZmluYWxRdWVyeUFyZywgYmFzZVF1ZXJ5QXBpLCBleHRyYU9wdGlvbnMsIChhcmcyKSA9PiBiYXNlUXVlcnkoYXJnMiwgYmFzZVF1ZXJ5QXBpLCBleHRyYU9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICAgIGNvbnN0IHdoYXQgPSBlbmRwb2ludERlZmluaXRpb24ucXVlcnkgPyBcImBiYXNlUXVlcnlgXCIgOiBcImBxdWVyeUZuYFwiO1xuICAgICAgICAgIGxldCBlcnI7XG4gICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIGVyciA9IGAke3doYXR9IGRpZCBub3QgcmV0dXJuIGFueXRoaW5nLmA7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVzdWx0ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBlcnIgPSBgJHt3aGF0fSBkaWQgbm90IHJldHVybiBhbiBvYmplY3QuYDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5lcnJvciAmJiByZXN1bHQuZGF0YSkge1xuICAgICAgICAgICAgZXJyID0gYCR7d2hhdH0gcmV0dXJuZWQgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYm90aCBcXGBlcnJvclxcYCBhbmQgXFxgcmVzdWx0XFxgLmA7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQuZXJyb3IgPT09IHZvaWQgMCAmJiByZXN1bHQuZGF0YSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBlcnIgPSBgJHt3aGF0fSByZXR1cm5lZCBhbiBvYmplY3QgY29udGFpbmluZyBuZWl0aGVyIGEgdmFsaWQgXFxgZXJyb3JcXGAgYW5kIFxcYHJlc3VsdFxcYC4gQXQgbGVhc3Qgb25lIG9mIHRoZW0gc2hvdWxkIG5vdCBiZSBcXGB1bmRlZmluZWRcXGBgO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhyZXN1bHQpKSB7XG4gICAgICAgICAgICAgIGlmIChrZXkgIT09IFwiZXJyb3JcIiAmJiBrZXkgIT09IFwiZGF0YVwiICYmIGtleSAhPT0gXCJtZXRhXCIpIHtcbiAgICAgICAgICAgICAgICBlcnIgPSBgVGhlIG9iamVjdCByZXR1cm5lZCBieSAke3doYXR9IGhhcyB0aGUgdW5rbm93biBwcm9wZXJ0eSAke2tleX0uYDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBlbmNvdW50ZXJlZCBoYW5kbGluZyB0aGUgZW5kcG9pbnQgJHthcmcuZW5kcG9pbnROYW1lfS5cbiAgICAgICAgICAgICAgICAgICR7ZXJyfVxuICAgICAgICAgICAgICAgICAgSXQgbmVlZHMgdG8gcmV0dXJuIGFuIG9iamVjdCB3aXRoIGVpdGhlciB0aGUgc2hhcGUgXFxgeyBkYXRhOiA8dmFsdWU+IH1cXGAgb3IgXFxgeyBlcnJvcjogPHZhbHVlPiB9XFxgIHRoYXQgbWF5IGNvbnRhaW4gYW4gb3B0aW9uYWwgXFxgbWV0YVxcYCBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAgIE9iamVjdCByZXR1cm5lZCB3YXM6YCwgcmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5lcnJvcikgdGhyb3cgbmV3IEhhbmRsZWRFcnJvcihyZXN1bHQuZXJyb3IsIHJlc3VsdC5tZXRhKTtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBkYXRhXG4gICAgICAgIH0gPSByZXN1bHQ7XG4gICAgICAgIGlmIChyYXdSZXNwb25zZVNjaGVtYSAmJiAhc2hvdWxkU2tpcChza2lwU2NoZW1hVmFsaWRhdGlvbiwgXCJyYXdSZXNwb25zZVwiKSkge1xuICAgICAgICAgIGRhdGEgPSBhd2FpdCBwYXJzZVdpdGhTY2hlbWEocmF3UmVzcG9uc2VTY2hlbWEsIHJlc3VsdC5kYXRhLCBcInJhd1Jlc3BvbnNlU2NoZW1hXCIsIHJlc3VsdC5tZXRhKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdHJhbnNmb3JtZWRSZXNwb25zZSA9IGF3YWl0IHRyYW5zZm9ybVJlc3BvbnNlKGRhdGEsIHJlc3VsdC5tZXRhLCBmaW5hbFF1ZXJ5QXJnKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlU2NoZW1hICYmICFzaG91bGRTa2lwKHNraXBTY2hlbWFWYWxpZGF0aW9uLCBcInJlc3BvbnNlXCIpKSB7XG4gICAgICAgICAgdHJhbnNmb3JtZWRSZXNwb25zZSA9IGF3YWl0IHBhcnNlV2l0aFNjaGVtYShyZXNwb25zZVNjaGVtYSwgdHJhbnNmb3JtZWRSZXNwb25zZSwgXCJyZXNwb25zZVNjaGVtYVwiLCByZXN1bHQubWV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgICAgZGF0YTogdHJhbnNmb3JtZWRSZXNwb25zZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGFyZy50eXBlID09PSBcInF1ZXJ5XCIgJiYgXCJpbmZpbml0ZVF1ZXJ5T3B0aW9uc1wiIGluIGVuZHBvaW50RGVmaW5pdGlvbikge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaW5maW5pdGVRdWVyeU9wdGlvbnNcbiAgICAgICAgfSA9IGVuZHBvaW50RGVmaW5pdGlvbjtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIG1heFBhZ2VzID0gSW5maW5pdHlcbiAgICAgICAgfSA9IGluZmluaXRlUXVlcnlPcHRpb25zO1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBjb25zdCBibGFua0RhdGEgPSB7XG4gICAgICAgICAgcGFnZXM6IFtdLFxuICAgICAgICAgIHBhZ2VQYXJhbXM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNhY2hlZERhdGEgPSBzZWxlY3RvcnMuc2VsZWN0UXVlcnlFbnRyeShnZXRTdGF0ZSgpLCBhcmcucXVlcnlDYWNoZUtleSk/LmRhdGE7XG4gICAgICAgIGNvbnN0IGlzRm9yY2VkUXVlcnlOZWVkaW5nUmVmZXRjaCA9IChcbiAgICAgICAgICAvLyBhcmcuZm9yY2VSZWZldGNoXG4gICAgICAgICAgaXNGb3JjZWRRdWVyeShhcmcsIGdldFN0YXRlKCkpICYmICFhcmcuZGlyZWN0aW9uXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nRGF0YSA9IGlzRm9yY2VkUXVlcnlOZWVkaW5nUmVmZXRjaCB8fCAhY2FjaGVkRGF0YSA/IGJsYW5rRGF0YSA6IGNhY2hlZERhdGE7XG4gICAgICAgIGlmIChcImRpcmVjdGlvblwiIGluIGFyZyAmJiBhcmcuZGlyZWN0aW9uICYmIGV4aXN0aW5nRGF0YS5wYWdlcy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBwcmV2aW91cyA9IGFyZy5kaXJlY3Rpb24gPT09IFwiYmFja3dhcmRcIjtcbiAgICAgICAgICBjb25zdCBwYWdlUGFyYW1GbiA9IHByZXZpb3VzID8gZ2V0UHJldmlvdXNQYWdlUGFyYW0gOiBnZXROZXh0UGFnZVBhcmFtO1xuICAgICAgICAgIGNvbnN0IHBhcmFtID0gcGFnZVBhcmFtRm4oaW5maW5pdGVRdWVyeU9wdGlvbnMsIGV4aXN0aW5nRGF0YSwgYXJnLm9yaWdpbmFsQXJncyk7XG4gICAgICAgICAgcmVzdWx0ID0gYXdhaXQgZmV0Y2hQYWdlKGV4aXN0aW5nRGF0YSwgcGFyYW0sIG1heFBhZ2VzLCBwcmV2aW91cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgaW5pdGlhbFBhZ2VQYXJhbSA9IGluZmluaXRlUXVlcnlPcHRpb25zLmluaXRpYWxQYWdlUGFyYW1cbiAgICAgICAgICB9ID0gYXJnO1xuICAgICAgICAgIGNvbnN0IGNhY2hlZFBhZ2VQYXJhbXMgPSBjYWNoZWREYXRhPy5wYWdlUGFyYW1zID8/IFtdO1xuICAgICAgICAgIGNvbnN0IGZpcnN0UGFnZVBhcmFtID0gY2FjaGVkUGFnZVBhcmFtc1swXSA/PyBpbml0aWFsUGFnZVBhcmFtO1xuICAgICAgICAgIGNvbnN0IHRvdGFsUGFnZXMgPSBjYWNoZWRQYWdlUGFyYW1zLmxlbmd0aDtcbiAgICAgICAgICByZXN1bHQgPSBhd2FpdCBmZXRjaFBhZ2UoZXhpc3RpbmdEYXRhLCBmaXJzdFBhZ2VQYXJhbSwgbWF4UGFnZXMpO1xuICAgICAgICAgIGlmIChmb3JjZVF1ZXJ5Rm4pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgZGF0YTogcmVzdWx0LmRhdGEucGFnZXNbMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdG90YWxQYWdlczsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbSA9IGdldE5leHRQYWdlUGFyYW0oaW5maW5pdGVRdWVyeU9wdGlvbnMsIHJlc3VsdC5kYXRhLCBhcmcub3JpZ2luYWxBcmdzKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IGZldGNoUGFnZShyZXN1bHQuZGF0YSwgcGFyYW0sIG1heFBhZ2VzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxRdWVyeVJldHVyblZhbHVlID0gcmVzdWx0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmluYWxRdWVyeVJldHVyblZhbHVlID0gYXdhaXQgZXhlY3V0ZVJlcXVlc3QoYXJnLm9yaWdpbmFsQXJncyk7XG4gICAgICB9XG4gICAgICBpZiAobWV0YVNjaGVtYSAmJiAhc2hvdWxkU2tpcChza2lwU2NoZW1hVmFsaWRhdGlvbiwgXCJtZXRhXCIpICYmIGZpbmFsUXVlcnlSZXR1cm5WYWx1ZS5tZXRhKSB7XG4gICAgICAgIGZpbmFsUXVlcnlSZXR1cm5WYWx1ZS5tZXRhID0gYXdhaXQgcGFyc2VXaXRoU2NoZW1hKG1ldGFTY2hlbWEsIGZpbmFsUXVlcnlSZXR1cm5WYWx1ZS5tZXRhLCBcIm1ldGFTY2hlbWFcIiwgZmluYWxRdWVyeVJldHVyblZhbHVlLm1ldGEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bGZpbGxXaXRoVmFsdWUoZmluYWxRdWVyeVJldHVyblZhbHVlLmRhdGEsIGFkZFNob3VsZEF1dG9CYXRjaCh7XG4gICAgICAgIGZ1bGZpbGxlZFRpbWVTdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgYmFzZVF1ZXJ5TWV0YTogZmluYWxRdWVyeVJldHVyblZhbHVlLm1ldGFcbiAgICAgIH0pKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbGV0IGNhdWdodEVycm9yID0gZXJyb3I7XG4gICAgICBpZiAoY2F1Z2h0RXJyb3IgaW5zdGFuY2VvZiBIYW5kbGVkRXJyb3IpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybUVycm9yUmVzcG9uc2UgPSBnZXRUcmFuc2Zvcm1DYWxsYmFja0ZvckVuZHBvaW50KGVuZHBvaW50RGVmaW5pdGlvbiwgXCJ0cmFuc2Zvcm1FcnJvclJlc3BvbnNlXCIpO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcmF3RXJyb3JSZXNwb25zZVNjaGVtYSxcbiAgICAgICAgICBlcnJvclJlc3BvbnNlU2NoZW1hXG4gICAgICAgIH0gPSBlbmRwb2ludERlZmluaXRpb247XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgbWV0YVxuICAgICAgICB9ID0gY2F1Z2h0RXJyb3I7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHJhd0Vycm9yUmVzcG9uc2VTY2hlbWEgJiYgIXNob3VsZFNraXAoc2tpcFNjaGVtYVZhbGlkYXRpb24sIFwicmF3RXJyb3JSZXNwb25zZVwiKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBhd2FpdCBwYXJzZVdpdGhTY2hlbWEocmF3RXJyb3JSZXNwb25zZVNjaGVtYSwgdmFsdWUsIFwicmF3RXJyb3JSZXNwb25zZVNjaGVtYVwiLCBtZXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1ldGFTY2hlbWEgJiYgIXNob3VsZFNraXAoc2tpcFNjaGVtYVZhbGlkYXRpb24sIFwibWV0YVwiKSkge1xuICAgICAgICAgICAgbWV0YSA9IGF3YWl0IHBhcnNlV2l0aFNjaGVtYShtZXRhU2NoZW1hLCBtZXRhLCBcIm1ldGFTY2hlbWFcIiwgbWV0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCB0cmFuc2Zvcm1lZEVycm9yUmVzcG9uc2UgPSBhd2FpdCB0cmFuc2Zvcm1FcnJvclJlc3BvbnNlKHZhbHVlLCBtZXRhLCBhcmcub3JpZ2luYWxBcmdzKTtcbiAgICAgICAgICBpZiAoZXJyb3JSZXNwb25zZVNjaGVtYSAmJiAhc2hvdWxkU2tpcChza2lwU2NoZW1hVmFsaWRhdGlvbiwgXCJlcnJvclJlc3BvbnNlXCIpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZEVycm9yUmVzcG9uc2UgPSBhd2FpdCBwYXJzZVdpdGhTY2hlbWEoZXJyb3JSZXNwb25zZVNjaGVtYSwgdHJhbnNmb3JtZWRFcnJvclJlc3BvbnNlLCBcImVycm9yUmVzcG9uc2VTY2hlbWFcIiwgbWV0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZWplY3RXaXRoVmFsdWUodHJhbnNmb3JtZWRFcnJvclJlc3BvbnNlLCBhZGRTaG91bGRBdXRvQmF0Y2goe1xuICAgICAgICAgICAgYmFzZVF1ZXJ5TWV0YTogbWV0YVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNhdWdodEVycm9yID0gZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGNhdWdodEVycm9yIGluc3RhbmNlb2YgTmFtZWRTY2hlbWFFcnJvcikge1xuICAgICAgICAgIGNvbnN0IGluZm8gPSB7XG4gICAgICAgICAgICBlbmRwb2ludDogYXJnLmVuZHBvaW50TmFtZSxcbiAgICAgICAgICAgIGFyZzogYXJnLm9yaWdpbmFsQXJncyxcbiAgICAgICAgICAgIHR5cGU6IGFyZy50eXBlLFxuICAgICAgICAgICAgcXVlcnlDYWNoZUtleTogYXJnLnR5cGUgPT09IFwicXVlcnlcIiA/IGFyZy5xdWVyeUNhY2hlS2V5IDogdm9pZCAwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBlbmRwb2ludERlZmluaXRpb24ub25TY2hlbWFGYWlsdXJlPy4oY2F1Z2h0RXJyb3IsIGluZm8pO1xuICAgICAgICAgIG9uU2NoZW1hRmFpbHVyZT8uKGNhdWdodEVycm9yLCBpbmZvKTtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBjYXRjaFNjaGVtYUZhaWx1cmUgPSBnbG9iYWxDYXRjaFNjaGVtYUZhaWx1cmVcbiAgICAgICAgICB9ID0gZW5kcG9pbnREZWZpbml0aW9uO1xuICAgICAgICAgIGlmIChjYXRjaFNjaGVtYUZhaWx1cmUpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3RXaXRoVmFsdWUoY2F0Y2hTY2hlbWFGYWlsdXJlKGNhdWdodEVycm9yLCBpbmZvKSwgYWRkU2hvdWxkQXV0b0JhdGNoKHtcbiAgICAgICAgICAgICAgYmFzZVF1ZXJ5TWV0YTogY2F1Z2h0RXJyb3IuX2JxTWV0YVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYXVnaHRFcnJvciA9IGU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEFuIHVuaGFuZGxlZCBlcnJvciBvY2N1cnJlZCBwcm9jZXNzaW5nIGEgcmVxdWVzdCBmb3IgdGhlIGVuZHBvaW50IFwiJHthcmcuZW5kcG9pbnROYW1lfVwiLlxuSW4gdGhlIGNhc2Ugb2YgYW4gdW5oYW5kbGVkIGVycm9yLCBubyB0YWdzIHdpbGwgYmUgXCJwcm92aWRlZFwiIG9yIFwiaW52YWxpZGF0ZWRcIi5gLCBjYXVnaHRFcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKGNhdWdodEVycm9yKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGNhdWdodEVycm9yO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gaXNGb3JjZWRRdWVyeShhcmcsIHN0YXRlKSB7XG4gICAgY29uc3QgcmVxdWVzdFN0YXRlID0gc2VsZWN0b3JzLnNlbGVjdFF1ZXJ5RW50cnkoc3RhdGUsIGFyZy5xdWVyeUNhY2hlS2V5KTtcbiAgICBjb25zdCBiYXNlRmV0Y2hPbk1vdW50T3JBcmdDaGFuZ2UgPSBzZWxlY3RvcnMuc2VsZWN0Q29uZmlnKHN0YXRlKS5yZWZldGNoT25Nb3VudE9yQXJnQ2hhbmdlO1xuICAgIGNvbnN0IGZ1bGZpbGxlZFZhbCA9IHJlcXVlc3RTdGF0ZT8uZnVsZmlsbGVkVGltZVN0YW1wO1xuICAgIGNvbnN0IHJlZmV0Y2hWYWwgPSBhcmcuZm9yY2VSZWZldGNoID8/IChhcmcuc3Vic2NyaWJlICYmIGJhc2VGZXRjaE9uTW91bnRPckFyZ0NoYW5nZSk7XG4gICAgaWYgKHJlZmV0Y2hWYWwpIHtcbiAgICAgIHJldHVybiByZWZldGNoVmFsID09PSB0cnVlIHx8IChOdW1iZXIoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpIC0gTnVtYmVyKGZ1bGZpbGxlZFZhbCkpIC8gMWUzID49IHJlZmV0Y2hWYWw7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBjcmVhdGVRdWVyeVRodW5rID0gKCkgPT4ge1xuICAgIGNvbnN0IGdlbmVyYXRlZFF1ZXJ5VGh1bmsgPSBjcmVhdGVBc3luY1RodW5rKGAke3JlZHVjZXJQYXRofS9leGVjdXRlUXVlcnlgLCBleGVjdXRlRW5kcG9pbnQsIHtcbiAgICAgIGdldFBlbmRpbmdNZXRhKHtcbiAgICAgICAgYXJnXG4gICAgICB9KSB7XG4gICAgICAgIGNvbnN0IGVuZHBvaW50RGVmaW5pdGlvbiA9IGVuZHBvaW50RGVmaW5pdGlvbnNbYXJnLmVuZHBvaW50TmFtZV07XG4gICAgICAgIHJldHVybiBhZGRTaG91bGRBdXRvQmF0Y2goe1xuICAgICAgICAgIHN0YXJ0ZWRUaW1lU3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgLi4uaXNJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbihlbmRwb2ludERlZmluaXRpb24pID8ge1xuICAgICAgICAgICAgZGlyZWN0aW9uOiBhcmcuZGlyZWN0aW9uXG4gICAgICAgICAgfSA6IHt9XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGNvbmRpdGlvbihxdWVyeVRodW5rQXJnLCB7XG4gICAgICAgIGdldFN0YXRlXG4gICAgICB9KSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdFN0YXRlID0gc2VsZWN0b3JzLnNlbGVjdFF1ZXJ5RW50cnkoc3RhdGUsIHF1ZXJ5VGh1bmtBcmcucXVlcnlDYWNoZUtleSk7XG4gICAgICAgIGNvbnN0IGZ1bGZpbGxlZFZhbCA9IHJlcXVlc3RTdGF0ZT8uZnVsZmlsbGVkVGltZVN0YW1wO1xuICAgICAgICBjb25zdCBjdXJyZW50QXJnID0gcXVlcnlUaHVua0FyZy5vcmlnaW5hbEFyZ3M7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzQXJnID0gcmVxdWVzdFN0YXRlPy5vcmlnaW5hbEFyZ3M7XG4gICAgICAgIGNvbnN0IGVuZHBvaW50RGVmaW5pdGlvbiA9IGVuZHBvaW50RGVmaW5pdGlvbnNbcXVlcnlUaHVua0FyZy5lbmRwb2ludE5hbWVdO1xuICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBxdWVyeVRodW5rQXJnLmRpcmVjdGlvbjtcbiAgICAgICAgaWYgKGlzVXBzZXJ0UXVlcnkocXVlcnlUaHVua0FyZykpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxdWVzdFN0YXRlPy5zdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0ZvcmNlZFF1ZXJ5KHF1ZXJ5VGh1bmtBcmcsIHN0YXRlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1F1ZXJ5RGVmaW5pdGlvbihlbmRwb2ludERlZmluaXRpb24pICYmIGVuZHBvaW50RGVmaW5pdGlvbj8uZm9yY2VSZWZldGNoPy4oe1xuICAgICAgICAgIGN1cnJlbnRBcmcsXG4gICAgICAgICAgcHJldmlvdXNBcmcsXG4gICAgICAgICAgZW5kcG9pbnRTdGF0ZTogcmVxdWVzdFN0YXRlLFxuICAgICAgICAgIHN0YXRlXG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZ1bGZpbGxlZFZhbCAmJiAhZGlyZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcbiAgICAgIGRpc3BhdGNoQ29uZGl0aW9uUmVqZWN0aW9uOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGdlbmVyYXRlZFF1ZXJ5VGh1bms7XG4gIH07XG4gIGNvbnN0IHF1ZXJ5VGh1bmsgPSBjcmVhdGVRdWVyeVRodW5rKCk7XG4gIGNvbnN0IGluZmluaXRlUXVlcnlUaHVuayA9IGNyZWF0ZVF1ZXJ5VGh1bmsoKTtcbiAgY29uc3QgbXV0YXRpb25UaHVuayA9IGNyZWF0ZUFzeW5jVGh1bmsoYCR7cmVkdWNlclBhdGh9L2V4ZWN1dGVNdXRhdGlvbmAsIGV4ZWN1dGVFbmRwb2ludCwge1xuICAgIGdldFBlbmRpbmdNZXRhKCkge1xuICAgICAgcmV0dXJuIGFkZFNob3VsZEF1dG9CYXRjaCh7XG4gICAgICAgIHN0YXJ0ZWRUaW1lU3RhbXA6IERhdGUubm93KClcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGhhc1RoZUZvcmNlID0gKG9wdGlvbnMpID0+IFwiZm9yY2VcIiBpbiBvcHRpb25zO1xuICBjb25zdCBoYXNNYXhBZ2UgPSAob3B0aW9ucykgPT4gXCJpZk9sZGVyVGhhblwiIGluIG9wdGlvbnM7XG4gIGNvbnN0IHByZWZldGNoID0gKGVuZHBvaW50TmFtZSwgYXJnLCBvcHRpb25zID0ge30pID0+IChkaXNwYXRjaCwgZ2V0U3RhdGUpID0+IHtcbiAgICBjb25zdCBmb3JjZSA9IGhhc1RoZUZvcmNlKG9wdGlvbnMpICYmIG9wdGlvbnMuZm9yY2U7XG4gICAgY29uc3QgbWF4QWdlID0gaGFzTWF4QWdlKG9wdGlvbnMpICYmIG9wdGlvbnMuaWZPbGRlclRoYW47XG4gICAgY29uc3QgcXVlcnlBY3Rpb24gPSAoZm9yY2UyID0gdHJ1ZSkgPT4ge1xuICAgICAgY29uc3Qgb3B0aW9uczIgPSB7XG4gICAgICAgIGZvcmNlUmVmZXRjaDogZm9yY2UyLFxuICAgICAgICBzdWJzY3JpYmU6IGZhbHNlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXS5pbml0aWF0ZShhcmcsIG9wdGlvbnMyKTtcbiAgICB9O1xuICAgIGNvbnN0IGxhdGVzdFN0YXRlVmFsdWUgPSBhcGkuZW5kcG9pbnRzW2VuZHBvaW50TmFtZV0uc2VsZWN0KGFyZykoZ2V0U3RhdGUoKSk7XG4gICAgaWYgKGZvcmNlKSB7XG4gICAgICBkaXNwYXRjaChxdWVyeUFjdGlvbigpKTtcbiAgICB9IGVsc2UgaWYgKG1heEFnZSkge1xuICAgICAgY29uc3QgbGFzdEZ1bGZpbGxlZFRzID0gbGF0ZXN0U3RhdGVWYWx1ZT8uZnVsZmlsbGVkVGltZVN0YW1wO1xuICAgICAgaWYgKCFsYXN0RnVsZmlsbGVkVHMpIHtcbiAgICAgICAgZGlzcGF0Y2gocXVlcnlBY3Rpb24oKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNob3VsZFJldHJpZ2dlciA9IChOdW1iZXIoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpIC0gTnVtYmVyKG5ldyBEYXRlKGxhc3RGdWxmaWxsZWRUcykpKSAvIDFlMyA+PSBtYXhBZ2U7XG4gICAgICBpZiAoc2hvdWxkUmV0cmlnZ2VyKSB7XG4gICAgICAgIGRpc3BhdGNoKHF1ZXJ5QWN0aW9uKCkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkaXNwYXRjaChxdWVyeUFjdGlvbihmYWxzZSkpO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gbWF0Y2hlc0VuZHBvaW50KGVuZHBvaW50TmFtZSkge1xuICAgIHJldHVybiAoYWN0aW9uKSA9PiBhY3Rpb24/Lm1ldGE/LmFyZz8uZW5kcG9pbnROYW1lID09PSBlbmRwb2ludE5hbWU7XG4gIH1cbiAgZnVuY3Rpb24gYnVpbGRNYXRjaFRodW5rQWN0aW9ucyh0aHVuaywgZW5kcG9pbnROYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hdGNoUGVuZGluZzogaXNBbGxPZihpc1BlbmRpbmcodGh1bmspLCBtYXRjaGVzRW5kcG9pbnQoZW5kcG9pbnROYW1lKSksXG4gICAgICBtYXRjaEZ1bGZpbGxlZDogaXNBbGxPZihpc0Z1bGZpbGxlZCh0aHVuayksIG1hdGNoZXNFbmRwb2ludChlbmRwb2ludE5hbWUpKSxcbiAgICAgIG1hdGNoUmVqZWN0ZWQ6IGlzQWxsT2YoaXNSZWplY3RlZCh0aHVuayksIG1hdGNoZXNFbmRwb2ludChlbmRwb2ludE5hbWUpKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBxdWVyeVRodW5rLFxuICAgIG11dGF0aW9uVGh1bmssXG4gICAgaW5maW5pdGVRdWVyeVRodW5rLFxuICAgIHByZWZldGNoLFxuICAgIHVwZGF0ZVF1ZXJ5RGF0YSxcbiAgICB1cHNlcnRRdWVyeURhdGEsXG4gICAgcGF0Y2hRdWVyeURhdGEsXG4gICAgYnVpbGRNYXRjaFRodW5rQWN0aW9uc1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0TmV4dFBhZ2VQYXJhbShvcHRpb25zLCB7XG4gIHBhZ2VzLFxuICBwYWdlUGFyYW1zXG59LCBxdWVyeUFyZykge1xuICBjb25zdCBsYXN0SW5kZXggPSBwYWdlcy5sZW5ndGggLSAxO1xuICByZXR1cm4gb3B0aW9ucy5nZXROZXh0UGFnZVBhcmFtKHBhZ2VzW2xhc3RJbmRleF0sIHBhZ2VzLCBwYWdlUGFyYW1zW2xhc3RJbmRleF0sIHBhZ2VQYXJhbXMsIHF1ZXJ5QXJnKTtcbn1cbmZ1bmN0aW9uIGdldFByZXZpb3VzUGFnZVBhcmFtKG9wdGlvbnMsIHtcbiAgcGFnZXMsXG4gIHBhZ2VQYXJhbXNcbn0sIHF1ZXJ5QXJnKSB7XG4gIHJldHVybiBvcHRpb25zLmdldFByZXZpb3VzUGFnZVBhcmFtPy4ocGFnZXNbMF0sIHBhZ2VzLCBwYWdlUGFyYW1zWzBdLCBwYWdlUGFyYW1zLCBxdWVyeUFyZyk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVQcm92aWRlZEJ5VGh1bmsoYWN0aW9uLCB0eXBlLCBlbmRwb2ludERlZmluaXRpb25zLCBhc3NlcnRUYWdUeXBlKSB7XG4gIHJldHVybiBjYWxjdWxhdGVQcm92aWRlZEJ5KGVuZHBvaW50RGVmaW5pdGlvbnNbYWN0aW9uLm1ldGEuYXJnLmVuZHBvaW50TmFtZV1bdHlwZV0sIGlzRnVsZmlsbGVkKGFjdGlvbikgPyBhY3Rpb24ucGF5bG9hZCA6IHZvaWQgMCwgaXNSZWplY3RlZFdpdGhWYWx1ZShhY3Rpb24pID8gYWN0aW9uLnBheWxvYWQgOiB2b2lkIDAsIGFjdGlvbi5tZXRhLmFyZy5vcmlnaW5hbEFyZ3MsIFwiYmFzZVF1ZXJ5TWV0YVwiIGluIGFjdGlvbi5tZXRhID8gYWN0aW9uLm1ldGEuYmFzZVF1ZXJ5TWV0YSA6IHZvaWQgMCwgYXNzZXJ0VGFnVHlwZSk7XG59XG5cbi8vIHNyYy9xdWVyeS9jb3JlL2J1aWxkU2xpY2UudHNcbmltcG9ydCB7IGlzRHJhZnQgfSBmcm9tIFwiaW1tZXJcIjtcbmltcG9ydCB7IGFwcGx5UGF0Y2hlcywgb3JpZ2luYWwgfSBmcm9tIFwiaW1tZXJcIjtcbmZ1bmN0aW9uIHVwZGF0ZVF1ZXJ5U3Vic3RhdGVJZkV4aXN0cyhzdGF0ZSwgcXVlcnlDYWNoZUtleSwgdXBkYXRlKSB7XG4gIGNvbnN0IHN1YnN0YXRlID0gc3RhdGVbcXVlcnlDYWNoZUtleV07XG4gIGlmIChzdWJzdGF0ZSkge1xuICAgIHVwZGF0ZShzdWJzdGF0ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldE11dGF0aW9uQ2FjaGVLZXkoaWQpIHtcbiAgcmV0dXJuIChcImFyZ1wiIGluIGlkID8gaWQuYXJnLmZpeGVkQ2FjaGVLZXkgOiBpZC5maXhlZENhY2hlS2V5KSA/PyBpZC5yZXF1ZXN0SWQ7XG59XG5mdW5jdGlvbiB1cGRhdGVNdXRhdGlvblN1YnN0YXRlSWZFeGlzdHMoc3RhdGUsIGlkLCB1cGRhdGUpIHtcbiAgY29uc3Qgc3Vic3RhdGUgPSBzdGF0ZVtnZXRNdXRhdGlvbkNhY2hlS2V5KGlkKV07XG4gIGlmIChzdWJzdGF0ZSkge1xuICAgIHVwZGF0ZShzdWJzdGF0ZSk7XG4gIH1cbn1cbnZhciBpbml0aWFsU3RhdGUgPSB7fTtcbmZ1bmN0aW9uIGJ1aWxkU2xpY2Uoe1xuICByZWR1Y2VyUGF0aCxcbiAgcXVlcnlUaHVuayxcbiAgbXV0YXRpb25UaHVuayxcbiAgc2VyaWFsaXplUXVlcnlBcmdzLFxuICBjb250ZXh0OiB7XG4gICAgZW5kcG9pbnREZWZpbml0aW9uczogZGVmaW5pdGlvbnMsXG4gICAgYXBpVWlkLFxuICAgIGV4dHJhY3RSZWh5ZHJhdGlvbkluZm8sXG4gICAgaGFzUmVoeWRyYXRpb25JbmZvXG4gIH0sXG4gIGFzc2VydFRhZ1R5cGUsXG4gIGNvbmZpZ1xufSkge1xuICBjb25zdCByZXNldEFwaVN0YXRlID0gY3JlYXRlQWN0aW9uKGAke3JlZHVjZXJQYXRofS9yZXNldEFwaVN0YXRlYCk7XG4gIGZ1bmN0aW9uIHdyaXRlUGVuZGluZ0NhY2hlRW50cnkoZHJhZnQsIGFyZywgdXBzZXJ0aW5nLCBtZXRhKSB7XG4gICAgZHJhZnRbYXJnLnF1ZXJ5Q2FjaGVLZXldID8/PSB7XG4gICAgICBzdGF0dXM6IFwidW5pbml0aWFsaXplZFwiIC8qIHVuaW5pdGlhbGl6ZWQgKi8sXG4gICAgICBlbmRwb2ludE5hbWU6IGFyZy5lbmRwb2ludE5hbWVcbiAgICB9O1xuICAgIHVwZGF0ZVF1ZXJ5U3Vic3RhdGVJZkV4aXN0cyhkcmFmdCwgYXJnLnF1ZXJ5Q2FjaGVLZXksIChzdWJzdGF0ZSkgPT4ge1xuICAgICAgc3Vic3RhdGUuc3RhdHVzID0gXCJwZW5kaW5nXCIgLyogcGVuZGluZyAqLztcbiAgICAgIHN1YnN0YXRlLnJlcXVlc3RJZCA9IHVwc2VydGluZyAmJiBzdWJzdGF0ZS5yZXF1ZXN0SWQgPyAoXG4gICAgICAgIC8vIGZvciBgdXBzZXJ0UXVlcnlgICoqdXBkYXRlcyoqLCBrZWVwIHRoZSBjdXJyZW50IGByZXF1ZXN0SWRgXG4gICAgICAgIHN1YnN0YXRlLnJlcXVlc3RJZFxuICAgICAgKSA6IChcbiAgICAgICAgLy8gZm9yIG5vcm1hbCBxdWVyaWVzIG9yIGB1cHNlcnRRdWVyeWAgKippbnNlcnRzKiogYWx3YXlzIHVwZGF0ZSB0aGUgYHJlcXVlc3RJZGBcbiAgICAgICAgbWV0YS5yZXF1ZXN0SWRcbiAgICAgICk7XG4gICAgICBpZiAoYXJnLm9yaWdpbmFsQXJncyAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHN1YnN0YXRlLm9yaWdpbmFsQXJncyA9IGFyZy5vcmlnaW5hbEFyZ3M7XG4gICAgICB9XG4gICAgICBzdWJzdGF0ZS5zdGFydGVkVGltZVN0YW1wID0gbWV0YS5zdGFydGVkVGltZVN0YW1wO1xuICAgICAgY29uc3QgZW5kcG9pbnREZWZpbml0aW9uID0gZGVmaW5pdGlvbnNbbWV0YS5hcmcuZW5kcG9pbnROYW1lXTtcbiAgICAgIGlmIChpc0luZmluaXRlUXVlcnlEZWZpbml0aW9uKGVuZHBvaW50RGVmaW5pdGlvbikgJiYgXCJkaXJlY3Rpb25cIiBpbiBhcmcpIHtcbiAgICAgICAgO1xuICAgICAgICBzdWJzdGF0ZS5kaXJlY3Rpb24gPSBhcmcuZGlyZWN0aW9uO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHdyaXRlRnVsZmlsbGVkQ2FjaGVFbnRyeShkcmFmdCwgbWV0YSwgcGF5bG9hZCwgdXBzZXJ0aW5nKSB7XG4gICAgdXBkYXRlUXVlcnlTdWJzdGF0ZUlmRXhpc3RzKGRyYWZ0LCBtZXRhLmFyZy5xdWVyeUNhY2hlS2V5LCAoc3Vic3RhdGUpID0+IHtcbiAgICAgIGlmIChzdWJzdGF0ZS5yZXF1ZXN0SWQgIT09IG1ldGEucmVxdWVzdElkICYmICF1cHNlcnRpbmcpIHJldHVybjtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWVyZ2VcbiAgICAgIH0gPSBkZWZpbml0aW9uc1ttZXRhLmFyZy5lbmRwb2ludE5hbWVdO1xuICAgICAgc3Vic3RhdGUuc3RhdHVzID0gXCJmdWxmaWxsZWRcIiAvKiBmdWxmaWxsZWQgKi87XG4gICAgICBpZiAobWVyZ2UpIHtcbiAgICAgICAgaWYgKHN1YnN0YXRlLmRhdGEgIT09IHZvaWQgMCkge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGZ1bGZpbGxlZFRpbWVTdGFtcCxcbiAgICAgICAgICAgIGFyZyxcbiAgICAgICAgICAgIGJhc2VRdWVyeU1ldGEsXG4gICAgICAgICAgICByZXF1ZXN0SWRcbiAgICAgICAgICB9ID0gbWV0YTtcbiAgICAgICAgICBsZXQgbmV3RGF0YSA9IGNyZWF0ZU5leHRTdGF0ZShzdWJzdGF0ZS5kYXRhLCAoZHJhZnRTdWJzdGF0ZURhdGEpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBtZXJnZShkcmFmdFN1YnN0YXRlRGF0YSwgcGF5bG9hZCwge1xuICAgICAgICAgICAgICBhcmc6IGFyZy5vcmlnaW5hbEFyZ3MsXG4gICAgICAgICAgICAgIGJhc2VRdWVyeU1ldGEsXG4gICAgICAgICAgICAgIGZ1bGZpbGxlZFRpbWVTdGFtcCxcbiAgICAgICAgICAgICAgcmVxdWVzdElkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdWJzdGF0ZS5kYXRhID0gbmV3RGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdWJzdGF0ZS5kYXRhID0gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3Vic3RhdGUuZGF0YSA9IGRlZmluaXRpb25zW21ldGEuYXJnLmVuZHBvaW50TmFtZV0uc3RydWN0dXJhbFNoYXJpbmcgPz8gdHJ1ZSA/IGNvcHlXaXRoU3RydWN0dXJhbFNoYXJpbmcoaXNEcmFmdChzdWJzdGF0ZS5kYXRhKSA/IG9yaWdpbmFsKHN1YnN0YXRlLmRhdGEpIDogc3Vic3RhdGUuZGF0YSwgcGF5bG9hZCkgOiBwYXlsb2FkO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHN1YnN0YXRlLmVycm9yO1xuICAgICAgc3Vic3RhdGUuZnVsZmlsbGVkVGltZVN0YW1wID0gbWV0YS5mdWxmaWxsZWRUaW1lU3RhbXA7XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgcXVlcnlTbGljZSA9IGNyZWF0ZVNsaWNlKHtcbiAgICBuYW1lOiBgJHtyZWR1Y2VyUGF0aH0vcXVlcmllc2AsXG4gICAgaW5pdGlhbFN0YXRlLFxuICAgIHJlZHVjZXJzOiB7XG4gICAgICByZW1vdmVRdWVyeVJlc3VsdDoge1xuICAgICAgICByZWR1Y2VyKGRyYWZ0LCB7XG4gICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgcXVlcnlDYWNoZUtleVxuICAgICAgICAgIH1cbiAgICAgICAgfSkge1xuICAgICAgICAgIGRlbGV0ZSBkcmFmdFtxdWVyeUNhY2hlS2V5XTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJlcGFyZTogcHJlcGFyZUF1dG9CYXRjaGVkKClcbiAgICAgIH0sXG4gICAgICBjYWNoZUVudHJpZXNVcHNlcnRlZDoge1xuICAgICAgICByZWR1Y2VyKGRyYWZ0LCBhY3Rpb24pIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGFjdGlvbi5wYXlsb2FkKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIHF1ZXJ5RGVzY3JpcHRpb246IGFyZyxcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH0gPSBlbnRyeTtcbiAgICAgICAgICAgIHdyaXRlUGVuZGluZ0NhY2hlRW50cnkoZHJhZnQsIGFyZywgdHJ1ZSwge1xuICAgICAgICAgICAgICBhcmcsXG4gICAgICAgICAgICAgIHJlcXVlc3RJZDogYWN0aW9uLm1ldGEucmVxdWVzdElkLFxuICAgICAgICAgICAgICBzdGFydGVkVGltZVN0YW1wOiBhY3Rpb24ubWV0YS50aW1lc3RhbXBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgd3JpdGVGdWxmaWxsZWRDYWNoZUVudHJ5KFxuICAgICAgICAgICAgICBkcmFmdCxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGFyZyxcbiAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IGFjdGlvbi5tZXRhLnJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgICBmdWxmaWxsZWRUaW1lU3RhbXA6IGFjdGlvbi5tZXRhLnRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICBiYXNlUXVlcnlNZXRhOiB7fVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgLy8gV2Uga25vdyB3ZSdyZSB1cHNlcnRpbmcgaGVyZVxuICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcHJlcGFyZTogKHBheWxvYWQpID0+IHtcbiAgICAgICAgICBjb25zdCBxdWVyeURlc2NyaXB0aW9ucyA9IHBheWxvYWQubWFwKChlbnRyeSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBlbmRwb2ludE5hbWUsXG4gICAgICAgICAgICAgIGFyZyxcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH0gPSBlbnRyeTtcbiAgICAgICAgICAgIGNvbnN0IGVuZHBvaW50RGVmaW5pdGlvbiA9IGRlZmluaXRpb25zW2VuZHBvaW50TmFtZV07XG4gICAgICAgICAgICBjb25zdCBxdWVyeURlc2NyaXB0aW9uID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcInF1ZXJ5XCIsXG4gICAgICAgICAgICAgIGVuZHBvaW50TmFtZSxcbiAgICAgICAgICAgICAgb3JpZ2luYWxBcmdzOiBlbnRyeS5hcmcsXG4gICAgICAgICAgICAgIHF1ZXJ5Q2FjaGVLZXk6IHNlcmlhbGl6ZVF1ZXJ5QXJncyh7XG4gICAgICAgICAgICAgICAgcXVlcnlBcmdzOiBhcmcsXG4gICAgICAgICAgICAgICAgZW5kcG9pbnREZWZpbml0aW9uLFxuICAgICAgICAgICAgICAgIGVuZHBvaW50TmFtZVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHF1ZXJ5RGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIHBheWxvYWQ6IHF1ZXJ5RGVzY3JpcHRpb25zLFxuICAgICAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgICBbU0hPVUxEX0FVVE9CQVRDSF06IHRydWUsXG4gICAgICAgICAgICAgIHJlcXVlc3RJZDogbmFub2lkKCksXG4gICAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHF1ZXJ5UmVzdWx0UGF0Y2hlZDoge1xuICAgICAgICByZWR1Y2VyKGRyYWZ0LCB7XG4gICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgcXVlcnlDYWNoZUtleSxcbiAgICAgICAgICAgIHBhdGNoZXNcbiAgICAgICAgICB9XG4gICAgICAgIH0pIHtcbiAgICAgICAgICB1cGRhdGVRdWVyeVN1YnN0YXRlSWZFeGlzdHMoZHJhZnQsIHF1ZXJ5Q2FjaGVLZXksIChzdWJzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgc3Vic3RhdGUuZGF0YSA9IGFwcGx5UGF0Y2hlcyhzdWJzdGF0ZS5kYXRhLCBwYXRjaGVzLmNvbmNhdCgpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJlcGFyZTogcHJlcGFyZUF1dG9CYXRjaGVkKClcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4dHJhUmVkdWNlcnMoYnVpbGRlcikge1xuICAgICAgYnVpbGRlci5hZGRDYXNlKHF1ZXJ5VGh1bmsucGVuZGluZywgKGRyYWZ0LCB7XG4gICAgICAgIG1ldGEsXG4gICAgICAgIG1ldGE6IHtcbiAgICAgICAgICBhcmdcbiAgICAgICAgfVxuICAgICAgfSkgPT4ge1xuICAgICAgICBjb25zdCB1cHNlcnRpbmcgPSBpc1Vwc2VydFF1ZXJ5KGFyZyk7XG4gICAgICAgIHdyaXRlUGVuZGluZ0NhY2hlRW50cnkoZHJhZnQsIGFyZywgdXBzZXJ0aW5nLCBtZXRhKTtcbiAgICAgIH0pLmFkZENhc2UocXVlcnlUaHVuay5mdWxmaWxsZWQsIChkcmFmdCwge1xuICAgICAgICBtZXRhLFxuICAgICAgICBwYXlsb2FkXG4gICAgICB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHVwc2VydGluZyA9IGlzVXBzZXJ0UXVlcnkobWV0YS5hcmcpO1xuICAgICAgICB3cml0ZUZ1bGZpbGxlZENhY2hlRW50cnkoZHJhZnQsIG1ldGEsIHBheWxvYWQsIHVwc2VydGluZyk7XG4gICAgICB9KS5hZGRDYXNlKHF1ZXJ5VGh1bmsucmVqZWN0ZWQsIChkcmFmdCwge1xuICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgY29uZGl0aW9uLFxuICAgICAgICAgIGFyZyxcbiAgICAgICAgICByZXF1ZXN0SWRcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIHBheWxvYWRcbiAgICAgIH0pID0+IHtcbiAgICAgICAgdXBkYXRlUXVlcnlTdWJzdGF0ZUlmRXhpc3RzKGRyYWZ0LCBhcmcucXVlcnlDYWNoZUtleSwgKHN1YnN0YXRlKSA9PiB7XG4gICAgICAgICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3Vic3RhdGUucmVxdWVzdElkICE9PSByZXF1ZXN0SWQpIHJldHVybjtcbiAgICAgICAgICAgIHN1YnN0YXRlLnN0YXR1cyA9IFwicmVqZWN0ZWRcIiAvKiByZWplY3RlZCAqLztcbiAgICAgICAgICAgIHN1YnN0YXRlLmVycm9yID0gcGF5bG9hZCA/PyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSkuYWRkTWF0Y2hlcihoYXNSZWh5ZHJhdGlvbkluZm8sIChkcmFmdCwgYWN0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBxdWVyaWVzXG4gICAgICAgIH0gPSBleHRyYWN0UmVoeWRyYXRpb25JbmZvKGFjdGlvbik7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgZW50cnldIG9mIE9iamVjdC5lbnRyaWVzKHF1ZXJpZXMpKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gZG8gbm90IHJlaHlkcmF0ZSBlbnRyaWVzIHRoYXQgd2VyZSBjdXJyZW50bHkgaW4gZmxpZ2h0LlxuICAgICAgICAgICAgZW50cnk/LnN0YXR1cyA9PT0gXCJmdWxmaWxsZWRcIiAvKiBmdWxmaWxsZWQgKi8gfHwgZW50cnk/LnN0YXR1cyA9PT0gXCJyZWplY3RlZFwiIC8qIHJlamVjdGVkICovXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBkcmFmdFtrZXldID0gZW50cnk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBtdXRhdGlvblNsaWNlID0gY3JlYXRlU2xpY2Uoe1xuICAgIG5hbWU6IGAke3JlZHVjZXJQYXRofS9tdXRhdGlvbnNgLFxuICAgIGluaXRpYWxTdGF0ZSxcbiAgICByZWR1Y2Vyczoge1xuICAgICAgcmVtb3ZlTXV0YXRpb25SZXN1bHQ6IHtcbiAgICAgICAgcmVkdWNlcihkcmFmdCwge1xuICAgICAgICAgIHBheWxvYWRcbiAgICAgICAgfSkge1xuICAgICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gZ2V0TXV0YXRpb25DYWNoZUtleShwYXlsb2FkKTtcbiAgICAgICAgICBpZiAoY2FjaGVLZXkgaW4gZHJhZnQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBkcmFmdFtjYWNoZUtleV07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwcmVwYXJlOiBwcmVwYXJlQXV0b0JhdGNoZWQoKVxuICAgICAgfVxuICAgIH0sXG4gICAgZXh0cmFSZWR1Y2VycyhidWlsZGVyKSB7XG4gICAgICBidWlsZGVyLmFkZENhc2UobXV0YXRpb25UaHVuay5wZW5kaW5nLCAoZHJhZnQsIHtcbiAgICAgICAgbWV0YSxcbiAgICAgICAgbWV0YToge1xuICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICBhcmcsXG4gICAgICAgICAgc3RhcnRlZFRpbWVTdGFtcFxuICAgICAgICB9XG4gICAgICB9KSA9PiB7XG4gICAgICAgIGlmICghYXJnLnRyYWNrKSByZXR1cm47XG4gICAgICAgIGRyYWZ0W2dldE11dGF0aW9uQ2FjaGVLZXkobWV0YSldID0ge1xuICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICBzdGF0dXM6IFwicGVuZGluZ1wiIC8qIHBlbmRpbmcgKi8sXG4gICAgICAgICAgZW5kcG9pbnROYW1lOiBhcmcuZW5kcG9pbnROYW1lLFxuICAgICAgICAgIHN0YXJ0ZWRUaW1lU3RhbXBcbiAgICAgICAgfTtcbiAgICAgIH0pLmFkZENhc2UobXV0YXRpb25UaHVuay5mdWxmaWxsZWQsIChkcmFmdCwge1xuICAgICAgICBwYXlsb2FkLFxuICAgICAgICBtZXRhXG4gICAgICB9KSA9PiB7XG4gICAgICAgIGlmICghbWV0YS5hcmcudHJhY2spIHJldHVybjtcbiAgICAgICAgdXBkYXRlTXV0YXRpb25TdWJzdGF0ZUlmRXhpc3RzKGRyYWZ0LCBtZXRhLCAoc3Vic3RhdGUpID0+IHtcbiAgICAgICAgICBpZiAoc3Vic3RhdGUucmVxdWVzdElkICE9PSBtZXRhLnJlcXVlc3RJZCkgcmV0dXJuO1xuICAgICAgICAgIHN1YnN0YXRlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCIgLyogZnVsZmlsbGVkICovO1xuICAgICAgICAgIHN1YnN0YXRlLmRhdGEgPSBwYXlsb2FkO1xuICAgICAgICAgIHN1YnN0YXRlLmZ1bGZpbGxlZFRpbWVTdGFtcCA9IG1ldGEuZnVsZmlsbGVkVGltZVN0YW1wO1xuICAgICAgICB9KTtcbiAgICAgIH0pLmFkZENhc2UobXV0YXRpb25UaHVuay5yZWplY3RlZCwgKGRyYWZ0LCB7XG4gICAgICAgIHBheWxvYWQsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBtZXRhXG4gICAgICB9KSA9PiB7XG4gICAgICAgIGlmICghbWV0YS5hcmcudHJhY2spIHJldHVybjtcbiAgICAgICAgdXBkYXRlTXV0YXRpb25TdWJzdGF0ZUlmRXhpc3RzKGRyYWZ0LCBtZXRhLCAoc3Vic3RhdGUpID0+IHtcbiAgICAgICAgICBpZiAoc3Vic3RhdGUucmVxdWVzdElkICE9PSBtZXRhLnJlcXVlc3RJZCkgcmV0dXJuO1xuICAgICAgICAgIHN1YnN0YXRlLnN0YXR1cyA9IFwicmVqZWN0ZWRcIiAvKiByZWplY3RlZCAqLztcbiAgICAgICAgICBzdWJzdGF0ZS5lcnJvciA9IHBheWxvYWQgPz8gZXJyb3I7XG4gICAgICAgIH0pO1xuICAgICAgfSkuYWRkTWF0Y2hlcihoYXNSZWh5ZHJhdGlvbkluZm8sIChkcmFmdCwgYWN0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBtdXRhdGlvbnNcbiAgICAgICAgfSA9IGV4dHJhY3RSZWh5ZHJhdGlvbkluZm8oYWN0aW9uKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBlbnRyeV0gb2YgT2JqZWN0LmVudHJpZXMobXV0YXRpb25zKSkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIGRvIG5vdCByZWh5ZHJhdGUgZW50cmllcyB0aGF0IHdlcmUgY3VycmVudGx5IGluIGZsaWdodC5cbiAgICAgICAgICAgIChlbnRyeT8uc3RhdHVzID09PSBcImZ1bGZpbGxlZFwiIC8qIGZ1bGZpbGxlZCAqLyB8fCBlbnRyeT8uc3RhdHVzID09PSBcInJlamVjdGVkXCIgLyogcmVqZWN0ZWQgKi8pICYmIC8vIG9ubHkgcmVoeWRyYXRlIGVuZHBvaW50cyB0aGF0IHdlcmUgcGVyc2lzdGVkIHVzaW5nIGEgYGZpeGVkQ2FjaGVLZXlgXG4gICAgICAgICAgICBrZXkgIT09IGVudHJ5Py5yZXF1ZXN0SWRcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGRyYWZ0W2tleV0gPSBlbnRyeTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGluaXRpYWxJbnZhbGlkYXRpb25TdGF0ZSA9IHtcbiAgICB0YWdzOiB7fSxcbiAgICBrZXlzOiB7fVxuICB9O1xuICBjb25zdCBpbnZhbGlkYXRpb25TbGljZSA9IGNyZWF0ZVNsaWNlKHtcbiAgICBuYW1lOiBgJHtyZWR1Y2VyUGF0aH0vaW52YWxpZGF0aW9uYCxcbiAgICBpbml0aWFsU3RhdGU6IGluaXRpYWxJbnZhbGlkYXRpb25TdGF0ZSxcbiAgICByZWR1Y2Vyczoge1xuICAgICAgdXBkYXRlUHJvdmlkZWRCeToge1xuICAgICAgICByZWR1Y2VyKGRyYWZ0LCBhY3Rpb24pIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgICAgIHF1ZXJ5Q2FjaGVLZXksXG4gICAgICAgICAgICBwcm92aWRlZFRhZ3NcbiAgICAgICAgICB9IG9mIGFjdGlvbi5wYXlsb2FkKSB7XG4gICAgICAgICAgICByZW1vdmVDYWNoZUtleUZyb21UYWdzKGRyYWZ0LCBxdWVyeUNhY2hlS2V5KTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qge1xuICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICBpZFxuICAgICAgICAgICAgfSBvZiBwcm92aWRlZFRhZ3MpIHtcbiAgICAgICAgICAgICAgY29uc3Qgc3Vic2NyaWJlZFF1ZXJpZXMgPSAoZHJhZnQudGFnc1t0eXBlXSA/Pz0ge30pW2lkIHx8IFwiX19pbnRlcm5hbF93aXRob3V0X2lkXCJdID8/PSBbXTtcbiAgICAgICAgICAgICAgY29uc3QgYWxyZWFkeVN1YnNjcmliZWQgPSBzdWJzY3JpYmVkUXVlcmllcy5pbmNsdWRlcyhxdWVyeUNhY2hlS2V5KTtcbiAgICAgICAgICAgICAgaWYgKCFhbHJlYWR5U3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZWRRdWVyaWVzLnB1c2gocXVlcnlDYWNoZUtleSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRyYWZ0LmtleXNbcXVlcnlDYWNoZUtleV0gPSBwcm92aWRlZFRhZ3M7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwcmVwYXJlOiBwcmVwYXJlQXV0b0JhdGNoZWQoKVxuICAgICAgfVxuICAgIH0sXG4gICAgZXh0cmFSZWR1Y2VycyhidWlsZGVyKSB7XG4gICAgICBidWlsZGVyLmFkZENhc2UocXVlcnlTbGljZS5hY3Rpb25zLnJlbW92ZVF1ZXJ5UmVzdWx0LCAoZHJhZnQsIHtcbiAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgIHF1ZXJ5Q2FjaGVLZXlcbiAgICAgICAgfVxuICAgICAgfSkgPT4ge1xuICAgICAgICByZW1vdmVDYWNoZUtleUZyb21UYWdzKGRyYWZ0LCBxdWVyeUNhY2hlS2V5KTtcbiAgICAgIH0pLmFkZE1hdGNoZXIoaGFzUmVoeWRyYXRpb25JbmZvLCAoZHJhZnQsIGFjdGlvbikgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcHJvdmlkZWRcbiAgICAgICAgfSA9IGV4dHJhY3RSZWh5ZHJhdGlvbkluZm8oYWN0aW9uKTtcbiAgICAgICAgZm9yIChjb25zdCBbdHlwZSwgaW5jb21pbmdUYWdzXSBvZiBPYmplY3QuZW50cmllcyhwcm92aWRlZC50YWdzID8/IHt9KSkge1xuICAgICAgICAgIGZvciAoY29uc3QgW2lkLCBjYWNoZUtleXNdIG9mIE9iamVjdC5lbnRyaWVzKGluY29taW5nVGFncykpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YnNjcmliZWRRdWVyaWVzID0gKGRyYWZ0LnRhZ3NbdHlwZV0gPz89IHt9KVtpZCB8fCBcIl9faW50ZXJuYWxfd2l0aG91dF9pZFwiXSA/Pz0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHF1ZXJ5Q2FjaGVLZXkgb2YgY2FjaGVLZXlzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGFscmVhZHlTdWJzY3JpYmVkID0gc3Vic2NyaWJlZFF1ZXJpZXMuaW5jbHVkZXMocXVlcnlDYWNoZUtleSk7XG4gICAgICAgICAgICAgIGlmICghYWxyZWFkeVN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVkUXVlcmllcy5wdXNoKHF1ZXJ5Q2FjaGVLZXkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRyYWZ0LmtleXNbcXVlcnlDYWNoZUtleV0gPSBwcm92aWRlZC5rZXlzW3F1ZXJ5Q2FjaGVLZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSkuYWRkTWF0Y2hlcihpc0FueU9mKGlzRnVsZmlsbGVkKHF1ZXJ5VGh1bmspLCBpc1JlamVjdGVkV2l0aFZhbHVlKHF1ZXJ5VGh1bmspKSwgKGRyYWZ0LCBhY3Rpb24pID0+IHtcbiAgICAgICAgd3JpdGVQcm92aWRlZFRhZ3NGb3JRdWVyaWVzKGRyYWZ0LCBbYWN0aW9uXSk7XG4gICAgICB9KS5hZGRNYXRjaGVyKHF1ZXJ5U2xpY2UuYWN0aW9ucy5jYWNoZUVudHJpZXNVcHNlcnRlZC5tYXRjaCwgKGRyYWZ0LCBhY3Rpb24pID0+IHtcbiAgICAgICAgY29uc3QgbW9ja0FjdGlvbnMgPSBhY3Rpb24ucGF5bG9hZC5tYXAoKHtcbiAgICAgICAgICBxdWVyeURlc2NyaXB0aW9uLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0pID0+IHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJVTktOT1dOXCIsXG4gICAgICAgICAgICBwYXlsb2FkOiB2YWx1ZSxcbiAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgcmVxdWVzdFN0YXR1czogXCJmdWxmaWxsZWRcIixcbiAgICAgICAgICAgICAgcmVxdWVzdElkOiBcIlVOS05PV05cIixcbiAgICAgICAgICAgICAgYXJnOiBxdWVyeURlc2NyaXB0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHdyaXRlUHJvdmlkZWRUYWdzRm9yUXVlcmllcyhkcmFmdCwgbW9ja0FjdGlvbnMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgZnVuY3Rpb24gcmVtb3ZlQ2FjaGVLZXlGcm9tVGFncyhkcmFmdCwgcXVlcnlDYWNoZUtleSkge1xuICAgIGNvbnN0IGV4aXN0aW5nVGFncyA9IGRyYWZ0LmtleXNbcXVlcnlDYWNoZUtleV0gPz8gW107XG4gICAgZm9yIChjb25zdCB0YWcgb2YgZXhpc3RpbmdUYWdzKSB7XG4gICAgICBjb25zdCB0YWdUeXBlID0gdGFnLnR5cGU7XG4gICAgICBjb25zdCB0YWdJZCA9IHRhZy5pZCA/PyBcIl9faW50ZXJuYWxfd2l0aG91dF9pZFwiO1xuICAgICAgY29uc3QgdGFnU3Vic2NyaXB0aW9ucyA9IGRyYWZ0LnRhZ3NbdGFnVHlwZV0/Llt0YWdJZF07XG4gICAgICBpZiAodGFnU3Vic2NyaXB0aW9ucykge1xuICAgICAgICBkcmFmdC50YWdzW3RhZ1R5cGVdW3RhZ0lkXSA9IHRhZ1N1YnNjcmlwdGlvbnMuZmlsdGVyKChxYykgPT4gcWMgIT09IHF1ZXJ5Q2FjaGVLZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBkZWxldGUgZHJhZnQua2V5c1txdWVyeUNhY2hlS2V5XTtcbiAgfVxuICBmdW5jdGlvbiB3cml0ZVByb3ZpZGVkVGFnc0ZvclF1ZXJpZXMoZHJhZnQsIGFjdGlvbnMyKSB7XG4gICAgY29uc3QgcHJvdmlkZWRCeUVudHJpZXMgPSBhY3Rpb25zMi5tYXAoKGFjdGlvbikgPT4ge1xuICAgICAgY29uc3QgcHJvdmlkZWRUYWdzID0gY2FsY3VsYXRlUHJvdmlkZWRCeVRodW5rKGFjdGlvbiwgXCJwcm92aWRlc1RhZ3NcIiwgZGVmaW5pdGlvbnMsIGFzc2VydFRhZ1R5cGUpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBxdWVyeUNhY2hlS2V5XG4gICAgICB9ID0gYWN0aW9uLm1ldGEuYXJnO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcXVlcnlDYWNoZUtleSxcbiAgICAgICAgcHJvdmlkZWRUYWdzXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGludmFsaWRhdGlvblNsaWNlLmNhc2VSZWR1Y2Vycy51cGRhdGVQcm92aWRlZEJ5KGRyYWZ0LCBpbnZhbGlkYXRpb25TbGljZS5hY3Rpb25zLnVwZGF0ZVByb3ZpZGVkQnkocHJvdmlkZWRCeUVudHJpZXMpKTtcbiAgfVxuICBjb25zdCBzdWJzY3JpcHRpb25TbGljZSA9IGNyZWF0ZVNsaWNlKHtcbiAgICBuYW1lOiBgJHtyZWR1Y2VyUGF0aH0vc3Vic2NyaXB0aW9uc2AsXG4gICAgaW5pdGlhbFN0YXRlLFxuICAgIHJlZHVjZXJzOiB7XG4gICAgICB1cGRhdGVTdWJzY3JpcHRpb25PcHRpb25zKGQsIGEpIHtcbiAgICAgIH0sXG4gICAgICB1bnN1YnNjcmliZVF1ZXJ5UmVzdWx0KGQsIGEpIHtcbiAgICAgIH0sXG4gICAgICBpbnRlcm5hbF9nZXRSVEtRU3Vic2NyaXB0aW9ucygpIHtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBjb25zdCBpbnRlcm5hbFN1YnNjcmlwdGlvbnNTbGljZSA9IGNyZWF0ZVNsaWNlKHtcbiAgICBuYW1lOiBgJHtyZWR1Y2VyUGF0aH0vaW50ZXJuYWxTdWJzY3JpcHRpb25zYCxcbiAgICBpbml0aWFsU3RhdGUsXG4gICAgcmVkdWNlcnM6IHtcbiAgICAgIHN1YnNjcmlwdGlvbnNVcGRhdGVkOiB7XG4gICAgICAgIHJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAgICAgICAgIHJldHVybiBhcHBseVBhdGNoZXMoc3RhdGUsIGFjdGlvbi5wYXlsb2FkKTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJlcGFyZTogcHJlcGFyZUF1dG9CYXRjaGVkKClcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBjb25zdCBjb25maWdTbGljZSA9IGNyZWF0ZVNsaWNlKHtcbiAgICBuYW1lOiBgJHtyZWR1Y2VyUGF0aH0vY29uZmlnYCxcbiAgICBpbml0aWFsU3RhdGU6IHtcbiAgICAgIG9ubGluZTogaXNPbmxpbmUoKSxcbiAgICAgIGZvY3VzZWQ6IGlzRG9jdW1lbnRWaXNpYmxlKCksXG4gICAgICBtaWRkbGV3YXJlUmVnaXN0ZXJlZDogZmFsc2UsXG4gICAgICAuLi5jb25maWdcbiAgICB9LFxuICAgIHJlZHVjZXJzOiB7XG4gICAgICBtaWRkbGV3YXJlUmVnaXN0ZXJlZChzdGF0ZSwge1xuICAgICAgICBwYXlsb2FkXG4gICAgICB9KSB7XG4gICAgICAgIHN0YXRlLm1pZGRsZXdhcmVSZWdpc3RlcmVkID0gc3RhdGUubWlkZGxld2FyZVJlZ2lzdGVyZWQgPT09IFwiY29uZmxpY3RcIiB8fCBhcGlVaWQgIT09IHBheWxvYWQgPyBcImNvbmZsaWN0XCIgOiB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgZXh0cmFSZWR1Y2VyczogKGJ1aWxkZXIpID0+IHtcbiAgICAgIGJ1aWxkZXIuYWRkQ2FzZShvbk9ubGluZSwgKHN0YXRlKSA9PiB7XG4gICAgICAgIHN0YXRlLm9ubGluZSA9IHRydWU7XG4gICAgICB9KS5hZGRDYXNlKG9uT2ZmbGluZSwgKHN0YXRlKSA9PiB7XG4gICAgICAgIHN0YXRlLm9ubGluZSA9IGZhbHNlO1xuICAgICAgfSkuYWRkQ2FzZShvbkZvY3VzLCAoc3RhdGUpID0+IHtcbiAgICAgICAgc3RhdGUuZm9jdXNlZCA9IHRydWU7XG4gICAgICB9KS5hZGRDYXNlKG9uRm9jdXNMb3N0LCAoc3RhdGUpID0+IHtcbiAgICAgICAgc3RhdGUuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgfSkuYWRkTWF0Y2hlcihoYXNSZWh5ZHJhdGlvbkluZm8sIChkcmFmdCkgPT4gKHtcbiAgICAgICAgLi4uZHJhZnRcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBjb21iaW5lZFJlZHVjZXIgPSBjb21iaW5lUmVkdWNlcnMoe1xuICAgIHF1ZXJpZXM6IHF1ZXJ5U2xpY2UucmVkdWNlcixcbiAgICBtdXRhdGlvbnM6IG11dGF0aW9uU2xpY2UucmVkdWNlcixcbiAgICBwcm92aWRlZDogaW52YWxpZGF0aW9uU2xpY2UucmVkdWNlcixcbiAgICBzdWJzY3JpcHRpb25zOiBpbnRlcm5hbFN1YnNjcmlwdGlvbnNTbGljZS5yZWR1Y2VyLFxuICAgIGNvbmZpZzogY29uZmlnU2xpY2UucmVkdWNlclxuICB9KTtcbiAgY29uc3QgcmVkdWNlciA9IChzdGF0ZSwgYWN0aW9uKSA9PiBjb21iaW5lZFJlZHVjZXIocmVzZXRBcGlTdGF0ZS5tYXRjaChhY3Rpb24pID8gdm9pZCAwIDogc3RhdGUsIGFjdGlvbik7XG4gIGNvbnN0IGFjdGlvbnMgPSB7XG4gICAgLi4uY29uZmlnU2xpY2UuYWN0aW9ucyxcbiAgICAuLi5xdWVyeVNsaWNlLmFjdGlvbnMsXG4gICAgLi4uc3Vic2NyaXB0aW9uU2xpY2UuYWN0aW9ucyxcbiAgICAuLi5pbnRlcm5hbFN1YnNjcmlwdGlvbnNTbGljZS5hY3Rpb25zLFxuICAgIC4uLm11dGF0aW9uU2xpY2UuYWN0aW9ucyxcbiAgICAuLi5pbnZhbGlkYXRpb25TbGljZS5hY3Rpb25zLFxuICAgIHJlc2V0QXBpU3RhdGVcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICByZWR1Y2VyLFxuICAgIGFjdGlvbnNcbiAgfTtcbn1cblxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRTZWxlY3RvcnMudHNcbnZhciBza2lwVG9rZW4gPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcIlJUS1Evc2tpcFRva2VuXCIpO1xudmFyIGluaXRpYWxTdWJTdGF0ZSA9IHtcbiAgc3RhdHVzOiBcInVuaW5pdGlhbGl6ZWRcIiAvKiB1bmluaXRpYWxpemVkICovXG59O1xudmFyIGRlZmF1bHRRdWVyeVN1YlN0YXRlID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZU5leHRTdGF0ZShpbml0aWFsU3ViU3RhdGUsICgpID0+IHtcbn0pO1xudmFyIGRlZmF1bHRNdXRhdGlvblN1YlN0YXRlID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZU5leHRTdGF0ZShpbml0aWFsU3ViU3RhdGUsICgpID0+IHtcbn0pO1xuZnVuY3Rpb24gYnVpbGRTZWxlY3RvcnMoe1xuICBzZXJpYWxpemVRdWVyeUFyZ3MsXG4gIHJlZHVjZXJQYXRoLFxuICBjcmVhdGVTZWxlY3RvcjogY3JlYXRlU2VsZWN0b3IyXG59KSB7XG4gIGNvbnN0IHNlbGVjdFNraXBwZWRRdWVyeSA9IChzdGF0ZSkgPT4gZGVmYXVsdFF1ZXJ5U3ViU3RhdGU7XG4gIGNvbnN0IHNlbGVjdFNraXBwZWRNdXRhdGlvbiA9IChzdGF0ZSkgPT4gZGVmYXVsdE11dGF0aW9uU3ViU3RhdGU7XG4gIHJldHVybiB7XG4gICAgYnVpbGRRdWVyeVNlbGVjdG9yLFxuICAgIGJ1aWxkSW5maW5pdGVRdWVyeVNlbGVjdG9yLFxuICAgIGJ1aWxkTXV0YXRpb25TZWxlY3RvcixcbiAgICBzZWxlY3RJbnZhbGlkYXRlZEJ5LFxuICAgIHNlbGVjdENhY2hlZEFyZ3NGb3JRdWVyeSxcbiAgICBzZWxlY3RBcGlTdGF0ZSxcbiAgICBzZWxlY3RRdWVyaWVzLFxuICAgIHNlbGVjdE11dGF0aW9ucyxcbiAgICBzZWxlY3RRdWVyeUVudHJ5LFxuICAgIHNlbGVjdENvbmZpZ1xuICB9O1xuICBmdW5jdGlvbiB3aXRoUmVxdWVzdEZsYWdzKHN1YnN0YXRlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1YnN0YXRlLFxuICAgICAgLi4uZ2V0UmVxdWVzdFN0YXR1c0ZsYWdzKHN1YnN0YXRlLnN0YXR1cylcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHNlbGVjdEFwaVN0YXRlKHJvb3RTdGF0ZSkge1xuICAgIGNvbnN0IHN0YXRlID0gcm9vdFN0YXRlW3JlZHVjZXJQYXRoXTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgIGlmIChzZWxlY3RBcGlTdGF0ZS50cmlnZ2VyZWQpIHJldHVybiBzdGF0ZTtcbiAgICAgICAgc2VsZWN0QXBpU3RhdGUudHJpZ2dlcmVkID0gdHJ1ZTtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3I6IE5vIGRhdGEgZm91bmQgYXQgXFxgc3RhdGUuJHtyZWR1Y2VyUGF0aH1cXGAuIERpZCB5b3UgZm9yZ2V0IHRvIGFkZCB0aGUgcmVkdWNlciB0byB0aGUgc3RvcmU/YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBmdW5jdGlvbiBzZWxlY3RRdWVyaWVzKHJvb3RTdGF0ZSkge1xuICAgIHJldHVybiBzZWxlY3RBcGlTdGF0ZShyb290U3RhdGUpPy5xdWVyaWVzO1xuICB9XG4gIGZ1bmN0aW9uIHNlbGVjdFF1ZXJ5RW50cnkocm9vdFN0YXRlLCBjYWNoZUtleSkge1xuICAgIHJldHVybiBzZWxlY3RRdWVyaWVzKHJvb3RTdGF0ZSk/LltjYWNoZUtleV07XG4gIH1cbiAgZnVuY3Rpb24gc2VsZWN0TXV0YXRpb25zKHJvb3RTdGF0ZSkge1xuICAgIHJldHVybiBzZWxlY3RBcGlTdGF0ZShyb290U3RhdGUpPy5tdXRhdGlvbnM7XG4gIH1cbiAgZnVuY3Rpb24gc2VsZWN0Q29uZmlnKHJvb3RTdGF0ZSkge1xuICAgIHJldHVybiBzZWxlY3RBcGlTdGF0ZShyb290U3RhdGUpPy5jb25maWc7XG4gIH1cbiAgZnVuY3Rpb24gYnVpbGRBbnlRdWVyeVNlbGVjdG9yKGVuZHBvaW50TmFtZSwgZW5kcG9pbnREZWZpbml0aW9uLCBjb21iaW5lcikge1xuICAgIHJldHVybiAocXVlcnlBcmdzKSA9PiB7XG4gICAgICBpZiAocXVlcnlBcmdzID09PSBza2lwVG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RTa2lwcGVkUXVlcnksIGNvbWJpbmVyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWRBcmdzID0gc2VyaWFsaXplUXVlcnlBcmdzKHtcbiAgICAgICAgcXVlcnlBcmdzLFxuICAgICAgICBlbmRwb2ludERlZmluaXRpb24sXG4gICAgICAgIGVuZHBvaW50TmFtZVxuICAgICAgfSk7XG4gICAgICBjb25zdCBzZWxlY3RRdWVyeVN1YnN0YXRlID0gKHN0YXRlKSA9PiBzZWxlY3RRdWVyeUVudHJ5KHN0YXRlLCBzZXJpYWxpemVkQXJncykgPz8gZGVmYXVsdFF1ZXJ5U3ViU3RhdGU7XG4gICAgICByZXR1cm4gY3JlYXRlU2VsZWN0b3IyKHNlbGVjdFF1ZXJ5U3Vic3RhdGUsIGNvbWJpbmVyKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGJ1aWxkUXVlcnlTZWxlY3RvcihlbmRwb2ludE5hbWUsIGVuZHBvaW50RGVmaW5pdGlvbikge1xuICAgIHJldHVybiBidWlsZEFueVF1ZXJ5U2VsZWN0b3IoZW5kcG9pbnROYW1lLCBlbmRwb2ludERlZmluaXRpb24sIHdpdGhSZXF1ZXN0RmxhZ3MpO1xuICB9XG4gIGZ1bmN0aW9uIGJ1aWxkSW5maW5pdGVRdWVyeVNlbGVjdG9yKGVuZHBvaW50TmFtZSwgZW5kcG9pbnREZWZpbml0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgaW5maW5pdGVRdWVyeU9wdGlvbnNcbiAgICB9ID0gZW5kcG9pbnREZWZpbml0aW9uO1xuICAgIGZ1bmN0aW9uIHdpdGhJbmZpbml0ZVF1ZXJ5UmVzdWx0RmxhZ3Moc3Vic3RhdGUpIHtcbiAgICAgIGNvbnN0IHN0YXRlV2l0aFJlcXVlc3RGbGFncyA9IHtcbiAgICAgICAgLi4uc3Vic3RhdGUsXG4gICAgICAgIC4uLmdldFJlcXVlc3RTdGF0dXNGbGFncyhzdWJzdGF0ZS5zdGF0dXMpXG4gICAgICB9O1xuICAgICAgY29uc3Qge1xuICAgICAgICBpc0xvYWRpbmcsXG4gICAgICAgIGlzRXJyb3IsXG4gICAgICAgIGRpcmVjdGlvblxuICAgICAgfSA9IHN0YXRlV2l0aFJlcXVlc3RGbGFncztcbiAgICAgIGNvbnN0IGlzRm9yd2FyZCA9IGRpcmVjdGlvbiA9PT0gXCJmb3J3YXJkXCI7XG4gICAgICBjb25zdCBpc0JhY2t3YXJkID0gZGlyZWN0aW9uID09PSBcImJhY2t3YXJkXCI7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZVdpdGhSZXF1ZXN0RmxhZ3MsXG4gICAgICAgIGhhc05leHRQYWdlOiBnZXRIYXNOZXh0UGFnZShpbmZpbml0ZVF1ZXJ5T3B0aW9ucywgc3RhdGVXaXRoUmVxdWVzdEZsYWdzLmRhdGEsIHN0YXRlV2l0aFJlcXVlc3RGbGFncy5vcmlnaW5hbEFyZ3MpLFxuICAgICAgICBoYXNQcmV2aW91c1BhZ2U6IGdldEhhc1ByZXZpb3VzUGFnZShpbmZpbml0ZVF1ZXJ5T3B0aW9ucywgc3RhdGVXaXRoUmVxdWVzdEZsYWdzLmRhdGEsIHN0YXRlV2l0aFJlcXVlc3RGbGFncy5vcmlnaW5hbEFyZ3MpLFxuICAgICAgICBpc0ZldGNoaW5nTmV4dFBhZ2U6IGlzTG9hZGluZyAmJiBpc0ZvcndhcmQsXG4gICAgICAgIGlzRmV0Y2hpbmdQcmV2aW91c1BhZ2U6IGlzTG9hZGluZyAmJiBpc0JhY2t3YXJkLFxuICAgICAgICBpc0ZldGNoTmV4dFBhZ2VFcnJvcjogaXNFcnJvciAmJiBpc0ZvcndhcmQsXG4gICAgICAgIGlzRmV0Y2hQcmV2aW91c1BhZ2VFcnJvcjogaXNFcnJvciAmJiBpc0JhY2t3YXJkXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gYnVpbGRBbnlRdWVyeVNlbGVjdG9yKGVuZHBvaW50TmFtZSwgZW5kcG9pbnREZWZpbml0aW9uLCB3aXRoSW5maW5pdGVRdWVyeVJlc3VsdEZsYWdzKTtcbiAgfVxuICBmdW5jdGlvbiBidWlsZE11dGF0aW9uU2VsZWN0b3IoKSB7XG4gICAgcmV0dXJuIChpZCkgPT4ge1xuICAgICAgbGV0IG11dGF0aW9uSWQ7XG4gICAgICBpZiAodHlwZW9mIGlkID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIG11dGF0aW9uSWQgPSBnZXRNdXRhdGlvbkNhY2hlS2V5KGlkKSA/PyBza2lwVG9rZW47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtdXRhdGlvbklkID0gaWQ7XG4gICAgICB9XG4gICAgICBjb25zdCBzZWxlY3RNdXRhdGlvblN1YnN0YXRlID0gKHN0YXRlKSA9PiBzZWxlY3RBcGlTdGF0ZShzdGF0ZSk/Lm11dGF0aW9ucz8uW211dGF0aW9uSWRdID8/IGRlZmF1bHRNdXRhdGlvblN1YlN0YXRlO1xuICAgICAgY29uc3QgZmluYWxTZWxlY3RNdXRhdGlvblN1YnN0YXRlID0gbXV0YXRpb25JZCA9PT0gc2tpcFRva2VuID8gc2VsZWN0U2tpcHBlZE11dGF0aW9uIDogc2VsZWN0TXV0YXRpb25TdWJzdGF0ZTtcbiAgICAgIHJldHVybiBjcmVhdGVTZWxlY3RvcjIoZmluYWxTZWxlY3RNdXRhdGlvblN1YnN0YXRlLCB3aXRoUmVxdWVzdEZsYWdzKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHNlbGVjdEludmFsaWRhdGVkQnkoc3RhdGUsIHRhZ3MpIHtcbiAgICBjb25zdCBhcGlTdGF0ZSA9IHN0YXRlW3JlZHVjZXJQYXRoXTtcbiAgICBjb25zdCB0b0ludmFsaWRhdGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgdGFnIG9mIHRhZ3MuZmlsdGVyKGlzTm90TnVsbGlzaCkubWFwKGV4cGFuZFRhZ0Rlc2NyaXB0aW9uKSkge1xuICAgICAgY29uc3QgcHJvdmlkZWQgPSBhcGlTdGF0ZS5wcm92aWRlZC50YWdzW3RhZy50eXBlXTtcbiAgICAgIGlmICghcHJvdmlkZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsZXQgaW52YWxpZGF0ZVN1YnNjcmlwdGlvbnMgPSAodGFnLmlkICE9PSB2b2lkIDAgPyAoXG4gICAgICAgIC8vIGlkIGdpdmVuOiBpbnZhbGlkYXRlIGFsbCBxdWVyaWVzIHRoYXQgcHJvdmlkZSB0aGlzIHR5cGUgJiBpZFxuICAgICAgICBwcm92aWRlZFt0YWcuaWRdXG4gICAgICApIDogKFxuICAgICAgICAvLyBubyBpZDogaW52YWxpZGF0ZSBhbGwgcXVlcmllcyB0aGF0IHByb3ZpZGUgdGhpcyB0eXBlXG4gICAgICAgIGZsYXR0ZW4oT2JqZWN0LnZhbHVlcyhwcm92aWRlZCkpXG4gICAgICApKSA/PyBbXTtcbiAgICAgIGZvciAoY29uc3QgaW52YWxpZGF0ZSBvZiBpbnZhbGlkYXRlU3Vic2NyaXB0aW9ucykge1xuICAgICAgICB0b0ludmFsaWRhdGUuYWRkKGludmFsaWRhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmxhdHRlbihBcnJheS5mcm9tKHRvSW52YWxpZGF0ZS52YWx1ZXMoKSkubWFwKChxdWVyeUNhY2hlS2V5KSA9PiB7XG4gICAgICBjb25zdCBxdWVyeVN1YlN0YXRlID0gYXBpU3RhdGUucXVlcmllc1txdWVyeUNhY2hlS2V5XTtcbiAgICAgIHJldHVybiBxdWVyeVN1YlN0YXRlID8gW3tcbiAgICAgICAgcXVlcnlDYWNoZUtleSxcbiAgICAgICAgZW5kcG9pbnROYW1lOiBxdWVyeVN1YlN0YXRlLmVuZHBvaW50TmFtZSxcbiAgICAgICAgb3JpZ2luYWxBcmdzOiBxdWVyeVN1YlN0YXRlLm9yaWdpbmFsQXJnc1xuICAgICAgfV0gOiBbXTtcbiAgICB9KSk7XG4gIH1cbiAgZnVuY3Rpb24gc2VsZWN0Q2FjaGVkQXJnc0ZvclF1ZXJ5KHN0YXRlLCBxdWVyeU5hbWUpIHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhzZWxlY3RRdWVyaWVzKHN0YXRlKSkuZmlsdGVyKChlbnRyeSkgPT4gZW50cnk/LmVuZHBvaW50TmFtZSA9PT0gcXVlcnlOYW1lICYmIGVudHJ5LnN0YXR1cyAhPT0gXCJ1bmluaXRpYWxpemVkXCIgLyogdW5pbml0aWFsaXplZCAqLykubWFwKChlbnRyeSkgPT4gZW50cnkub3JpZ2luYWxBcmdzKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRIYXNOZXh0UGFnZShvcHRpb25zLCBkYXRhLCBxdWVyeUFyZykge1xuICAgIGlmICghZGF0YSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBnZXROZXh0UGFnZVBhcmFtKG9wdGlvbnMsIGRhdGEsIHF1ZXJ5QXJnKSAhPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGdldEhhc1ByZXZpb3VzUGFnZShvcHRpb25zLCBkYXRhLCBxdWVyeUFyZykge1xuICAgIGlmICghZGF0YSB8fCAhb3B0aW9ucy5nZXRQcmV2aW91c1BhZ2VQYXJhbSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBnZXRQcmV2aW91c1BhZ2VQYXJhbShvcHRpb25zLCBkYXRhLCBxdWVyeUFyZykgIT0gbnVsbDtcbiAgfVxufVxuXG4vLyBzcmMvcXVlcnkvY3JlYXRlQXBpLnRzXG5pbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMiwgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTIyLCBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMyB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XG5cbi8vIHNyYy9xdWVyeS9kZWZhdWx0U2VyaWFsaXplUXVlcnlBcmdzLnRzXG52YXIgY2FjaGUgPSBXZWFrTWFwID8gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCkgOiB2b2lkIDA7XG52YXIgZGVmYXVsdFNlcmlhbGl6ZVF1ZXJ5QXJncyA9ICh7XG4gIGVuZHBvaW50TmFtZSxcbiAgcXVlcnlBcmdzXG59KSA9PiB7XG4gIGxldCBzZXJpYWxpemVkID0gXCJcIjtcbiAgY29uc3QgY2FjaGVkID0gY2FjaGU/LmdldChxdWVyeUFyZ3MpO1xuICBpZiAodHlwZW9mIGNhY2hlZCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHNlcmlhbGl6ZWQgPSBjYWNoZWQ7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc3RyaW5naWZpZWQgPSBKU09OLnN0cmluZ2lmeShxdWVyeUFyZ3MsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICB2YWx1ZSA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIiA/IHtcbiAgICAgICAgJGJpZ2ludDogdmFsdWUudG9TdHJpbmcoKVxuICAgICAgfSA6IHZhbHVlO1xuICAgICAgdmFsdWUgPSBpc1BsYWluT2JqZWN0KHZhbHVlKSA/IE9iamVjdC5rZXlzKHZhbHVlKS5zb3J0KCkucmVkdWNlKChhY2MsIGtleTIpID0+IHtcbiAgICAgICAgYWNjW2tleTJdID0gdmFsdWVba2V5Ml07XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCB7fSkgOiB2YWx1ZTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9KTtcbiAgICBpZiAoaXNQbGFpbk9iamVjdChxdWVyeUFyZ3MpKSB7XG4gICAgICBjYWNoZT8uc2V0KHF1ZXJ5QXJncywgc3RyaW5naWZpZWQpO1xuICAgIH1cbiAgICBzZXJpYWxpemVkID0gc3RyaW5naWZpZWQ7XG4gIH1cbiAgcmV0dXJuIGAke2VuZHBvaW50TmFtZX0oJHtzZXJpYWxpemVkfSlgO1xufTtcblxuLy8gc3JjL3F1ZXJ5L2NyZWF0ZUFwaS50c1xuaW1wb3J0IHsgd2Vha01hcE1lbW9pemUgfSBmcm9tIFwicmVzZWxlY3RcIjtcbmZ1bmN0aW9uIGJ1aWxkQ3JlYXRlQXBpKC4uLm1vZHVsZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJhc2VDcmVhdGVBcGkob3B0aW9ucykge1xuICAgIGNvbnN0IGV4dHJhY3RSZWh5ZHJhdGlvbkluZm8gPSB3ZWFrTWFwTWVtb2l6ZSgoYWN0aW9uKSA9PiBvcHRpb25zLmV4dHJhY3RSZWh5ZHJhdGlvbkluZm8/LihhY3Rpb24sIHtcbiAgICAgIHJlZHVjZXJQYXRoOiBvcHRpb25zLnJlZHVjZXJQYXRoID8/IFwiYXBpXCJcbiAgICB9KSk7XG4gICAgY29uc3Qgb3B0aW9uc1dpdGhEZWZhdWx0cyA9IHtcbiAgICAgIHJlZHVjZXJQYXRoOiBcImFwaVwiLFxuICAgICAga2VlcFVudXNlZERhdGFGb3I6IDYwLFxuICAgICAgcmVmZXRjaE9uTW91bnRPckFyZ0NoYW5nZTogZmFsc2UsXG4gICAgICByZWZldGNoT25Gb2N1czogZmFsc2UsXG4gICAgICByZWZldGNoT25SZWNvbm5lY3Q6IGZhbHNlLFxuICAgICAgaW52YWxpZGF0aW9uQmVoYXZpb3I6IFwiZGVsYXllZFwiLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGV4dHJhY3RSZWh5ZHJhdGlvbkluZm8sXG4gICAgICBzZXJpYWxpemVRdWVyeUFyZ3MocXVlcnlBcmdzQXBpKSB7XG4gICAgICAgIGxldCBmaW5hbFNlcmlhbGl6ZVF1ZXJ5QXJncyA9IGRlZmF1bHRTZXJpYWxpemVRdWVyeUFyZ3M7XG4gICAgICAgIGlmIChcInNlcmlhbGl6ZVF1ZXJ5QXJnc1wiIGluIHF1ZXJ5QXJnc0FwaS5lbmRwb2ludERlZmluaXRpb24pIHtcbiAgICAgICAgICBjb25zdCBlbmRwb2ludFNRQSA9IHF1ZXJ5QXJnc0FwaS5lbmRwb2ludERlZmluaXRpb24uc2VyaWFsaXplUXVlcnlBcmdzO1xuICAgICAgICAgIGZpbmFsU2VyaWFsaXplUXVlcnlBcmdzID0gKHF1ZXJ5QXJnc0FwaTIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxSZXN1bHQgPSBlbmRwb2ludFNRQShxdWVyeUFyZ3NBcGkyKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5pdGlhbFJlc3VsdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICByZXR1cm4gaW5pdGlhbFJlc3VsdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0U2VyaWFsaXplUXVlcnlBcmdzKHtcbiAgICAgICAgICAgICAgICAuLi5xdWVyeUFyZ3NBcGkyLFxuICAgICAgICAgICAgICAgIHF1ZXJ5QXJnczogaW5pdGlhbFJlc3VsdFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc2VyaWFsaXplUXVlcnlBcmdzKSB7XG4gICAgICAgICAgZmluYWxTZXJpYWxpemVRdWVyeUFyZ3MgPSBvcHRpb25zLnNlcmlhbGl6ZVF1ZXJ5QXJncztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmluYWxTZXJpYWxpemVRdWVyeUFyZ3MocXVlcnlBcmdzQXBpKTtcbiAgICAgIH0sXG4gICAgICB0YWdUeXBlczogWy4uLm9wdGlvbnMudGFnVHlwZXMgfHwgW11dXG4gICAgfTtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgZW5kcG9pbnREZWZpbml0aW9uczoge30sXG4gICAgICBiYXRjaChmbikge1xuICAgICAgICBmbigpO1xuICAgICAgfSxcbiAgICAgIGFwaVVpZDogbmFub2lkKCksXG4gICAgICBleHRyYWN0UmVoeWRyYXRpb25JbmZvLFxuICAgICAgaGFzUmVoeWRyYXRpb25JbmZvOiB3ZWFrTWFwTWVtb2l6ZSgoYWN0aW9uKSA9PiBleHRyYWN0UmVoeWRyYXRpb25JbmZvKGFjdGlvbikgIT0gbnVsbClcbiAgICB9O1xuICAgIGNvbnN0IGFwaSA9IHtcbiAgICAgIGluamVjdEVuZHBvaW50cyxcbiAgICAgIGVuaGFuY2VFbmRwb2ludHMoe1xuICAgICAgICBhZGRUYWdUeXBlcyxcbiAgICAgICAgZW5kcG9pbnRzXG4gICAgICB9KSB7XG4gICAgICAgIGlmIChhZGRUYWdUeXBlcykge1xuICAgICAgICAgIGZvciAoY29uc3QgZVQgb2YgYWRkVGFnVHlwZXMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9uc1dpdGhEZWZhdWx0cy50YWdUeXBlcy5pbmNsdWRlcyhlVCkpIHtcbiAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICBvcHRpb25zV2l0aERlZmF1bHRzLnRhZ1R5cGVzLnB1c2goZVQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kcG9pbnRzKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBbZW5kcG9pbnROYW1lLCBwYXJ0aWFsRGVmaW5pdGlvbl0gb2YgT2JqZWN0LmVudHJpZXMoZW5kcG9pbnRzKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0aWFsRGVmaW5pdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIHBhcnRpYWxEZWZpbml0aW9uKGNvbnRleHQuZW5kcG9pbnREZWZpbml0aW9uc1tlbmRwb2ludE5hbWVdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY29udGV4dC5lbmRwb2ludERlZmluaXRpb25zW2VuZHBvaW50TmFtZV0gfHwge30sIHBhcnRpYWxEZWZpbml0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwaTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGluaXRpYWxpemVkTW9kdWxlcyA9IG1vZHVsZXMubWFwKChtKSA9PiBtLmluaXQoYXBpLCBvcHRpb25zV2l0aERlZmF1bHRzLCBjb250ZXh0KSk7XG4gICAgZnVuY3Rpb24gaW5qZWN0RW5kcG9pbnRzKGluamVjdCkge1xuICAgICAgY29uc3QgZXZhbHVhdGVkRW5kcG9pbnRzID0gaW5qZWN0LmVuZHBvaW50cyh7XG4gICAgICAgIHF1ZXJ5OiAoeCkgPT4gKHtcbiAgICAgICAgICAuLi54LFxuICAgICAgICAgIHR5cGU6IFwicXVlcnlcIiAvKiBxdWVyeSAqL1xuICAgICAgICB9KSxcbiAgICAgICAgbXV0YXRpb246ICh4KSA9PiAoe1xuICAgICAgICAgIC4uLngsXG4gICAgICAgICAgdHlwZTogXCJtdXRhdGlvblwiIC8qIG11dGF0aW9uICovXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZpbml0ZVF1ZXJ5OiAoeCkgPT4gKHtcbiAgICAgICAgICAuLi54LFxuICAgICAgICAgIHR5cGU6IFwiaW5maW5pdGVxdWVyeVwiIC8qIGluZmluaXRlcXVlcnkgKi9cbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgZm9yIChjb25zdCBbZW5kcG9pbnROYW1lLCBkZWZpbml0aW9uXSBvZiBPYmplY3QuZW50cmllcyhldmFsdWF0ZWRFbmRwb2ludHMpKSB7XG4gICAgICAgIGlmIChpbmplY3Qub3ZlcnJpZGVFeGlzdGluZyAhPT0gdHJ1ZSAmJiBlbmRwb2ludE5hbWUgaW4gY29udGV4dC5lbmRwb2ludERlZmluaXRpb25zKSB7XG4gICAgICAgICAgaWYgKGluamVjdC5vdmVycmlkZUV4aXN0aW5nID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTIoMzkpIDogYGNhbGxlZCBcXGBpbmplY3RFbmRwb2ludHNcXGAgdG8gb3ZlcnJpZGUgYWxyZWFkeS1leGlzdGluZyBlbmRwb2ludE5hbWUgJHtlbmRwb2ludE5hbWV9IHdpdGhvdXQgc3BlY2lmeWluZyBcXGBvdmVycmlkZUV4aXN0aW5nOiB0cnVlXFxgYCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBjYWxsZWQgXFxgaW5qZWN0RW5kcG9pbnRzXFxgIHRvIG92ZXJyaWRlIGFscmVhZHktZXhpc3RpbmcgZW5kcG9pbnROYW1lICR7ZW5kcG9pbnROYW1lfSB3aXRob3V0IHNwZWNpZnlpbmcgXFxgb3ZlcnJpZGVFeGlzdGluZzogdHJ1ZVxcYGApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICAgIGlmIChpc0luZmluaXRlUXVlcnlEZWZpbml0aW9uKGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGluZmluaXRlUXVlcnlPcHRpb25zXG4gICAgICAgICAgICB9ID0gZGVmaW5pdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgbWF4UGFnZXMsXG4gICAgICAgICAgICAgIGdldFByZXZpb3VzUGFnZVBhcmFtOiBnZXRQcmV2aW91c1BhZ2VQYXJhbTJcbiAgICAgICAgICAgIH0gPSBpbmZpbml0ZVF1ZXJ5T3B0aW9ucztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWF4UGFnZXMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgaWYgKG1heFBhZ2VzIDwgMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTIyKDQwKSA6IGBtYXhQYWdlcyBmb3IgZW5kcG9pbnQgJyR7ZW5kcG9pbnROYW1lfScgbXVzdCBiZSBhIG51bWJlciBncmVhdGVyIHRoYW4gMGApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgZ2V0UHJldmlvdXNQYWdlUGFyYW0yICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UzKDQxKSA6IGBnZXRQcmV2aW91c1BhZ2VQYXJhbSBmb3IgZW5kcG9pbnQgJyR7ZW5kcG9pbnROYW1lfScgbXVzdCBiZSBhIGZ1bmN0aW9uIGlmIG1heFBhZ2VzIGlzIHVzZWRgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmVuZHBvaW50RGVmaW5pdGlvbnNbZW5kcG9pbnROYW1lXSA9IGRlZmluaXRpb247XG4gICAgICAgIGZvciAoY29uc3QgbSBvZiBpbml0aWFsaXplZE1vZHVsZXMpIHtcbiAgICAgICAgICBtLmluamVjdEVuZHBvaW50KGVuZHBvaW50TmFtZSwgZGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcGk7XG4gICAgfVxuICAgIHJldHVybiBhcGkuaW5qZWN0RW5kcG9pbnRzKHtcbiAgICAgIGVuZHBvaW50czogb3B0aW9ucy5lbmRwb2ludHNcbiAgICB9KTtcbiAgfTtcbn1cblxuLy8gc3JjL3F1ZXJ5L2Zha2VCYXNlUXVlcnkudHNcbmltcG9ydCB7IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U0IH0gZnJvbSBcIkByZWR1eGpzL3Rvb2xraXRcIjtcbnZhciBfTkVWRVIgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sKCk7XG5mdW5jdGlvbiBmYWtlQmFzZVF1ZXJ5KCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlNCgzMykgOiBcIldoZW4gdXNpbmcgYGZha2VCYXNlUXVlcnlgLCBhbGwgcXVlcmllcyAmIG11dGF0aW9ucyBtdXN0IHVzZSB0aGUgYHF1ZXJ5Rm5gIGRlZmluaXRpb24gc3ludGF4LlwiKTtcbiAgfTtcbn1cblxuLy8gc3JjL3F1ZXJ5L2NvcmUvbW9kdWxlLnRzXG5pbXBvcnQgeyBlbmFibGVQYXRjaGVzIH0gZnJvbSBcImltbWVyXCI7XG5cbi8vIHNyYy9xdWVyeS90c0hlbHBlcnMudHNcbmZ1bmN0aW9uIGFzc2VydENhc3Qodikge1xufVxuZnVuY3Rpb24gc2FmZUFzc2lnbih0YXJnZXQsIC4uLmFyZ3MpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24odGFyZ2V0LCAuLi5hcmdzKTtcbn1cblxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRNaWRkbGV3YXJlL2JhdGNoQWN0aW9ucy50c1xuaW1wb3J0IHsgcHJvZHVjZVdpdGhQYXRjaGVzIGFzIHByb2R1Y2VXaXRoUGF0Y2hlczIgfSBmcm9tIFwiaW1tZXJcIjtcbnZhciBidWlsZEJhdGNoZWRBY3Rpb25zSGFuZGxlciA9ICh7XG4gIGFwaSxcbiAgcXVlcnlUaHVuayxcbiAgaW50ZXJuYWxTdGF0ZSxcbiAgbXdBcGlcbn0pID0+IHtcbiAgY29uc3Qgc3Vic2NyaXB0aW9uc1ByZWZpeCA9IGAke2FwaS5yZWR1Y2VyUGF0aH0vc3Vic2NyaXB0aW9uc2A7XG4gIGxldCBwcmV2aW91c1N1YnNjcmlwdGlvbnMgPSBudWxsO1xuICBsZXQgdXBkYXRlU3luY1RpbWVyID0gbnVsbDtcbiAgY29uc3Qge1xuICAgIHVwZGF0ZVN1YnNjcmlwdGlvbk9wdGlvbnMsXG4gICAgdW5zdWJzY3JpYmVRdWVyeVJlc3VsdFxuICB9ID0gYXBpLmludGVybmFsQWN0aW9ucztcbiAgY29uc3QgYWN0dWFsbHlNdXRhdGVTdWJzY3JpcHRpb25zID0gKGN1cnJlbnRTdWJzY3JpcHRpb25zLCBhY3Rpb24pID0+IHtcbiAgICBpZiAodXBkYXRlU3Vic2NyaXB0aW9uT3B0aW9ucy5tYXRjaChhY3Rpb24pKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHF1ZXJ5Q2FjaGVLZXksXG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgY29uc3Qgc3ViID0gY3VycmVudFN1YnNjcmlwdGlvbnMuZ2V0KHF1ZXJ5Q2FjaGVLZXkpO1xuICAgICAgaWYgKHN1Yj8uaGFzKHJlcXVlc3RJZCkpIHtcbiAgICAgICAgc3ViLnNldChyZXF1ZXN0SWQsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh1bnN1YnNjcmliZVF1ZXJ5UmVzdWx0Lm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcXVlcnlDYWNoZUtleSxcbiAgICAgICAgcmVxdWVzdElkXG4gICAgICB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgICBjb25zdCBzdWIgPSBjdXJyZW50U3Vic2NyaXB0aW9ucy5nZXQocXVlcnlDYWNoZUtleSk7XG4gICAgICBpZiAoc3ViKSB7XG4gICAgICAgIHN1Yi5kZWxldGUocmVxdWVzdElkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoYXBpLmludGVybmFsQWN0aW9ucy5yZW1vdmVRdWVyeVJlc3VsdC5tYXRjaChhY3Rpb24pKSB7XG4gICAgICBjdXJyZW50U3Vic2NyaXB0aW9ucy5kZWxldGUoYWN0aW9uLnBheWxvYWQucXVlcnlDYWNoZUtleSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5VGh1bmsucGVuZGluZy5tYXRjaChhY3Rpb24pKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1ldGE6IHtcbiAgICAgICAgICBhcmcsXG4gICAgICAgICAgcmVxdWVzdElkXG4gICAgICAgIH1cbiAgICAgIH0gPSBhY3Rpb247XG4gICAgICBjb25zdCBzdWJzdGF0ZSA9IGdldE9ySW5zZXJ0Q29tcHV0ZWQoY3VycmVudFN1YnNjcmlwdGlvbnMsIGFyZy5xdWVyeUNhY2hlS2V5LCBjcmVhdGVOZXdNYXApO1xuICAgICAgaWYgKGFyZy5zdWJzY3JpYmUpIHtcbiAgICAgICAgc3Vic3RhdGUuc2V0KHJlcXVlc3RJZCwgYXJnLnN1YnNjcmlwdGlvbk9wdGlvbnMgPz8gc3Vic3RhdGUuZ2V0KHJlcXVlc3RJZCkgPz8ge30pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBtdXRhdGVkID0gZmFsc2U7XG4gICAgaWYgKHF1ZXJ5VGh1bmsucmVqZWN0ZWQubWF0Y2goYWN0aW9uKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgY29uZGl0aW9uLFxuICAgICAgICAgIGFyZyxcbiAgICAgICAgICByZXF1ZXN0SWRcbiAgICAgICAgfVxuICAgICAgfSA9IGFjdGlvbjtcbiAgICAgIGlmIChjb25kaXRpb24gJiYgYXJnLnN1YnNjcmliZSkge1xuICAgICAgICBjb25zdCBzdWJzdGF0ZSA9IGdldE9ySW5zZXJ0Q29tcHV0ZWQoY3VycmVudFN1YnNjcmlwdGlvbnMsIGFyZy5xdWVyeUNhY2hlS2V5LCBjcmVhdGVOZXdNYXApO1xuICAgICAgICBzdWJzdGF0ZS5zZXQocmVxdWVzdElkLCBhcmcuc3Vic2NyaXB0aW9uT3B0aW9ucyA/PyBzdWJzdGF0ZS5nZXQocmVxdWVzdElkKSA/PyB7fSk7XG4gICAgICAgIG11dGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbXV0YXRlZDtcbiAgfTtcbiAgY29uc3QgZ2V0U3Vic2NyaXB0aW9ucyA9ICgpID0+IGludGVybmFsU3RhdGUuY3VycmVudFN1YnNjcmlwdGlvbnM7XG4gIGNvbnN0IGdldFN1YnNjcmlwdGlvbkNvdW50ID0gKHF1ZXJ5Q2FjaGVLZXkpID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb25zID0gZ2V0U3Vic2NyaXB0aW9ucygpO1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbnNGb3JRdWVyeUFyZyA9IHN1YnNjcmlwdGlvbnMuZ2V0KHF1ZXJ5Q2FjaGVLZXkpO1xuICAgIHJldHVybiBzdWJzY3JpcHRpb25zRm9yUXVlcnlBcmc/LnNpemUgPz8gMDtcbiAgfTtcbiAgY29uc3QgaXNSZXF1ZXN0U3Vic2NyaWJlZCA9IChxdWVyeUNhY2hlS2V5LCByZXF1ZXN0SWQpID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb25zID0gZ2V0U3Vic2NyaXB0aW9ucygpO1xuICAgIHJldHVybiAhIXN1YnNjcmlwdGlvbnM/LmdldChxdWVyeUNhY2hlS2V5KT8uZ2V0KHJlcXVlc3RJZCk7XG4gIH07XG4gIGNvbnN0IHN1YnNjcmlwdGlvblNlbGVjdG9ycyA9IHtcbiAgICBnZXRTdWJzY3JpcHRpb25zLFxuICAgIGdldFN1YnNjcmlwdGlvbkNvdW50LFxuICAgIGlzUmVxdWVzdFN1YnNjcmliZWRcbiAgfTtcbiAgZnVuY3Rpb24gc2VyaWFsaXplU3Vic2NyaXB0aW9ucyhjdXJyZW50U3Vic2NyaXB0aW9ucykge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KE9iamVjdC5mcm9tRW50cmllcyhbLi4uY3VycmVudFN1YnNjcmlwdGlvbnNdLm1hcCgoW2ssIHZdKSA9PiBbaywgT2JqZWN0LmZyb21FbnRyaWVzKHYpXSkpKSk7XG4gIH1cbiAgcmV0dXJuIChhY3Rpb24sIG13QXBpMikgPT4ge1xuICAgIGlmICghcHJldmlvdXNTdWJzY3JpcHRpb25zKSB7XG4gICAgICBwcmV2aW91c1N1YnNjcmlwdGlvbnMgPSBzZXJpYWxpemVTdWJzY3JpcHRpb25zKGludGVybmFsU3RhdGUuY3VycmVudFN1YnNjcmlwdGlvbnMpO1xuICAgIH1cbiAgICBpZiAoYXBpLnV0aWwucmVzZXRBcGlTdGF0ZS5tYXRjaChhY3Rpb24pKSB7XG4gICAgICBwcmV2aW91c1N1YnNjcmlwdGlvbnMgPSB7fTtcbiAgICAgIGludGVybmFsU3RhdGUuY3VycmVudFN1YnNjcmlwdGlvbnMuY2xlYXIoKTtcbiAgICAgIHVwZGF0ZVN5bmNUaW1lciA9IG51bGw7XG4gICAgICByZXR1cm4gW3RydWUsIGZhbHNlXTtcbiAgICB9XG4gICAgaWYgKGFwaS5pbnRlcm5hbEFjdGlvbnMuaW50ZXJuYWxfZ2V0UlRLUVN1YnNjcmlwdGlvbnMubWF0Y2goYWN0aW9uKSkge1xuICAgICAgcmV0dXJuIFtmYWxzZSwgc3Vic2NyaXB0aW9uU2VsZWN0b3JzXTtcbiAgICB9XG4gICAgY29uc3QgZGlkTXV0YXRlID0gYWN0dWFsbHlNdXRhdGVTdWJzY3JpcHRpb25zKGludGVybmFsU3RhdGUuY3VycmVudFN1YnNjcmlwdGlvbnMsIGFjdGlvbik7XG4gICAgbGV0IGFjdGlvblNob3VsZENvbnRpbnVlID0gdHJ1ZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwidGVzdFwiICYmIHR5cGVvZiBhY3Rpb24udHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBhY3Rpb24udHlwZSA9PT0gYCR7YXBpLnJlZHVjZXJQYXRofS9nZXRQb2xsaW5nYCkge1xuICAgICAgcmV0dXJuIFtmYWxzZSwgaW50ZXJuYWxTdGF0ZS5jdXJyZW50UG9sbHNdO1xuICAgIH1cbiAgICBpZiAoZGlkTXV0YXRlKSB7XG4gICAgICBpZiAoIXVwZGF0ZVN5bmNUaW1lcikge1xuICAgICAgICB1cGRhdGVTeW5jVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBjb25zdCBuZXdTdWJzY3JpcHRpb25zID0gc2VyaWFsaXplU3Vic2NyaXB0aW9ucyhpbnRlcm5hbFN0YXRlLmN1cnJlbnRTdWJzY3JpcHRpb25zKTtcbiAgICAgICAgICBjb25zdCBbLCBwYXRjaGVzXSA9IHByb2R1Y2VXaXRoUGF0Y2hlczIocHJldmlvdXNTdWJzY3JpcHRpb25zLCAoKSA9PiBuZXdTdWJzY3JpcHRpb25zKTtcbiAgICAgICAgICBtd0FwaTIubmV4dChhcGkuaW50ZXJuYWxBY3Rpb25zLnN1YnNjcmlwdGlvbnNVcGRhdGVkKHBhdGNoZXMpKTtcbiAgICAgICAgICBwcmV2aW91c1N1YnNjcmlwdGlvbnMgPSBuZXdTdWJzY3JpcHRpb25zO1xuICAgICAgICAgIHVwZGF0ZVN5bmNUaW1lciA9IG51bGw7XG4gICAgICAgIH0sIDUwMCk7XG4gICAgICB9XG4gICAgICBjb25zdCBpc1N1YnNjcmlwdGlvblNsaWNlQWN0aW9uID0gdHlwZW9mIGFjdGlvbi50eXBlID09IFwic3RyaW5nXCIgJiYgISFhY3Rpb24udHlwZS5zdGFydHNXaXRoKHN1YnNjcmlwdGlvbnNQcmVmaXgpO1xuICAgICAgY29uc3QgaXNBZGRpdGlvbmFsU3Vic2NyaXB0aW9uQWN0aW9uID0gcXVlcnlUaHVuay5yZWplY3RlZC5tYXRjaChhY3Rpb24pICYmIGFjdGlvbi5tZXRhLmNvbmRpdGlvbiAmJiAhIWFjdGlvbi5tZXRhLmFyZy5zdWJzY3JpYmU7XG4gICAgICBhY3Rpb25TaG91bGRDb250aW51ZSA9ICFpc1N1YnNjcmlwdGlvblNsaWNlQWN0aW9uICYmICFpc0FkZGl0aW9uYWxTdWJzY3JpcHRpb25BY3Rpb247XG4gICAgfVxuICAgIHJldHVybiBbYWN0aW9uU2hvdWxkQ29udGludWUsIGZhbHNlXTtcbiAgfTtcbn07XG5cbi8vIHNyYy9xdWVyeS9jb3JlL2J1aWxkTWlkZGxld2FyZS9jYWNoZUNvbGxlY3Rpb24udHNcbnZhciBUSElSVFlfVFdPX0JJVF9NQVhfVElNRVJfU0VDT05EUyA9IDIxNDc0ODM2NDcgLyAxZTMgLSAxO1xudmFyIGJ1aWxkQ2FjaGVDb2xsZWN0aW9uSGFuZGxlciA9ICh7XG4gIHJlZHVjZXJQYXRoLFxuICBhcGksXG4gIHF1ZXJ5VGh1bmssXG4gIGNvbnRleHQsXG4gIGludGVybmFsU3RhdGUsXG4gIHNlbGVjdG9yczoge1xuICAgIHNlbGVjdFF1ZXJ5RW50cnksXG4gICAgc2VsZWN0Q29uZmlnXG4gIH0sXG4gIGdldFJ1bm5pbmdRdWVyeVRodW5rLFxuICBtd0FwaVxufSkgPT4ge1xuICBjb25zdCB7XG4gICAgcmVtb3ZlUXVlcnlSZXN1bHQsXG4gICAgdW5zdWJzY3JpYmVRdWVyeVJlc3VsdCxcbiAgICBjYWNoZUVudHJpZXNVcHNlcnRlZFxuICB9ID0gYXBpLmludGVybmFsQWN0aW9ucztcbiAgY29uc3QgY2FuVHJpZ2dlclVuc3Vic2NyaWJlID0gaXNBbnlPZih1bnN1YnNjcmliZVF1ZXJ5UmVzdWx0Lm1hdGNoLCBxdWVyeVRodW5rLmZ1bGZpbGxlZCwgcXVlcnlUaHVuay5yZWplY3RlZCwgY2FjaGVFbnRyaWVzVXBzZXJ0ZWQubWF0Y2gpO1xuICBmdW5jdGlvbiBhbnlTdWJzY3JpcHRpb25zUmVtYWluaW5nRm9yS2V5KHF1ZXJ5Q2FjaGVLZXkpIHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb25zID0gaW50ZXJuYWxTdGF0ZS5jdXJyZW50U3Vic2NyaXB0aW9ucy5nZXQocXVlcnlDYWNoZUtleSk7XG4gICAgaWYgKCFzdWJzY3JpcHRpb25zKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGhhc1N1YnNjcmlwdGlvbnMgPSBzdWJzY3JpcHRpb25zLnNpemUgPiAwO1xuICAgIHJldHVybiBoYXNTdWJzY3JpcHRpb25zO1xuICB9XG4gIGNvbnN0IGN1cnJlbnRSZW1vdmFsVGltZW91dHMgPSB7fTtcbiAgZnVuY3Rpb24gYWJvcnRBbGxQcm9taXNlcyhwcm9taXNlTWFwKSB7XG4gICAgZm9yIChjb25zdCBwcm9taXNlIG9mIHByb21pc2VNYXAudmFsdWVzKCkpIHtcbiAgICAgIHByb21pc2U/LmFib3J0Py4oKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgaGFuZGxlciA9IChhY3Rpb24sIG13QXBpMikgPT4ge1xuICAgIGNvbnN0IHN0YXRlID0gbXdBcGkyLmdldFN0YXRlKCk7XG4gICAgY29uc3QgY29uZmlnID0gc2VsZWN0Q29uZmlnKHN0YXRlKTtcbiAgICBpZiAoY2FuVHJpZ2dlclVuc3Vic2NyaWJlKGFjdGlvbikpIHtcbiAgICAgIGxldCBxdWVyeUNhY2hlS2V5cztcbiAgICAgIGlmIChjYWNoZUVudHJpZXNVcHNlcnRlZC5tYXRjaChhY3Rpb24pKSB7XG4gICAgICAgIHF1ZXJ5Q2FjaGVLZXlzID0gYWN0aW9uLnBheWxvYWQubWFwKChlbnRyeSkgPT4gZW50cnkucXVlcnlEZXNjcmlwdGlvbi5xdWVyeUNhY2hlS2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBxdWVyeUNhY2hlS2V5XG4gICAgICAgIH0gPSB1bnN1YnNjcmliZVF1ZXJ5UmVzdWx0Lm1hdGNoKGFjdGlvbikgPyBhY3Rpb24ucGF5bG9hZCA6IGFjdGlvbi5tZXRhLmFyZztcbiAgICAgICAgcXVlcnlDYWNoZUtleXMgPSBbcXVlcnlDYWNoZUtleV07XG4gICAgICB9XG4gICAgICBoYW5kbGVVbnN1YnNjcmliZU1hbnkocXVlcnlDYWNoZUtleXMsIG13QXBpMiwgY29uZmlnKTtcbiAgICB9XG4gICAgaWYgKGFwaS51dGlsLnJlc2V0QXBpU3RhdGUubWF0Y2goYWN0aW9uKSkge1xuICAgICAgZm9yIChjb25zdCBba2V5LCB0aW1lb3V0XSBvZiBPYmplY3QuZW50cmllcyhjdXJyZW50UmVtb3ZhbFRpbWVvdXRzKSkge1xuICAgICAgICBpZiAodGltZW91dCkgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICBkZWxldGUgY3VycmVudFJlbW92YWxUaW1lb3V0c1trZXldO1xuICAgICAgfVxuICAgICAgYWJvcnRBbGxQcm9taXNlcyhpbnRlcm5hbFN0YXRlLnJ1bm5pbmdRdWVyaWVzKTtcbiAgICAgIGFib3J0QWxsUHJvbWlzZXMoaW50ZXJuYWxTdGF0ZS5ydW5uaW5nTXV0YXRpb25zKTtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQuaGFzUmVoeWRyYXRpb25JbmZvKGFjdGlvbikpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcXVlcmllc1xuICAgICAgfSA9IGNvbnRleHQuZXh0cmFjdFJlaHlkcmF0aW9uSW5mbyhhY3Rpb24pO1xuICAgICAgaGFuZGxlVW5zdWJzY3JpYmVNYW55KE9iamVjdC5rZXlzKHF1ZXJpZXMpLCBtd0FwaTIsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBoYW5kbGVVbnN1YnNjcmliZU1hbnkoY2FjaGVLZXlzLCBhcGkyLCBjb25maWcpIHtcbiAgICBjb25zdCBzdGF0ZSA9IGFwaTIuZ2V0U3RhdGUoKTtcbiAgICBmb3IgKGNvbnN0IHF1ZXJ5Q2FjaGVLZXkgb2YgY2FjaGVLZXlzKSB7XG4gICAgICBjb25zdCBlbnRyeSA9IHNlbGVjdFF1ZXJ5RW50cnkoc3RhdGUsIHF1ZXJ5Q2FjaGVLZXkpO1xuICAgICAgaWYgKGVudHJ5Py5lbmRwb2ludE5hbWUpIHtcbiAgICAgICAgaGFuZGxlVW5zdWJzY3JpYmUocXVlcnlDYWNoZUtleSwgZW50cnkuZW5kcG9pbnROYW1lLCBhcGkyLCBjb25maWcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVVbnN1YnNjcmliZShxdWVyeUNhY2hlS2V5LCBlbmRwb2ludE5hbWUsIGFwaTIsIGNvbmZpZykge1xuICAgIGNvbnN0IGVuZHBvaW50RGVmaW5pdGlvbiA9IGNvbnRleHQuZW5kcG9pbnREZWZpbml0aW9uc1tlbmRwb2ludE5hbWVdO1xuICAgIGNvbnN0IGtlZXBVbnVzZWREYXRhRm9yID0gZW5kcG9pbnREZWZpbml0aW9uPy5rZWVwVW51c2VkRGF0YUZvciA/PyBjb25maWcua2VlcFVudXNlZERhdGFGb3I7XG4gICAgaWYgKGtlZXBVbnVzZWREYXRhRm9yID09PSBJbmZpbml0eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBmaW5hbEtlZXBVbnVzZWREYXRhRm9yID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oa2VlcFVudXNlZERhdGFGb3IsIFRISVJUWV9UV09fQklUX01BWF9USU1FUl9TRUNPTkRTKSk7XG4gICAgaWYgKCFhbnlTdWJzY3JpcHRpb25zUmVtYWluaW5nRm9yS2V5KHF1ZXJ5Q2FjaGVLZXkpKSB7XG4gICAgICBjb25zdCBjdXJyZW50VGltZW91dCA9IGN1cnJlbnRSZW1vdmFsVGltZW91dHNbcXVlcnlDYWNoZUtleV07XG4gICAgICBpZiAoY3VycmVudFRpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGN1cnJlbnRUaW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRSZW1vdmFsVGltZW91dHNbcXVlcnlDYWNoZUtleV0gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKCFhbnlTdWJzY3JpcHRpb25zUmVtYWluaW5nRm9yS2V5KHF1ZXJ5Q2FjaGVLZXkpKSB7XG4gICAgICAgICAgY29uc3QgZW50cnkgPSBzZWxlY3RRdWVyeUVudHJ5KGFwaTIuZ2V0U3RhdGUoKSwgcXVlcnlDYWNoZUtleSk7XG4gICAgICAgICAgaWYgKGVudHJ5Py5lbmRwb2ludE5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bm5pbmdRdWVyeSA9IGFwaTIuZGlzcGF0Y2goZ2V0UnVubmluZ1F1ZXJ5VGh1bmsoZW50cnkuZW5kcG9pbnROYW1lLCBlbnRyeS5vcmlnaW5hbEFyZ3MpKTtcbiAgICAgICAgICAgIHJ1bm5pbmdRdWVyeT8uYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXBpMi5kaXNwYXRjaChyZW1vdmVRdWVyeVJlc3VsdCh7XG4gICAgICAgICAgICBxdWVyeUNhY2hlS2V5XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBjdXJyZW50UmVtb3ZhbFRpbWVvdXRzW3F1ZXJ5Q2FjaGVLZXldO1xuICAgICAgfSwgZmluYWxLZWVwVW51c2VkRGF0YUZvciAqIDFlMyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBoYW5kbGVyO1xufTtcblxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRNaWRkbGV3YXJlL2NhY2hlTGlmZWN5Y2xlLnRzXG52YXIgbmV2ZXJSZXNvbHZlZEVycm9yID0gbmV3IEVycm9yKFwiUHJvbWlzZSBuZXZlciByZXNvbHZlZCBiZWZvcmUgY2FjaGVFbnRyeVJlbW92ZWQuXCIpO1xudmFyIGJ1aWxkQ2FjaGVMaWZlY3ljbGVIYW5kbGVyID0gKHtcbiAgYXBpLFxuICByZWR1Y2VyUGF0aCxcbiAgY29udGV4dCxcbiAgcXVlcnlUaHVuayxcbiAgbXV0YXRpb25UaHVuayxcbiAgaW50ZXJuYWxTdGF0ZSxcbiAgc2VsZWN0b3JzOiB7XG4gICAgc2VsZWN0UXVlcnlFbnRyeSxcbiAgICBzZWxlY3RBcGlTdGF0ZVxuICB9XG59KSA9PiB7XG4gIGNvbnN0IGlzUXVlcnlUaHVuayA9IGlzQXN5bmNUaHVua0FjdGlvbihxdWVyeVRodW5rKTtcbiAgY29uc3QgaXNNdXRhdGlvblRodW5rID0gaXNBc3luY1RodW5rQWN0aW9uKG11dGF0aW9uVGh1bmspO1xuICBjb25zdCBpc0Z1bGZpbGxlZFRodW5rID0gaXNGdWxmaWxsZWQocXVlcnlUaHVuaywgbXV0YXRpb25UaHVuayk7XG4gIGNvbnN0IGxpZmVjeWNsZU1hcCA9IHt9O1xuICBmdW5jdGlvbiByZXNvbHZlTGlmZWN5Y2xlRW50cnkoY2FjaGVLZXksIGRhdGEsIG1ldGEpIHtcbiAgICBjb25zdCBsaWZlY3ljbGUgPSBsaWZlY3ljbGVNYXBbY2FjaGVLZXldO1xuICAgIGlmIChsaWZlY3ljbGU/LnZhbHVlUmVzb2x2ZWQpIHtcbiAgICAgIGxpZmVjeWNsZS52YWx1ZVJlc29sdmVkKHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgbWV0YVxuICAgICAgfSk7XG4gICAgICBkZWxldGUgbGlmZWN5Y2xlLnZhbHVlUmVzb2x2ZWQ7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZUxpZmVjeWNsZUVudHJ5KGNhY2hlS2V5KSB7XG4gICAgY29uc3QgbGlmZWN5Y2xlID0gbGlmZWN5Y2xlTWFwW2NhY2hlS2V5XTtcbiAgICBpZiAobGlmZWN5Y2xlKSB7XG4gICAgICBkZWxldGUgbGlmZWN5Y2xlTWFwW2NhY2hlS2V5XTtcbiAgICAgIGxpZmVjeWNsZS5jYWNoZUVudHJ5UmVtb3ZlZCgpO1xuICAgIH1cbiAgfVxuICBjb25zdCBoYW5kbGVyID0gKGFjdGlvbiwgbXdBcGksIHN0YXRlQmVmb3JlKSA9PiB7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBnZXRDYWNoZUtleShhY3Rpb24pO1xuICAgIGZ1bmN0aW9uIGNoZWNrRm9yTmV3Q2FjaGVLZXkoZW5kcG9pbnROYW1lLCBjYWNoZUtleTIsIHJlcXVlc3RJZCwgb3JpZ2luYWxBcmdzKSB7XG4gICAgICBjb25zdCBvbGRFbnRyeSA9IHNlbGVjdFF1ZXJ5RW50cnkoc3RhdGVCZWZvcmUsIGNhY2hlS2V5Mik7XG4gICAgICBjb25zdCBuZXdFbnRyeSA9IHNlbGVjdFF1ZXJ5RW50cnkobXdBcGkuZ2V0U3RhdGUoKSwgY2FjaGVLZXkyKTtcbiAgICAgIGlmICghb2xkRW50cnkgJiYgbmV3RW50cnkpIHtcbiAgICAgICAgaGFuZGxlTmV3S2V5KGVuZHBvaW50TmFtZSwgb3JpZ2luYWxBcmdzLCBjYWNoZUtleTIsIG13QXBpLCByZXF1ZXN0SWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocXVlcnlUaHVuay5wZW5kaW5nLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIGNoZWNrRm9yTmV3Q2FjaGVLZXkoYWN0aW9uLm1ldGEuYXJnLmVuZHBvaW50TmFtZSwgY2FjaGVLZXksIGFjdGlvbi5tZXRhLnJlcXVlc3RJZCwgYWN0aW9uLm1ldGEuYXJnLm9yaWdpbmFsQXJncyk7XG4gICAgfSBlbHNlIGlmIChhcGkuaW50ZXJuYWxBY3Rpb25zLmNhY2hlRW50cmllc1Vwc2VydGVkLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIGZvciAoY29uc3Qge1xuICAgICAgICBxdWVyeURlc2NyaXB0aW9uLFxuICAgICAgICB2YWx1ZVxuICAgICAgfSBvZiBhY3Rpb24ucGF5bG9hZCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZW5kcG9pbnROYW1lLFxuICAgICAgICAgIG9yaWdpbmFsQXJncyxcbiAgICAgICAgICBxdWVyeUNhY2hlS2V5XG4gICAgICAgIH0gPSBxdWVyeURlc2NyaXB0aW9uO1xuICAgICAgICBjaGVja0Zvck5ld0NhY2hlS2V5KGVuZHBvaW50TmFtZSwgcXVlcnlDYWNoZUtleSwgYWN0aW9uLm1ldGEucmVxdWVzdElkLCBvcmlnaW5hbEFyZ3MpO1xuICAgICAgICByZXNvbHZlTGlmZWN5Y2xlRW50cnkocXVlcnlDYWNoZUtleSwgdmFsdWUsIHt9KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG11dGF0aW9uVGh1bmsucGVuZGluZy5tYXRjaChhY3Rpb24pKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IG13QXBpLmdldFN0YXRlKClbcmVkdWNlclBhdGhdLm11dGF0aW9uc1tjYWNoZUtleV07XG4gICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgaGFuZGxlTmV3S2V5KGFjdGlvbi5tZXRhLmFyZy5lbmRwb2ludE5hbWUsIGFjdGlvbi5tZXRhLmFyZy5vcmlnaW5hbEFyZ3MsIGNhY2hlS2V5LCBtd0FwaSwgYWN0aW9uLm1ldGEucmVxdWVzdElkKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzRnVsZmlsbGVkVGh1bmsoYWN0aW9uKSkge1xuICAgICAgcmVzb2x2ZUxpZmVjeWNsZUVudHJ5KGNhY2hlS2V5LCBhY3Rpb24ucGF5bG9hZCwgYWN0aW9uLm1ldGEuYmFzZVF1ZXJ5TWV0YSk7XG4gICAgfSBlbHNlIGlmIChhcGkuaW50ZXJuYWxBY3Rpb25zLnJlbW92ZVF1ZXJ5UmVzdWx0Lm1hdGNoKGFjdGlvbikgfHwgYXBpLmludGVybmFsQWN0aW9ucy5yZW1vdmVNdXRhdGlvblJlc3VsdC5tYXRjaChhY3Rpb24pKSB7XG4gICAgICByZW1vdmVMaWZlY3ljbGVFbnRyeShjYWNoZUtleSk7XG4gICAgfSBlbHNlIGlmIChhcGkudXRpbC5yZXNldEFwaVN0YXRlLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIGZvciAoY29uc3QgY2FjaGVLZXkyIG9mIE9iamVjdC5rZXlzKGxpZmVjeWNsZU1hcCkpIHtcbiAgICAgICAgcmVtb3ZlTGlmZWN5Y2xlRW50cnkoY2FjaGVLZXkyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGdldENhY2hlS2V5KGFjdGlvbikge1xuICAgIGlmIChpc1F1ZXJ5VGh1bmsoYWN0aW9uKSkgcmV0dXJuIGFjdGlvbi5tZXRhLmFyZy5xdWVyeUNhY2hlS2V5O1xuICAgIGlmIChpc011dGF0aW9uVGh1bmsoYWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGFjdGlvbi5tZXRhLmFyZy5maXhlZENhY2hlS2V5ID8/IGFjdGlvbi5tZXRhLnJlcXVlc3RJZDtcbiAgICB9XG4gICAgaWYgKGFwaS5pbnRlcm5hbEFjdGlvbnMucmVtb3ZlUXVlcnlSZXN1bHQubWF0Y2goYWN0aW9uKSkgcmV0dXJuIGFjdGlvbi5wYXlsb2FkLnF1ZXJ5Q2FjaGVLZXk7XG4gICAgaWYgKGFwaS5pbnRlcm5hbEFjdGlvbnMucmVtb3ZlTXV0YXRpb25SZXN1bHQubWF0Y2goYWN0aW9uKSkgcmV0dXJuIGdldE11dGF0aW9uQ2FjaGVLZXkoYWN0aW9uLnBheWxvYWQpO1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZU5ld0tleShlbmRwb2ludE5hbWUsIG9yaWdpbmFsQXJncywgcXVlcnlDYWNoZUtleSwgbXdBcGksIHJlcXVlc3RJZCkge1xuICAgIGNvbnN0IGVuZHBvaW50RGVmaW5pdGlvbiA9IGNvbnRleHQuZW5kcG9pbnREZWZpbml0aW9uc1tlbmRwb2ludE5hbWVdO1xuICAgIGNvbnN0IG9uQ2FjaGVFbnRyeUFkZGVkID0gZW5kcG9pbnREZWZpbml0aW9uPy5vbkNhY2hlRW50cnlBZGRlZDtcbiAgICBpZiAoIW9uQ2FjaGVFbnRyeUFkZGVkKSByZXR1cm47XG4gICAgY29uc3QgbGlmZWN5Y2xlID0ge307XG4gICAgY29uc3QgY2FjaGVFbnRyeVJlbW92ZWQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgbGlmZWN5Y2xlLmNhY2hlRW50cnlSZW1vdmVkID0gcmVzb2x2ZTtcbiAgICB9KTtcbiAgICBjb25zdCBjYWNoZURhdGFMb2FkZWQgPSBQcm9taXNlLnJhY2UoW25ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBsaWZlY3ljbGUudmFsdWVSZXNvbHZlZCA9IHJlc29sdmU7XG4gICAgfSksIGNhY2hlRW50cnlSZW1vdmVkLnRoZW4oKCkgPT4ge1xuICAgICAgdGhyb3cgbmV2ZXJSZXNvbHZlZEVycm9yO1xuICAgIH0pXSk7XG4gICAgY2FjaGVEYXRhTG9hZGVkLmNhdGNoKCgpID0+IHtcbiAgICB9KTtcbiAgICBsaWZlY3ljbGVNYXBbcXVlcnlDYWNoZUtleV0gPSBsaWZlY3ljbGU7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBhcGkuZW5kcG9pbnRzW2VuZHBvaW50TmFtZV0uc2VsZWN0KGlzQW55UXVlcnlEZWZpbml0aW9uKGVuZHBvaW50RGVmaW5pdGlvbikgPyBvcmlnaW5hbEFyZ3MgOiBxdWVyeUNhY2hlS2V5KTtcbiAgICBjb25zdCBleHRyYSA9IG13QXBpLmRpc3BhdGNoKChfLCBfXywgZXh0cmEyKSA9PiBleHRyYTIpO1xuICAgIGNvbnN0IGxpZmVjeWNsZUFwaSA9IHtcbiAgICAgIC4uLm13QXBpLFxuICAgICAgZ2V0Q2FjaGVFbnRyeTogKCkgPT4gc2VsZWN0b3IobXdBcGkuZ2V0U3RhdGUoKSksXG4gICAgICByZXF1ZXN0SWQsXG4gICAgICBleHRyYSxcbiAgICAgIHVwZGF0ZUNhY2hlZERhdGE6IGlzQW55UXVlcnlEZWZpbml0aW9uKGVuZHBvaW50RGVmaW5pdGlvbikgPyAodXBkYXRlUmVjaXBlKSA9PiBtd0FwaS5kaXNwYXRjaChhcGkudXRpbC51cGRhdGVRdWVyeURhdGEoZW5kcG9pbnROYW1lLCBvcmlnaW5hbEFyZ3MsIHVwZGF0ZVJlY2lwZSkpIDogdm9pZCAwLFxuICAgICAgY2FjaGVEYXRhTG9hZGVkLFxuICAgICAgY2FjaGVFbnRyeVJlbW92ZWRcbiAgICB9O1xuICAgIGNvbnN0IHJ1bm5pbmdIYW5kbGVyID0gb25DYWNoZUVudHJ5QWRkZWQob3JpZ2luYWxBcmdzLCBsaWZlY3ljbGVBcGkpO1xuICAgIFByb21pc2UucmVzb2x2ZShydW5uaW5nSGFuZGxlcikuY2F0Y2goKGUpID0+IHtcbiAgICAgIGlmIChlID09PSBuZXZlclJlc29sdmVkRXJyb3IpIHJldHVybjtcbiAgICAgIHRocm93IGU7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGhhbmRsZXI7XG59O1xuXG4vLyBzcmMvcXVlcnkvY29yZS9idWlsZE1pZGRsZXdhcmUvZGV2TWlkZGxld2FyZS50c1xudmFyIGJ1aWxkRGV2Q2hlY2tIYW5kbGVyID0gKHtcbiAgYXBpLFxuICBjb250ZXh0OiB7XG4gICAgYXBpVWlkXG4gIH0sXG4gIHJlZHVjZXJQYXRoXG59KSA9PiB7XG4gIHJldHVybiAoYWN0aW9uLCBtd0FwaSkgPT4ge1xuICAgIGlmIChhcGkudXRpbC5yZXNldEFwaVN0YXRlLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIG13QXBpLmRpc3BhdGNoKGFwaS5pbnRlcm5hbEFjdGlvbnMubWlkZGxld2FyZVJlZ2lzdGVyZWQoYXBpVWlkKSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICBpZiAoYXBpLmludGVybmFsQWN0aW9ucy5taWRkbGV3YXJlUmVnaXN0ZXJlZC5tYXRjaChhY3Rpb24pICYmIGFjdGlvbi5wYXlsb2FkID09PSBhcGlVaWQgJiYgbXdBcGkuZ2V0U3RhdGUoKVtyZWR1Y2VyUGF0aF0/LmNvbmZpZz8ubWlkZGxld2FyZVJlZ2lzdGVyZWQgPT09IFwiY29uZmxpY3RcIikge1xuICAgICAgICBjb25zb2xlLndhcm4oYFRoZXJlIGlzIGEgbWlzbWF0Y2ggYmV0d2VlbiBzbGljZSBhbmQgbWlkZGxld2FyZSBmb3IgdGhlIHJlZHVjZXJQYXRoIFwiJHtyZWR1Y2VyUGF0aH1cIi5cbllvdSBjYW4gb25seSBoYXZlIG9uZSBhcGkgcGVyIHJlZHVjZXIgcGF0aCwgdGhpcyB3aWxsIGxlYWQgdG8gY3Jhc2hlcyBpbiB2YXJpb3VzIHNpdHVhdGlvbnMhJHtyZWR1Y2VyUGF0aCA9PT0gXCJhcGlcIiA/IGBcbklmIHlvdSBoYXZlIG11bHRpcGxlIGFwaXMsIHlvdSAqaGF2ZSogdG8gc3BlY2lmeSB0aGUgcmVkdWNlclBhdGggb3B0aW9uIHdoZW4gdXNpbmcgY3JlYXRlQXBpIWAgOiBcIlwifWApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG5cbi8vIHNyYy9xdWVyeS9jb3JlL2J1aWxkTWlkZGxld2FyZS9pbnZhbGlkYXRpb25CeVRhZ3MudHNcbnZhciBidWlsZEludmFsaWRhdGlvbkJ5VGFnc0hhbmRsZXIgPSAoe1xuICByZWR1Y2VyUGF0aCxcbiAgY29udGV4dCxcbiAgY29udGV4dDoge1xuICAgIGVuZHBvaW50RGVmaW5pdGlvbnNcbiAgfSxcbiAgbXV0YXRpb25UaHVuayxcbiAgcXVlcnlUaHVuayxcbiAgYXBpLFxuICBhc3NlcnRUYWdUeXBlLFxuICByZWZldGNoUXVlcnksXG4gIGludGVybmFsU3RhdGVcbn0pID0+IHtcbiAgY29uc3Qge1xuICAgIHJlbW92ZVF1ZXJ5UmVzdWx0XG4gIH0gPSBhcGkuaW50ZXJuYWxBY3Rpb25zO1xuICBjb25zdCBpc1RodW5rQWN0aW9uV2l0aFRhZ3MgPSBpc0FueU9mKGlzRnVsZmlsbGVkKG11dGF0aW9uVGh1bmspLCBpc1JlamVjdGVkV2l0aFZhbHVlKG11dGF0aW9uVGh1bmspKTtcbiAgY29uc3QgaXNRdWVyeUVuZCA9IGlzQW55T2YoaXNGdWxmaWxsZWQobXV0YXRpb25UaHVuaywgcXVlcnlUaHVuayksIGlzUmVqZWN0ZWQobXV0YXRpb25UaHVuaywgcXVlcnlUaHVuaykpO1xuICBsZXQgcGVuZGluZ1RhZ0ludmFsaWRhdGlvbnMgPSBbXTtcbiAgY29uc3QgaGFuZGxlciA9IChhY3Rpb24sIG13QXBpKSA9PiB7XG4gICAgaWYgKGlzVGh1bmtBY3Rpb25XaXRoVGFncyhhY3Rpb24pKSB7XG4gICAgICBpbnZhbGlkYXRlVGFncyhjYWxjdWxhdGVQcm92aWRlZEJ5VGh1bmsoYWN0aW9uLCBcImludmFsaWRhdGVzVGFnc1wiLCBlbmRwb2ludERlZmluaXRpb25zLCBhc3NlcnRUYWdUeXBlKSwgbXdBcGkpO1xuICAgIH0gZWxzZSBpZiAoaXNRdWVyeUVuZChhY3Rpb24pKSB7XG4gICAgICBpbnZhbGlkYXRlVGFncyhbXSwgbXdBcGkpO1xuICAgIH0gZWxzZSBpZiAoYXBpLnV0aWwuaW52YWxpZGF0ZVRhZ3MubWF0Y2goYWN0aW9uKSkge1xuICAgICAgaW52YWxpZGF0ZVRhZ3MoY2FsY3VsYXRlUHJvdmlkZWRCeShhY3Rpb24ucGF5bG9hZCwgdm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBhc3NlcnRUYWdUeXBlKSwgbXdBcGkpO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gaGFzUGVuZGluZ1JlcXVlc3RzKHN0YXRlKSB7XG4gICAgY29uc3Qge1xuICAgICAgcXVlcmllcyxcbiAgICAgIG11dGF0aW9uc1xuICAgIH0gPSBzdGF0ZTtcbiAgICBmb3IgKGNvbnN0IGNhY2hlUmVjb3JkIG9mIFtxdWVyaWVzLCBtdXRhdGlvbnNdKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBjYWNoZVJlY29yZCkge1xuICAgICAgICBpZiAoY2FjaGVSZWNvcmRba2V5XT8uc3RhdHVzID09PSBcInBlbmRpbmdcIiAvKiBwZW5kaW5nICovKSByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIGludmFsaWRhdGVUYWdzKG5ld1RhZ3MsIG13QXBpKSB7XG4gICAgY29uc3Qgcm9vdFN0YXRlID0gbXdBcGkuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBzdGF0ZSA9IHJvb3RTdGF0ZVtyZWR1Y2VyUGF0aF07XG4gICAgcGVuZGluZ1RhZ0ludmFsaWRhdGlvbnMucHVzaCguLi5uZXdUYWdzKTtcbiAgICBpZiAoc3RhdGUuY29uZmlnLmludmFsaWRhdGlvbkJlaGF2aW9yID09PSBcImRlbGF5ZWRcIiAmJiBoYXNQZW5kaW5nUmVxdWVzdHMoc3RhdGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRhZ3MgPSBwZW5kaW5nVGFnSW52YWxpZGF0aW9ucztcbiAgICBwZW5kaW5nVGFnSW52YWxpZGF0aW9ucyA9IFtdO1xuICAgIGlmICh0YWdzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIGNvbnN0IHRvSW52YWxpZGF0ZSA9IGFwaS51dGlsLnNlbGVjdEludmFsaWRhdGVkQnkocm9vdFN0YXRlLCB0YWdzKTtcbiAgICBjb250ZXh0LmJhdGNoKCgpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlc0FycmF5ID0gQXJyYXkuZnJvbSh0b0ludmFsaWRhdGUudmFsdWVzKCkpO1xuICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgIHF1ZXJ5Q2FjaGVLZXlcbiAgICAgIH0gb2YgdmFsdWVzQXJyYXkpIHtcbiAgICAgICAgY29uc3QgcXVlcnlTdWJTdGF0ZSA9IHN0YXRlLnF1ZXJpZXNbcXVlcnlDYWNoZUtleV07XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvblN1YlN0YXRlID0gZ2V0T3JJbnNlcnRDb21wdXRlZChpbnRlcm5hbFN0YXRlLmN1cnJlbnRTdWJzY3JpcHRpb25zLCBxdWVyeUNhY2hlS2V5LCBjcmVhdGVOZXdNYXApO1xuICAgICAgICBpZiAocXVlcnlTdWJTdGF0ZSkge1xuICAgICAgICAgIGlmIChzdWJzY3JpcHRpb25TdWJTdGF0ZS5zaXplID09PSAwKSB7XG4gICAgICAgICAgICBtd0FwaS5kaXNwYXRjaChyZW1vdmVRdWVyeVJlc3VsdCh7XG4gICAgICAgICAgICAgIHF1ZXJ5Q2FjaGVLZXlcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHF1ZXJ5U3ViU3RhdGUuc3RhdHVzICE9PSBcInVuaW5pdGlhbGl6ZWRcIiAvKiB1bmluaXRpYWxpemVkICovKSB7XG4gICAgICAgICAgICBtd0FwaS5kaXNwYXRjaChyZWZldGNoUXVlcnkocXVlcnlTdWJTdGF0ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBoYW5kbGVyO1xufTtcblxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRNaWRkbGV3YXJlL3BvbGxpbmcudHNcbnZhciBidWlsZFBvbGxpbmdIYW5kbGVyID0gKHtcbiAgcmVkdWNlclBhdGgsXG4gIHF1ZXJ5VGh1bmssXG4gIGFwaSxcbiAgcmVmZXRjaFF1ZXJ5LFxuICBpbnRlcm5hbFN0YXRlXG59KSA9PiB7XG4gIGNvbnN0IHtcbiAgICBjdXJyZW50UG9sbHMsXG4gICAgY3VycmVudFN1YnNjcmlwdGlvbnNcbiAgfSA9IGludGVybmFsU3RhdGU7XG4gIGNvbnN0IHBlbmRpbmdQb2xsaW5nVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGxldCBwb2xsaW5nVXBkYXRlVGltZXIgPSBudWxsO1xuICBjb25zdCBoYW5kbGVyID0gKGFjdGlvbiwgbXdBcGkpID0+IHtcbiAgICBpZiAoYXBpLmludGVybmFsQWN0aW9ucy51cGRhdGVTdWJzY3JpcHRpb25PcHRpb25zLm1hdGNoKGFjdGlvbikgfHwgYXBpLmludGVybmFsQWN0aW9ucy51bnN1YnNjcmliZVF1ZXJ5UmVzdWx0Lm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIHNjaGVkdWxlUG9sbGluZ1VwZGF0ZShhY3Rpb24ucGF5bG9hZC5xdWVyeUNhY2hlS2V5LCBtd0FwaSk7XG4gICAgfVxuICAgIGlmIChxdWVyeVRodW5rLnBlbmRpbmcubWF0Y2goYWN0aW9uKSB8fCBxdWVyeVRodW5rLnJlamVjdGVkLm1hdGNoKGFjdGlvbikgJiYgYWN0aW9uLm1ldGEuY29uZGl0aW9uKSB7XG4gICAgICBzY2hlZHVsZVBvbGxpbmdVcGRhdGUoYWN0aW9uLm1ldGEuYXJnLnF1ZXJ5Q2FjaGVLZXksIG13QXBpKTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5VGh1bmsuZnVsZmlsbGVkLm1hdGNoKGFjdGlvbikgfHwgcXVlcnlUaHVuay5yZWplY3RlZC5tYXRjaChhY3Rpb24pICYmICFhY3Rpb24ubWV0YS5jb25kaXRpb24pIHtcbiAgICAgIHN0YXJ0TmV4dFBvbGwoYWN0aW9uLm1ldGEuYXJnLCBtd0FwaSk7XG4gICAgfVxuICAgIGlmIChhcGkudXRpbC5yZXNldEFwaVN0YXRlLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIGNsZWFyUG9sbHMoKTtcbiAgICAgIGlmIChwb2xsaW5nVXBkYXRlVGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHBvbGxpbmdVcGRhdGVUaW1lcik7XG4gICAgICAgIHBvbGxpbmdVcGRhdGVUaW1lciA9IG51bGw7XG4gICAgICB9XG4gICAgICBwZW5kaW5nUG9sbGluZ1VwZGF0ZXMuY2xlYXIoKTtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIHNjaGVkdWxlUG9sbGluZ1VwZGF0ZShxdWVyeUNhY2hlS2V5LCBhcGkyKSB7XG4gICAgcGVuZGluZ1BvbGxpbmdVcGRhdGVzLmFkZChxdWVyeUNhY2hlS2V5KTtcbiAgICBpZiAoIXBvbGxpbmdVcGRhdGVUaW1lcikge1xuICAgICAgcG9sbGluZ1VwZGF0ZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHBlbmRpbmdQb2xsaW5nVXBkYXRlcykge1xuICAgICAgICAgIHVwZGF0ZVBvbGxpbmdJbnRlcnZhbCh7XG4gICAgICAgICAgICBxdWVyeUNhY2hlS2V5OiBrZXlcbiAgICAgICAgICB9LCBhcGkyKTtcbiAgICAgICAgfVxuICAgICAgICBwZW5kaW5nUG9sbGluZ1VwZGF0ZXMuY2xlYXIoKTtcbiAgICAgICAgcG9sbGluZ1VwZGF0ZVRpbWVyID0gbnVsbDtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRDYWNoZUVudHJ5U3Vic2NyaXB0aW9ucyhxdWVyeUNhY2hlS2V5LCBhcGkyKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBhcGkyLmdldFN0YXRlKClbcmVkdWNlclBhdGhdO1xuICAgIGNvbnN0IHF1ZXJ5U3ViU3RhdGUgPSBzdGF0ZS5xdWVyaWVzW3F1ZXJ5Q2FjaGVLZXldO1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSBjdXJyZW50U3Vic2NyaXB0aW9ucy5nZXQocXVlcnlDYWNoZUtleSk7XG4gICAgaWYgKCFxdWVyeVN1YlN0YXRlIHx8IHF1ZXJ5U3ViU3RhdGUuc3RhdHVzID09PSBcInVuaW5pdGlhbGl6ZWRcIiAvKiB1bmluaXRpYWxpemVkICovKSByZXR1cm47XG4gICAgcmV0dXJuIHN1YnNjcmlwdGlvbnM7XG4gIH1cbiAgZnVuY3Rpb24gc3RhcnROZXh0UG9sbCh7XG4gICAgcXVlcnlDYWNoZUtleVxuICB9LCBhcGkyKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBhcGkyLmdldFN0YXRlKClbcmVkdWNlclBhdGhdO1xuICAgIGNvbnN0IHF1ZXJ5U3ViU3RhdGUgPSBzdGF0ZS5xdWVyaWVzW3F1ZXJ5Q2FjaGVLZXldO1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSBjdXJyZW50U3Vic2NyaXB0aW9ucy5nZXQocXVlcnlDYWNoZUtleSk7XG4gICAgaWYgKCFxdWVyeVN1YlN0YXRlIHx8IHF1ZXJ5U3ViU3RhdGUuc3RhdHVzID09PSBcInVuaW5pdGlhbGl6ZWRcIiAvKiB1bmluaXRpYWxpemVkICovKSByZXR1cm47XG4gICAgY29uc3Qge1xuICAgICAgbG93ZXN0UG9sbGluZ0ludGVydmFsLFxuICAgICAgc2tpcFBvbGxpbmdJZlVuZm9jdXNlZFxuICAgIH0gPSBmaW5kTG93ZXN0UG9sbGluZ0ludGVydmFsKHN1YnNjcmlwdGlvbnMpO1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGxvd2VzdFBvbGxpbmdJbnRlcnZhbCkpIHJldHVybjtcbiAgICBjb25zdCBjdXJyZW50UG9sbCA9IGN1cnJlbnRQb2xscy5nZXQocXVlcnlDYWNoZUtleSk7XG4gICAgaWYgKGN1cnJlbnRQb2xsPy50aW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQoY3VycmVudFBvbGwudGltZW91dCk7XG4gICAgICBjdXJyZW50UG9sbC50aW1lb3V0ID0gdm9pZCAwO1xuICAgIH1cbiAgICBjb25zdCBuZXh0UG9sbFRpbWVzdGFtcCA9IERhdGUubm93KCkgKyBsb3dlc3RQb2xsaW5nSW50ZXJ2YWw7XG4gICAgY3VycmVudFBvbGxzLnNldChxdWVyeUNhY2hlS2V5LCB7XG4gICAgICBuZXh0UG9sbFRpbWVzdGFtcCxcbiAgICAgIHBvbGxpbmdJbnRlcnZhbDogbG93ZXN0UG9sbGluZ0ludGVydmFsLFxuICAgICAgdGltZW91dDogc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChzdGF0ZS5jb25maWcuZm9jdXNlZCB8fCAhc2tpcFBvbGxpbmdJZlVuZm9jdXNlZCkge1xuICAgICAgICAgIGFwaTIuZGlzcGF0Y2gocmVmZXRjaFF1ZXJ5KHF1ZXJ5U3ViU3RhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGFydE5leHRQb2xsKHtcbiAgICAgICAgICBxdWVyeUNhY2hlS2V5XG4gICAgICAgIH0sIGFwaTIpO1xuICAgICAgfSwgbG93ZXN0UG9sbGluZ0ludGVydmFsKVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZVBvbGxpbmdJbnRlcnZhbCh7XG4gICAgcXVlcnlDYWNoZUtleVxuICB9LCBhcGkyKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBhcGkyLmdldFN0YXRlKClbcmVkdWNlclBhdGhdO1xuICAgIGNvbnN0IHF1ZXJ5U3ViU3RhdGUgPSBzdGF0ZS5xdWVyaWVzW3F1ZXJ5Q2FjaGVLZXldO1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSBjdXJyZW50U3Vic2NyaXB0aW9ucy5nZXQocXVlcnlDYWNoZUtleSk7XG4gICAgaWYgKCFxdWVyeVN1YlN0YXRlIHx8IHF1ZXJ5U3ViU3RhdGUuc3RhdHVzID09PSBcInVuaW5pdGlhbGl6ZWRcIiAvKiB1bmluaXRpYWxpemVkICovKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGxvd2VzdFBvbGxpbmdJbnRlcnZhbFxuICAgIH0gPSBmaW5kTG93ZXN0UG9sbGluZ0ludGVydmFsKHN1YnNjcmlwdGlvbnMpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJ0ZXN0XCIpIHtcbiAgICAgIGNvbnN0IHVwZGF0ZUNvdW50ZXJzID0gY3VycmVudFBvbGxzLnBvbGxVcGRhdGVDb3VudGVycyA/Pz0ge307XG4gICAgICB1cGRhdGVDb3VudGVyc1txdWVyeUNhY2hlS2V5XSA/Pz0gMDtcbiAgICAgIHVwZGF0ZUNvdW50ZXJzW3F1ZXJ5Q2FjaGVLZXldKys7XG4gICAgfVxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGxvd2VzdFBvbGxpbmdJbnRlcnZhbCkpIHtcbiAgICAgIGNsZWFudXBQb2xsRm9yS2V5KHF1ZXJ5Q2FjaGVLZXkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50UG9sbCA9IGN1cnJlbnRQb2xscy5nZXQocXVlcnlDYWNoZUtleSk7XG4gICAgY29uc3QgbmV4dFBvbGxUaW1lc3RhbXAgPSBEYXRlLm5vdygpICsgbG93ZXN0UG9sbGluZ0ludGVydmFsO1xuICAgIGlmICghY3VycmVudFBvbGwgfHwgbmV4dFBvbGxUaW1lc3RhbXAgPCBjdXJyZW50UG9sbC5uZXh0UG9sbFRpbWVzdGFtcCkge1xuICAgICAgc3RhcnROZXh0UG9sbCh7XG4gICAgICAgIHF1ZXJ5Q2FjaGVLZXlcbiAgICAgIH0sIGFwaTIpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjbGVhbnVwUG9sbEZvcktleShrZXkpIHtcbiAgICBjb25zdCBleGlzdGluZ1BvbGwgPSBjdXJyZW50UG9sbHMuZ2V0KGtleSk7XG4gICAgaWYgKGV4aXN0aW5nUG9sbD8udGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGV4aXN0aW5nUG9sbC50aW1lb3V0KTtcbiAgICB9XG4gICAgY3VycmVudFBvbGxzLmRlbGV0ZShrZXkpO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyUG9sbHMoKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgY3VycmVudFBvbGxzLmtleXMoKSkge1xuICAgICAgY2xlYW51cFBvbGxGb3JLZXkoa2V5KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZmluZExvd2VzdFBvbGxpbmdJbnRlcnZhbChzdWJzY3JpYmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpIHtcbiAgICBsZXQgc2tpcFBvbGxpbmdJZlVuZm9jdXNlZCA9IGZhbHNlO1xuICAgIGxldCBsb3dlc3RQb2xsaW5nSW50ZXJ2YWwgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBzdWJzY3JpYmVycy52YWx1ZXMoKSkge1xuICAgICAgaWYgKCEhZW50cnkucG9sbGluZ0ludGVydmFsKSB7XG4gICAgICAgIGxvd2VzdFBvbGxpbmdJbnRlcnZhbCA9IE1hdGgubWluKGVudHJ5LnBvbGxpbmdJbnRlcnZhbCwgbG93ZXN0UG9sbGluZ0ludGVydmFsKTtcbiAgICAgICAgc2tpcFBvbGxpbmdJZlVuZm9jdXNlZCA9IGVudHJ5LnNraXBQb2xsaW5nSWZVbmZvY3VzZWQgfHwgc2tpcFBvbGxpbmdJZlVuZm9jdXNlZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvd2VzdFBvbGxpbmdJbnRlcnZhbCxcbiAgICAgIHNraXBQb2xsaW5nSWZVbmZvY3VzZWRcbiAgICB9O1xuICB9XG4gIHJldHVybiBoYW5kbGVyO1xufTtcblxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRNaWRkbGV3YXJlL3F1ZXJ5TGlmZWN5Y2xlLnRzXG52YXIgYnVpbGRRdWVyeUxpZmVjeWNsZUhhbmRsZXIgPSAoe1xuICBhcGksXG4gIGNvbnRleHQsXG4gIHF1ZXJ5VGh1bmssXG4gIG11dGF0aW9uVGh1bmtcbn0pID0+IHtcbiAgY29uc3QgaXNQZW5kaW5nVGh1bmsgPSBpc1BlbmRpbmcocXVlcnlUaHVuaywgbXV0YXRpb25UaHVuayk7XG4gIGNvbnN0IGlzUmVqZWN0ZWRUaHVuayA9IGlzUmVqZWN0ZWQocXVlcnlUaHVuaywgbXV0YXRpb25UaHVuayk7XG4gIGNvbnN0IGlzRnVsbGZpbGxlZFRodW5rID0gaXNGdWxmaWxsZWQocXVlcnlUaHVuaywgbXV0YXRpb25UaHVuayk7XG4gIGNvbnN0IGxpZmVjeWNsZU1hcCA9IHt9O1xuICBjb25zdCBoYW5kbGVyID0gKGFjdGlvbiwgbXdBcGkpID0+IHtcbiAgICBpZiAoaXNQZW5kaW5nVGh1bmsoYWN0aW9uKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIGFyZzoge1xuICAgICAgICAgIGVuZHBvaW50TmFtZSxcbiAgICAgICAgICBvcmlnaW5hbEFyZ3NcbiAgICAgICAgfVxuICAgICAgfSA9IGFjdGlvbi5tZXRhO1xuICAgICAgY29uc3QgZW5kcG9pbnREZWZpbml0aW9uID0gY29udGV4dC5lbmRwb2ludERlZmluaXRpb25zW2VuZHBvaW50TmFtZV07XG4gICAgICBjb25zdCBvblF1ZXJ5U3RhcnRlZCA9IGVuZHBvaW50RGVmaW5pdGlvbj8ub25RdWVyeVN0YXJ0ZWQ7XG4gICAgICBpZiAob25RdWVyeVN0YXJ0ZWQpIHtcbiAgICAgICAgY29uc3QgbGlmZWN5Y2xlID0ge307XG4gICAgICAgIGNvbnN0IHF1ZXJ5RnVsZmlsbGVkID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGxpZmVjeWNsZS5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICBsaWZlY3ljbGUucmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgcXVlcnlGdWxmaWxsZWQuY2F0Y2goKCkgPT4ge1xuICAgICAgICB9KTtcbiAgICAgICAgbGlmZWN5Y2xlTWFwW3JlcXVlc3RJZF0gPSBsaWZlY3ljbGU7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gYXBpLmVuZHBvaW50c1tlbmRwb2ludE5hbWVdLnNlbGVjdChpc0FueVF1ZXJ5RGVmaW5pdGlvbihlbmRwb2ludERlZmluaXRpb24pID8gb3JpZ2luYWxBcmdzIDogcmVxdWVzdElkKTtcbiAgICAgICAgY29uc3QgZXh0cmEgPSBtd0FwaS5kaXNwYXRjaCgoXywgX18sIGV4dHJhMikgPT4gZXh0cmEyKTtcbiAgICAgICAgY29uc3QgbGlmZWN5Y2xlQXBpID0ge1xuICAgICAgICAgIC4uLm13QXBpLFxuICAgICAgICAgIGdldENhY2hlRW50cnk6ICgpID0+IHNlbGVjdG9yKG13QXBpLmdldFN0YXRlKCkpLFxuICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICBleHRyYSxcbiAgICAgICAgICB1cGRhdGVDYWNoZWREYXRhOiBpc0FueVF1ZXJ5RGVmaW5pdGlvbihlbmRwb2ludERlZmluaXRpb24pID8gKHVwZGF0ZVJlY2lwZSkgPT4gbXdBcGkuZGlzcGF0Y2goYXBpLnV0aWwudXBkYXRlUXVlcnlEYXRhKGVuZHBvaW50TmFtZSwgb3JpZ2luYWxBcmdzLCB1cGRhdGVSZWNpcGUpKSA6IHZvaWQgMCxcbiAgICAgICAgICBxdWVyeUZ1bGZpbGxlZFxuICAgICAgICB9O1xuICAgICAgICBvblF1ZXJ5U3RhcnRlZChvcmlnaW5hbEFyZ3MsIGxpZmVjeWNsZUFwaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0Z1bGxmaWxsZWRUaHVuayhhY3Rpb24pKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgYmFzZVF1ZXJ5TWV0YVxuICAgICAgfSA9IGFjdGlvbi5tZXRhO1xuICAgICAgbGlmZWN5Y2xlTWFwW3JlcXVlc3RJZF0/LnJlc29sdmUoe1xuICAgICAgICBkYXRhOiBhY3Rpb24ucGF5bG9hZCxcbiAgICAgICAgbWV0YTogYmFzZVF1ZXJ5TWV0YVxuICAgICAgfSk7XG4gICAgICBkZWxldGUgbGlmZWN5Y2xlTWFwW3JlcXVlc3RJZF07XG4gICAgfSBlbHNlIGlmIChpc1JlamVjdGVkVGh1bmsoYWN0aW9uKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIHJlamVjdGVkV2l0aFZhbHVlLFxuICAgICAgICBiYXNlUXVlcnlNZXRhXG4gICAgICB9ID0gYWN0aW9uLm1ldGE7XG4gICAgICBsaWZlY3ljbGVNYXBbcmVxdWVzdElkXT8ucmVqZWN0KHtcbiAgICAgICAgZXJyb3I6IGFjdGlvbi5wYXlsb2FkID8/IGFjdGlvbi5lcnJvcixcbiAgICAgICAgaXNVbmhhbmRsZWRFcnJvcjogIXJlamVjdGVkV2l0aFZhbHVlLFxuICAgICAgICBtZXRhOiBiYXNlUXVlcnlNZXRhXG4gICAgICB9KTtcbiAgICAgIGRlbGV0ZSBsaWZlY3ljbGVNYXBbcmVxdWVzdElkXTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBoYW5kbGVyO1xufTtcblxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRNaWRkbGV3YXJlL3dpbmRvd0V2ZW50SGFuZGxpbmcudHNcbnZhciBidWlsZFdpbmRvd0V2ZW50SGFuZGxlciA9ICh7XG4gIHJlZHVjZXJQYXRoLFxuICBjb250ZXh0LFxuICBhcGksXG4gIHJlZmV0Y2hRdWVyeSxcbiAgaW50ZXJuYWxTdGF0ZVxufSkgPT4ge1xuICBjb25zdCB7XG4gICAgcmVtb3ZlUXVlcnlSZXN1bHRcbiAgfSA9IGFwaS5pbnRlcm5hbEFjdGlvbnM7XG4gIGNvbnN0IGhhbmRsZXIgPSAoYWN0aW9uLCBtd0FwaSkgPT4ge1xuICAgIGlmIChvbkZvY3VzLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIHJlZmV0Y2hWYWxpZFF1ZXJpZXMobXdBcGksIFwicmVmZXRjaE9uRm9jdXNcIik7XG4gICAgfVxuICAgIGlmIChvbk9ubGluZS5tYXRjaChhY3Rpb24pKSB7XG4gICAgICByZWZldGNoVmFsaWRRdWVyaWVzKG13QXBpLCBcInJlZmV0Y2hPblJlY29ubmVjdFwiKTtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIHJlZmV0Y2hWYWxpZFF1ZXJpZXMoYXBpMiwgdHlwZSkge1xuICAgIGNvbnN0IHN0YXRlID0gYXBpMi5nZXRTdGF0ZSgpW3JlZHVjZXJQYXRoXTtcbiAgICBjb25zdCBxdWVyaWVzID0gc3RhdGUucXVlcmllcztcbiAgICBjb25zdCBzdWJzY3JpcHRpb25zID0gaW50ZXJuYWxTdGF0ZS5jdXJyZW50U3Vic2NyaXB0aW9ucztcbiAgICBjb250ZXh0LmJhdGNoKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgcXVlcnlDYWNoZUtleSBvZiBzdWJzY3JpcHRpb25zLmtleXMoKSkge1xuICAgICAgICBjb25zdCBxdWVyeVN1YlN0YXRlID0gcXVlcmllc1txdWVyeUNhY2hlS2V5XTtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uU3ViU3RhdGUgPSBzdWJzY3JpcHRpb25zLmdldChxdWVyeUNhY2hlS2V5KTtcbiAgICAgICAgaWYgKCFzdWJzY3JpcHRpb25TdWJTdGF0ZSB8fCAhcXVlcnlTdWJTdGF0ZSkgY29udGludWU7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IFsuLi5zdWJzY3JpcHRpb25TdWJTdGF0ZS52YWx1ZXMoKV07XG4gICAgICAgIGNvbnN0IHNob3VsZFJlZmV0Y2ggPSB2YWx1ZXMuc29tZSgoc3ViKSA9PiBzdWJbdHlwZV0gPT09IHRydWUpIHx8IHZhbHVlcy5ldmVyeSgoc3ViKSA9PiBzdWJbdHlwZV0gPT09IHZvaWQgMCkgJiYgc3RhdGUuY29uZmlnW3R5cGVdO1xuICAgICAgICBpZiAoc2hvdWxkUmVmZXRjaCkge1xuICAgICAgICAgIGlmIChzdWJzY3JpcHRpb25TdWJTdGF0ZS5zaXplID09PSAwKSB7XG4gICAgICAgICAgICBhcGkyLmRpc3BhdGNoKHJlbW92ZVF1ZXJ5UmVzdWx0KHtcbiAgICAgICAgICAgICAgcXVlcnlDYWNoZUtleVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocXVlcnlTdWJTdGF0ZS5zdGF0dXMgIT09IFwidW5pbml0aWFsaXplZFwiIC8qIHVuaW5pdGlhbGl6ZWQgKi8pIHtcbiAgICAgICAgICAgIGFwaTIuZGlzcGF0Y2gocmVmZXRjaFF1ZXJ5KHF1ZXJ5U3ViU3RhdGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gaGFuZGxlcjtcbn07XG5cbi8vIHNyYy9xdWVyeS9jb3JlL2J1aWxkTWlkZGxld2FyZS9pbmRleC50c1xuZnVuY3Rpb24gYnVpbGRNaWRkbGV3YXJlKGlucHV0KSB7XG4gIGNvbnN0IHtcbiAgICByZWR1Y2VyUGF0aCxcbiAgICBxdWVyeVRodW5rLFxuICAgIGFwaSxcbiAgICBjb250ZXh0LFxuICAgIGdldEludGVybmFsU3RhdGVcbiAgfSA9IGlucHV0O1xuICBjb25zdCB7XG4gICAgYXBpVWlkXG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCBhY3Rpb25zID0ge1xuICAgIGludmFsaWRhdGVUYWdzOiBjcmVhdGVBY3Rpb24oYCR7cmVkdWNlclBhdGh9L2ludmFsaWRhdGVUYWdzYClcbiAgfTtcbiAgY29uc3QgaXNUaGlzQXBpU2xpY2VBY3Rpb24gPSAoYWN0aW9uKSA9PiBhY3Rpb24udHlwZS5zdGFydHNXaXRoKGAke3JlZHVjZXJQYXRofS9gKTtcbiAgY29uc3QgaGFuZGxlckJ1aWxkZXJzID0gW2J1aWxkRGV2Q2hlY2tIYW5kbGVyLCBidWlsZENhY2hlQ29sbGVjdGlvbkhhbmRsZXIsIGJ1aWxkSW52YWxpZGF0aW9uQnlUYWdzSGFuZGxlciwgYnVpbGRQb2xsaW5nSGFuZGxlciwgYnVpbGRDYWNoZUxpZmVjeWNsZUhhbmRsZXIsIGJ1aWxkUXVlcnlMaWZlY3ljbGVIYW5kbGVyXTtcbiAgY29uc3QgbWlkZGxld2FyZSA9IChtd0FwaSkgPT4ge1xuICAgIGxldCBpbml0aWFsaXplZDIgPSBmYWxzZTtcbiAgICBjb25zdCBpbnRlcm5hbFN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZShtd0FwaS5kaXNwYXRjaCk7XG4gICAgY29uc3QgYnVpbGRlckFyZ3MgPSB7XG4gICAgICAuLi5pbnB1dCxcbiAgICAgIGludGVybmFsU3RhdGUsXG4gICAgICByZWZldGNoUXVlcnksXG4gICAgICBpc1RoaXNBcGlTbGljZUFjdGlvbixcbiAgICAgIG13QXBpXG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVycyA9IGhhbmRsZXJCdWlsZGVycy5tYXAoKGJ1aWxkKSA9PiBidWlsZChidWlsZGVyQXJncykpO1xuICAgIGNvbnN0IGJhdGNoZWRBY3Rpb25zSGFuZGxlciA9IGJ1aWxkQmF0Y2hlZEFjdGlvbnNIYW5kbGVyKGJ1aWxkZXJBcmdzKTtcbiAgICBjb25zdCB3aW5kb3dFdmVudHNIYW5kbGVyID0gYnVpbGRXaW5kb3dFdmVudEhhbmRsZXIoYnVpbGRlckFyZ3MpO1xuICAgIHJldHVybiAobmV4dCkgPT4ge1xuICAgICAgcmV0dXJuIChhY3Rpb24pID0+IHtcbiAgICAgICAgaWYgKCFpc0FjdGlvbihhY3Rpb24pKSB7XG4gICAgICAgICAgcmV0dXJuIG5leHQoYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWluaXRpYWxpemVkMikge1xuICAgICAgICAgIGluaXRpYWxpemVkMiA9IHRydWU7XG4gICAgICAgICAgbXdBcGkuZGlzcGF0Y2goYXBpLmludGVybmFsQWN0aW9ucy5taWRkbGV3YXJlUmVnaXN0ZXJlZChhcGlVaWQpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtd0FwaVdpdGhOZXh0ID0ge1xuICAgICAgICAgIC4uLm13QXBpLFxuICAgICAgICAgIG5leHRcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3RhdGVCZWZvcmUgPSBtd0FwaS5nZXRTdGF0ZSgpO1xuICAgICAgICBjb25zdCBbYWN0aW9uU2hvdWxkQ29udGludWUsIGludGVybmFsUHJvYmVSZXN1bHRdID0gYmF0Y2hlZEFjdGlvbnNIYW5kbGVyKGFjdGlvbiwgbXdBcGlXaXRoTmV4dCwgc3RhdGVCZWZvcmUpO1xuICAgICAgICBsZXQgcmVzO1xuICAgICAgICBpZiAoYWN0aW9uU2hvdWxkQ29udGludWUpIHtcbiAgICAgICAgICByZXMgPSBuZXh0KGFjdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzID0gaW50ZXJuYWxQcm9iZVJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISFtd0FwaS5nZXRTdGF0ZSgpW3JlZHVjZXJQYXRoXSkge1xuICAgICAgICAgIHdpbmRvd0V2ZW50c0hhbmRsZXIoYWN0aW9uLCBtd0FwaVdpdGhOZXh0LCBzdGF0ZUJlZm9yZSk7XG4gICAgICAgICAgaWYgKGlzVGhpc0FwaVNsaWNlQWN0aW9uKGFjdGlvbikgfHwgY29udGV4dC5oYXNSZWh5ZHJhdGlvbkluZm8oYWN0aW9uKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIGhhbmRsZXJzKSB7XG4gICAgICAgICAgICAgIGhhbmRsZXIoYWN0aW9uLCBtd0FwaVdpdGhOZXh0LCBzdGF0ZUJlZm9yZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9O1xuICAgIH07XG4gIH07XG4gIHJldHVybiB7XG4gICAgbWlkZGxld2FyZSxcbiAgICBhY3Rpb25zXG4gIH07XG4gIGZ1bmN0aW9uIHJlZmV0Y2hRdWVyeShxdWVyeVN1YlN0YXRlKSB7XG4gICAgcmV0dXJuIGlucHV0LmFwaS5lbmRwb2ludHNbcXVlcnlTdWJTdGF0ZS5lbmRwb2ludE5hbWVdLmluaXRpYXRlKHF1ZXJ5U3ViU3RhdGUub3JpZ2luYWxBcmdzLCB7XG4gICAgICBzdWJzY3JpYmU6IGZhbHNlLFxuICAgICAgZm9yY2VSZWZldGNoOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuLy8gc3JjL3F1ZXJ5L2NvcmUvbW9kdWxlLnRzXG52YXIgY29yZU1vZHVsZU5hbWUgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sKCk7XG52YXIgY29yZU1vZHVsZSA9ICh7XG4gIGNyZWF0ZVNlbGVjdG9yOiBjcmVhdGVTZWxlY3RvcjIgPSBjcmVhdGVTZWxlY3RvclxufSA9IHt9KSA9PiAoe1xuICBuYW1lOiBjb3JlTW9kdWxlTmFtZSxcbiAgaW5pdChhcGksIHtcbiAgICBiYXNlUXVlcnksXG4gICAgdGFnVHlwZXMsXG4gICAgcmVkdWNlclBhdGgsXG4gICAgc2VyaWFsaXplUXVlcnlBcmdzLFxuICAgIGtlZXBVbnVzZWREYXRhRm9yLFxuICAgIHJlZmV0Y2hPbk1vdW50T3JBcmdDaGFuZ2UsXG4gICAgcmVmZXRjaE9uRm9jdXMsXG4gICAgcmVmZXRjaE9uUmVjb25uZWN0LFxuICAgIGludmFsaWRhdGlvbkJlaGF2aW9yLFxuICAgIG9uU2NoZW1hRmFpbHVyZSxcbiAgICBjYXRjaFNjaGVtYUZhaWx1cmUsXG4gICAgc2tpcFNjaGVtYVZhbGlkYXRpb25cbiAgfSwgY29udGV4dCkge1xuICAgIGVuYWJsZVBhdGNoZXMoKTtcbiAgICBhc3NlcnRDYXN0KHNlcmlhbGl6ZVF1ZXJ5QXJncyk7XG4gICAgY29uc3QgYXNzZXJ0VGFnVHlwZSA9ICh0YWcpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICAgIGlmICghdGFnVHlwZXMuaW5jbHVkZXModGFnLnR5cGUpKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgVGFnIHR5cGUgJyR7dGFnLnR5cGV9JyB3YXMgdXNlZCwgYnV0IG5vdCBzcGVjaWZpZWQgaW4gXFxgdGFnVHlwZXNcXGAhYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWc7XG4gICAgfTtcbiAgICBPYmplY3QuYXNzaWduKGFwaSwge1xuICAgICAgcmVkdWNlclBhdGgsXG4gICAgICBlbmRwb2ludHM6IHt9LFxuICAgICAgaW50ZXJuYWxBY3Rpb25zOiB7XG4gICAgICAgIG9uT25saW5lLFxuICAgICAgICBvbk9mZmxpbmUsXG4gICAgICAgIG9uRm9jdXMsXG4gICAgICAgIG9uRm9jdXNMb3N0XG4gICAgICB9LFxuICAgICAgdXRpbDoge31cbiAgICB9KTtcbiAgICBjb25zdCBzZWxlY3RvcnMgPSBidWlsZFNlbGVjdG9ycyh7XG4gICAgICBzZXJpYWxpemVRdWVyeUFyZ3MsXG4gICAgICByZWR1Y2VyUGF0aCxcbiAgICAgIGNyZWF0ZVNlbGVjdG9yOiBjcmVhdGVTZWxlY3RvcjJcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBzZWxlY3RJbnZhbGlkYXRlZEJ5LFxuICAgICAgc2VsZWN0Q2FjaGVkQXJnc0ZvclF1ZXJ5LFxuICAgICAgYnVpbGRRdWVyeVNlbGVjdG9yLFxuICAgICAgYnVpbGRJbmZpbml0ZVF1ZXJ5U2VsZWN0b3IsXG4gICAgICBidWlsZE11dGF0aW9uU2VsZWN0b3JcbiAgICB9ID0gc2VsZWN0b3JzO1xuICAgIHNhZmVBc3NpZ24oYXBpLnV0aWwsIHtcbiAgICAgIHNlbGVjdEludmFsaWRhdGVkQnksXG4gICAgICBzZWxlY3RDYWNoZWRBcmdzRm9yUXVlcnlcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBxdWVyeVRodW5rLFxuICAgICAgaW5maW5pdGVRdWVyeVRodW5rLFxuICAgICAgbXV0YXRpb25UaHVuayxcbiAgICAgIHBhdGNoUXVlcnlEYXRhLFxuICAgICAgdXBkYXRlUXVlcnlEYXRhLFxuICAgICAgdXBzZXJ0UXVlcnlEYXRhLFxuICAgICAgcHJlZmV0Y2gsXG4gICAgICBidWlsZE1hdGNoVGh1bmtBY3Rpb25zXG4gICAgfSA9IGJ1aWxkVGh1bmtzKHtcbiAgICAgIGJhc2VRdWVyeSxcbiAgICAgIHJlZHVjZXJQYXRoLFxuICAgICAgY29udGV4dCxcbiAgICAgIGFwaSxcbiAgICAgIHNlcmlhbGl6ZVF1ZXJ5QXJncyxcbiAgICAgIGFzc2VydFRhZ1R5cGUsXG4gICAgICBzZWxlY3RvcnMsXG4gICAgICBvblNjaGVtYUZhaWx1cmUsXG4gICAgICBjYXRjaFNjaGVtYUZhaWx1cmUsXG4gICAgICBza2lwU2NoZW1hVmFsaWRhdGlvblxuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlZHVjZXIsXG4gICAgICBhY3Rpb25zOiBzbGljZUFjdGlvbnNcbiAgICB9ID0gYnVpbGRTbGljZSh7XG4gICAgICBjb250ZXh0LFxuICAgICAgcXVlcnlUaHVuayxcbiAgICAgIGluZmluaXRlUXVlcnlUaHVuayxcbiAgICAgIG11dGF0aW9uVGh1bmssXG4gICAgICBzZXJpYWxpemVRdWVyeUFyZ3MsXG4gICAgICByZWR1Y2VyUGF0aCxcbiAgICAgIGFzc2VydFRhZ1R5cGUsXG4gICAgICBjb25maWc6IHtcbiAgICAgICAgcmVmZXRjaE9uRm9jdXMsXG4gICAgICAgIHJlZmV0Y2hPblJlY29ubmVjdCxcbiAgICAgICAgcmVmZXRjaE9uTW91bnRPckFyZ0NoYW5nZSxcbiAgICAgICAga2VlcFVudXNlZERhdGFGb3IsXG4gICAgICAgIHJlZHVjZXJQYXRoLFxuICAgICAgICBpbnZhbGlkYXRpb25CZWhhdmlvclxuICAgICAgfVxuICAgIH0pO1xuICAgIHNhZmVBc3NpZ24oYXBpLnV0aWwsIHtcbiAgICAgIHBhdGNoUXVlcnlEYXRhLFxuICAgICAgdXBkYXRlUXVlcnlEYXRhLFxuICAgICAgdXBzZXJ0UXVlcnlEYXRhLFxuICAgICAgcHJlZmV0Y2gsXG4gICAgICByZXNldEFwaVN0YXRlOiBzbGljZUFjdGlvbnMucmVzZXRBcGlTdGF0ZSxcbiAgICAgIHVwc2VydFF1ZXJ5RW50cmllczogc2xpY2VBY3Rpb25zLmNhY2hlRW50cmllc1Vwc2VydGVkXG4gICAgfSk7XG4gICAgc2FmZUFzc2lnbihhcGkuaW50ZXJuYWxBY3Rpb25zLCBzbGljZUFjdGlvbnMpO1xuICAgIGNvbnN0IGludGVybmFsU3RhdGVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgICBjb25zdCBnZXRJbnRlcm5hbFN0YXRlID0gKGRpc3BhdGNoKSA9PiB7XG4gICAgICBjb25zdCBzdGF0ZSA9IGdldE9ySW5zZXJ0Q29tcHV0ZWQoaW50ZXJuYWxTdGF0ZU1hcCwgZGlzcGF0Y2gsICgpID0+ICh7XG4gICAgICAgIGN1cnJlbnRTdWJzY3JpcHRpb25zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgICBjdXJyZW50UG9sbHM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgICAgIHJ1bm5pbmdRdWVyaWVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgICBydW5uaW5nTXV0YXRpb25zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpXG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfTtcbiAgICBjb25zdCB7XG4gICAgICBidWlsZEluaXRpYXRlUXVlcnksXG4gICAgICBidWlsZEluaXRpYXRlSW5maW5pdGVRdWVyeSxcbiAgICAgIGJ1aWxkSW5pdGlhdGVNdXRhdGlvbixcbiAgICAgIGdldFJ1bm5pbmdNdXRhdGlvblRodW5rLFxuICAgICAgZ2V0UnVubmluZ011dGF0aW9uc1RodW5rLFxuICAgICAgZ2V0UnVubmluZ1F1ZXJpZXNUaHVuayxcbiAgICAgIGdldFJ1bm5pbmdRdWVyeVRodW5rXG4gICAgfSA9IGJ1aWxkSW5pdGlhdGUoe1xuICAgICAgcXVlcnlUaHVuayxcbiAgICAgIG11dGF0aW9uVGh1bmssXG4gICAgICBpbmZpbml0ZVF1ZXJ5VGh1bmssXG4gICAgICBhcGksXG4gICAgICBzZXJpYWxpemVRdWVyeUFyZ3MsXG4gICAgICBjb250ZXh0LFxuICAgICAgZ2V0SW50ZXJuYWxTdGF0ZVxuICAgIH0pO1xuICAgIHNhZmVBc3NpZ24oYXBpLnV0aWwsIHtcbiAgICAgIGdldFJ1bm5pbmdNdXRhdGlvblRodW5rLFxuICAgICAgZ2V0UnVubmluZ011dGF0aW9uc1RodW5rLFxuICAgICAgZ2V0UnVubmluZ1F1ZXJ5VGh1bmssXG4gICAgICBnZXRSdW5uaW5nUXVlcmllc1RodW5rXG4gICAgfSk7XG4gICAgY29uc3Qge1xuICAgICAgbWlkZGxld2FyZSxcbiAgICAgIGFjdGlvbnM6IG1pZGRsZXdhcmVBY3Rpb25zXG4gICAgfSA9IGJ1aWxkTWlkZGxld2FyZSh7XG4gICAgICByZWR1Y2VyUGF0aCxcbiAgICAgIGNvbnRleHQsXG4gICAgICBxdWVyeVRodW5rLFxuICAgICAgbXV0YXRpb25UaHVuayxcbiAgICAgIGluZmluaXRlUXVlcnlUaHVuayxcbiAgICAgIGFwaSxcbiAgICAgIGFzc2VydFRhZ1R5cGUsXG4gICAgICBzZWxlY3RvcnMsXG4gICAgICBnZXRSdW5uaW5nUXVlcnlUaHVuayxcbiAgICAgIGdldEludGVybmFsU3RhdGVcbiAgICB9KTtcbiAgICBzYWZlQXNzaWduKGFwaS51dGlsLCBtaWRkbGV3YXJlQWN0aW9ucyk7XG4gICAgc2FmZUFzc2lnbihhcGksIHtcbiAgICAgIHJlZHVjZXIsXG4gICAgICBtaWRkbGV3YXJlXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IGNvcmVNb2R1bGVOYW1lLFxuICAgICAgaW5qZWN0RW5kcG9pbnQoZW5kcG9pbnROYW1lLCBkZWZpbml0aW9uKSB7XG4gICAgICAgIGNvbnN0IGFueUFwaSA9IGFwaTtcbiAgICAgICAgY29uc3QgZW5kcG9pbnQgPSBhbnlBcGkuZW5kcG9pbnRzW2VuZHBvaW50TmFtZV0gPz89IHt9O1xuICAgICAgICBpZiAoaXNRdWVyeURlZmluaXRpb24oZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICBzYWZlQXNzaWduKGVuZHBvaW50LCB7XG4gICAgICAgICAgICBuYW1lOiBlbmRwb2ludE5hbWUsXG4gICAgICAgICAgICBzZWxlY3Q6IGJ1aWxkUXVlcnlTZWxlY3RvcihlbmRwb2ludE5hbWUsIGRlZmluaXRpb24pLFxuICAgICAgICAgICAgaW5pdGlhdGU6IGJ1aWxkSW5pdGlhdGVRdWVyeShlbmRwb2ludE5hbWUsIGRlZmluaXRpb24pXG4gICAgICAgICAgfSwgYnVpbGRNYXRjaFRodW5rQWN0aW9ucyhxdWVyeVRodW5rLCBlbmRwb2ludE5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNNdXRhdGlvbkRlZmluaXRpb24oZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICBzYWZlQXNzaWduKGVuZHBvaW50LCB7XG4gICAgICAgICAgICBuYW1lOiBlbmRwb2ludE5hbWUsXG4gICAgICAgICAgICBzZWxlY3Q6IGJ1aWxkTXV0YXRpb25TZWxlY3RvcigpLFxuICAgICAgICAgICAgaW5pdGlhdGU6IGJ1aWxkSW5pdGlhdGVNdXRhdGlvbihlbmRwb2ludE5hbWUpXG4gICAgICAgICAgfSwgYnVpbGRNYXRjaFRodW5rQWN0aW9ucyhtdXRhdGlvblRodW5rLCBlbmRwb2ludE5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbihkZWZpbml0aW9uKSkge1xuICAgICAgICAgIHNhZmVBc3NpZ24oZW5kcG9pbnQsIHtcbiAgICAgICAgICAgIG5hbWU6IGVuZHBvaW50TmFtZSxcbiAgICAgICAgICAgIHNlbGVjdDogYnVpbGRJbmZpbml0ZVF1ZXJ5U2VsZWN0b3IoZW5kcG9pbnROYW1lLCBkZWZpbml0aW9uKSxcbiAgICAgICAgICAgIGluaXRpYXRlOiBidWlsZEluaXRpYXRlSW5maW5pdGVRdWVyeShlbmRwb2ludE5hbWUsIGRlZmluaXRpb24pXG4gICAgICAgICAgfSwgYnVpbGRNYXRjaFRodW5rQWN0aW9ucyhxdWVyeVRodW5rLCBlbmRwb2ludE5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvcXVlcnkvY29yZS9pbmRleC50c1xudmFyIGNyZWF0ZUFwaSA9IC8qIEBfX1BVUkVfXyAqLyBidWlsZENyZWF0ZUFwaShjb3JlTW9kdWxlKCkpO1xuZXhwb3J0IHtcbiAgTmFtZWRTY2hlbWFFcnJvcixcbiAgUXVlcnlTdGF0dXMsXG4gIF9ORVZFUixcbiAgYnVpbGRDcmVhdGVBcGksXG4gIGNvcHlXaXRoU3RydWN0dXJhbFNoYXJpbmcsXG4gIGNvcmVNb2R1bGUsXG4gIGNvcmVNb2R1bGVOYW1lLFxuICBjcmVhdGVBcGksXG4gIGRlZmF1bHRTZXJpYWxpemVRdWVyeUFyZ3MsXG4gIGZha2VCYXNlUXVlcnksXG4gIGZldGNoQmFzZVF1ZXJ5LFxuICByZXRyeSxcbiAgc2V0dXBMaXN0ZW5lcnMsXG4gIHNraXBUb2tlblxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJ0ay1xdWVyeS5tb2Rlcm4ubWpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reduxjs/toolkit/dist/query/rtk-query.modern.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ReducerType: () => (/* binding */ ReducerType),\n/* harmony export */   SHOULD_AUTOBATCH: () => (/* binding */ SHOULD_AUTOBATCH),\n/* harmony export */   TaskAbortError: () => (/* binding */ TaskAbortError),\n/* harmony export */   Tuple: () => (/* binding */ Tuple),\n/* harmony export */   __DO_NOT_USE__ActionTypes: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.__DO_NOT_USE__ActionTypes),\n/* harmony export */   addListener: () => (/* binding */ addListener),\n/* harmony export */   applyMiddleware: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware),\n/* harmony export */   asyncThunkCreator: () => (/* binding */ asyncThunkCreator),\n/* harmony export */   autoBatchEnhancer: () => (/* binding */ autoBatchEnhancer),\n/* harmony export */   bindActionCreators: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.bindActionCreators),\n/* harmony export */   buildCreateSlice: () => (/* binding */ buildCreateSlice),\n/* harmony export */   clearAllListeners: () => (/* binding */ clearAllListeners),\n/* harmony export */   combineReducers: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers),\n/* harmony export */   combineSlices: () => (/* binding */ combineSlices),\n/* harmony export */   compose: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.compose),\n/* harmony export */   configureStore: () => (/* binding */ configureStore),\n/* harmony export */   createAction: () => (/* binding */ createAction),\n/* harmony export */   createActionCreatorInvariantMiddleware: () => (/* binding */ createActionCreatorInvariantMiddleware),\n/* harmony export */   createAsyncThunk: () => (/* binding */ createAsyncThunk),\n/* harmony export */   createDraftSafeSelector: () => (/* binding */ createDraftSafeSelector),\n/* harmony export */   createDraftSafeSelectorCreator: () => (/* binding */ createDraftSafeSelectorCreator),\n/* harmony export */   createDynamicMiddleware: () => (/* binding */ createDynamicMiddleware),\n/* harmony export */   createEntityAdapter: () => (/* binding */ createEntityAdapter),\n/* harmony export */   createImmutableStateInvariantMiddleware: () => (/* binding */ createImmutableStateInvariantMiddleware),\n/* harmony export */   createListenerMiddleware: () => (/* binding */ createListenerMiddleware),\n/* harmony export */   createNextState: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.produce),\n/* harmony export */   createReducer: () => (/* binding */ createReducer),\n/* harmony export */   createSelector: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.createSelector),\n/* harmony export */   createSelectorCreator: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.createSelectorCreator),\n/* harmony export */   createSerializableStateInvariantMiddleware: () => (/* binding */ createSerializableStateInvariantMiddleware),\n/* harmony export */   createSlice: () => (/* binding */ createSlice),\n/* harmony export */   createStore: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.createStore),\n/* harmony export */   current: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.current),\n/* harmony export */   findNonSerializableValue: () => (/* binding */ findNonSerializableValue),\n/* harmony export */   formatProdErrorMessage: () => (/* binding */ formatProdErrorMessage),\n/* harmony export */   freeze: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.freeze),\n/* harmony export */   isAction: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.isAction),\n/* harmony export */   isActionCreator: () => (/* binding */ isActionCreator),\n/* harmony export */   isAllOf: () => (/* binding */ isAllOf),\n/* harmony export */   isAnyOf: () => (/* binding */ isAnyOf),\n/* harmony export */   isAsyncThunkAction: () => (/* binding */ isAsyncThunkAction),\n/* harmony export */   isDraft: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.isDraft),\n/* harmony export */   isFluxStandardAction: () => (/* binding */ isFSA),\n/* harmony export */   isFulfilled: () => (/* binding */ isFulfilled),\n/* harmony export */   isImmutableDefault: () => (/* binding */ isImmutableDefault),\n/* harmony export */   isPending: () => (/* binding */ isPending),\n/* harmony export */   isPlain: () => (/* binding */ isPlain),\n/* harmony export */   isPlainObject: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.isPlainObject),\n/* harmony export */   isRejected: () => (/* binding */ isRejected),\n/* harmony export */   isRejectedWithValue: () => (/* binding */ isRejectedWithValue),\n/* harmony export */   legacy_createStore: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.legacy_createStore),\n/* harmony export */   lruMemoize: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.lruMemoize),\n/* harmony export */   miniSerializeError: () => (/* binding */ miniSerializeError),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   original: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.original),\n/* harmony export */   prepareAutoBatched: () => (/* binding */ prepareAutoBatched),\n/* harmony export */   removeListener: () => (/* binding */ removeListener),\n/* harmony export */   unwrapResult: () => (/* binding */ unwrapResult),\n/* harmony export */   weakMapMemoize: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.weakMapMemoize)\n/* harmony export */ });\n/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! redux */ \"(ssr)/./node_modules/redux/dist/redux.mjs\");\n/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/immer.mjs\");\n/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! reselect */ \"(ssr)/./node_modules/reselect/dist/reselect.mjs\");\n/* harmony import */ var redux_thunk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! redux-thunk */ \"(ssr)/./node_modules/redux-thunk/dist/redux-thunk.mjs\");\n// src/index.ts\n\n\n\n\n// src/createDraftSafeSelector.ts\n\n\nvar createDraftSafeSelectorCreator = (...args) => {\n  const createSelector2 = (0,reselect__WEBPACK_IMPORTED_MODULE_1__.createSelectorCreator)(...args);\n  const createDraftSafeSelector2 = Object.assign((...args2) => {\n    const selector = createSelector2(...args2);\n    const wrappedSelector = (value, ...rest) => selector((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(value) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.current)(value) : value, ...rest);\n    Object.assign(wrappedSelector, selector);\n    return wrappedSelector;\n  }, {\n    withTypes: () => createDraftSafeSelector2\n  });\n  return createDraftSafeSelector2;\n};\nvar createDraftSafeSelector = /* @__PURE__ */ createDraftSafeSelectorCreator(reselect__WEBPACK_IMPORTED_MODULE_1__.weakMapMemoize);\n\n// src/configureStore.ts\n\n\n// src/devtoolsExtension.ts\n\nvar composeWithDevTools = typeof window !== \"undefined\" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {\n  if (arguments.length === 0) return void 0;\n  if (typeof arguments[0] === \"object\") return redux__WEBPACK_IMPORTED_MODULE_0__.compose;\n  return redux__WEBPACK_IMPORTED_MODULE_0__.compose.apply(null, arguments);\n};\nvar devToolsEnhancer = typeof window !== \"undefined\" && window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__ : function() {\n  return function(noop3) {\n    return noop3;\n  };\n};\n\n// src/getDefaultMiddleware.ts\n\n\n// src/createAction.ts\n\n\n// src/tsHelpers.ts\nvar hasMatchFunction = (v) => {\n  return v && typeof v.match === \"function\";\n};\n\n// src/createAction.ts\nfunction createAction(type, prepareAction) {\n  function actionCreator(...args) {\n    if (prepareAction) {\n      let prepared = prepareAction(...args);\n      if (!prepared) {\n        throw new Error( false ? 0 : \"prepareAction did not return an object\");\n      }\n      return {\n        type,\n        payload: prepared.payload,\n        ...\"meta\" in prepared && {\n          meta: prepared.meta\n        },\n        ...\"error\" in prepared && {\n          error: prepared.error\n        }\n      };\n    }\n    return {\n      type,\n      payload: args[0]\n    };\n  }\n  actionCreator.toString = () => `${type}`;\n  actionCreator.type = type;\n  actionCreator.match = (action) => (0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action) && action.type === type;\n  return actionCreator;\n}\nfunction isActionCreator(action) {\n  return typeof action === \"function\" && \"type\" in action && // hasMatchFunction only wants Matchers but I don't see the point in rewriting it\n  hasMatchFunction(action);\n}\nfunction isFSA(action) {\n  return (0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action) && Object.keys(action).every(isValidKey);\n}\nfunction isValidKey(key) {\n  return [\"type\", \"payload\", \"error\", \"meta\"].indexOf(key) > -1;\n}\n\n// src/actionCreatorInvariantMiddleware.ts\nfunction getMessage(type) {\n  const splitType = type ? `${type}`.split(\"/\") : [];\n  const actionName = splitType[splitType.length - 1] || \"actionCreator\";\n  return `Detected an action creator with type \"${type || \"unknown\"}\" being dispatched. \nMake sure you're calling the action creator before dispatching, i.e. \\`dispatch(${actionName}())\\` instead of \\`dispatch(${actionName})\\`. This is necessary even if the action has no payload.`;\n}\nfunction createActionCreatorInvariantMiddleware(options = {}) {\n  if (false) {}\n  const {\n    isActionCreator: isActionCreator2 = isActionCreator\n  } = options;\n  return () => (next) => (action) => {\n    if (isActionCreator2(action)) {\n      console.warn(getMessage(action.type));\n    }\n    return next(action);\n  };\n}\n\n// src/utils.ts\n\nfunction getTimeMeasureUtils(maxDelay, fnName) {\n  let elapsed = 0;\n  return {\n    measureTime(fn) {\n      const started = Date.now();\n      try {\n        return fn();\n      } finally {\n        const finished = Date.now();\n        elapsed += finished - started;\n      }\n    },\n    warnIfExceeded() {\n      if (elapsed > maxDelay) {\n        console.warn(`${fnName} took ${elapsed}ms, which is more than the warning threshold of ${maxDelay}ms. \nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\nIt is disabled in production builds, so you don't need to worry about that.`);\n      }\n    }\n  };\n}\nvar Tuple = class _Tuple extends Array {\n  constructor(...items) {\n    super(...items);\n    Object.setPrototypeOf(this, _Tuple.prototype);\n  }\n  static get [Symbol.species]() {\n    return _Tuple;\n  }\n  concat(...arr) {\n    return super.concat.apply(this, arr);\n  }\n  prepend(...arr) {\n    if (arr.length === 1 && Array.isArray(arr[0])) {\n      return new _Tuple(...arr[0].concat(this));\n    }\n    return new _Tuple(...arr.concat(this));\n  }\n};\nfunction freezeDraftable(val) {\n  return (0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(val) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(val, () => {\n  }) : val;\n}\nfunction getOrInsertComputed(map, key, compute) {\n  if (map.has(key)) return map.get(key);\n  return map.set(key, compute(key)).get(key);\n}\n\n// src/immutableStateInvariantMiddleware.ts\nfunction isImmutableDefault(value) {\n  return typeof value !== \"object\" || value == null || Object.isFrozen(value);\n}\nfunction trackForMutations(isImmutable, ignorePaths, obj) {\n  const trackedProperties = trackProperties(isImmutable, ignorePaths, obj);\n  return {\n    detectMutations() {\n      return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);\n    }\n  };\n}\nfunction trackProperties(isImmutable, ignorePaths = [], obj, path = \"\", checkedObjects = /* @__PURE__ */ new Set()) {\n  const tracked = {\n    value: obj\n  };\n  if (!isImmutable(obj) && !checkedObjects.has(obj)) {\n    checkedObjects.add(obj);\n    tracked.children = {};\n    for (const key in obj) {\n      const childPath = path ? path + \".\" + key : key;\n      if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {\n        continue;\n      }\n      tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);\n    }\n  }\n  return tracked;\n}\nfunction detectMutations(isImmutable, ignoredPaths = [], trackedProperty, obj, sameParentRef = false, path = \"\") {\n  const prevObj = trackedProperty ? trackedProperty.value : void 0;\n  const sameRef = prevObj === obj;\n  if (sameParentRef && !sameRef && !Number.isNaN(obj)) {\n    return {\n      wasMutated: true,\n      path\n    };\n  }\n  if (isImmutable(prevObj) || isImmutable(obj)) {\n    return {\n      wasMutated: false\n    };\n  }\n  const keysToDetect = {};\n  for (let key in trackedProperty.children) {\n    keysToDetect[key] = true;\n  }\n  for (let key in obj) {\n    keysToDetect[key] = true;\n  }\n  const hasIgnoredPaths = ignoredPaths.length > 0;\n  for (let key in keysToDetect) {\n    const nestedPath = path ? path + \".\" + key : key;\n    if (hasIgnoredPaths) {\n      const hasMatches = ignoredPaths.some((ignored) => {\n        if (ignored instanceof RegExp) {\n          return ignored.test(nestedPath);\n        }\n        return nestedPath === ignored;\n      });\n      if (hasMatches) {\n        continue;\n      }\n    }\n    const result = detectMutations(isImmutable, ignoredPaths, trackedProperty.children[key], obj[key], sameRef, nestedPath);\n    if (result.wasMutated) {\n      return result;\n    }\n  }\n  return {\n    wasMutated: false\n  };\n}\nfunction createImmutableStateInvariantMiddleware(options = {}) {\n  if (false) {} else {\n    let stringify2 = function(obj, serializer, indent, decycler) {\n      return JSON.stringify(obj, getSerialize2(serializer, decycler), indent);\n    }, getSerialize2 = function(serializer, decycler) {\n      let stack = [], keys = [];\n      if (!decycler) decycler = function(_, value) {\n        if (stack[0] === value) return \"[Circular ~]\";\n        return \"[Circular ~.\" + keys.slice(0, stack.indexOf(value)).join(\".\") + \"]\";\n      };\n      return function(key, value) {\n        if (stack.length > 0) {\n          var thisPos = stack.indexOf(this);\n          ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);\n          ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);\n          if (~stack.indexOf(value)) value = decycler.call(this, key, value);\n        } else stack.push(value);\n        return serializer == null ? value : serializer.call(this, key, value);\n      };\n    };\n    var stringify = stringify2, getSerialize = getSerialize2;\n    let {\n      isImmutable = isImmutableDefault,\n      ignoredPaths,\n      warnAfter = 32\n    } = options;\n    const track = trackForMutations.bind(null, isImmutable, ignoredPaths);\n    return ({\n      getState\n    }) => {\n      let state = getState();\n      let tracker = track(state);\n      let result;\n      return (next) => (action) => {\n        const measureUtils = getTimeMeasureUtils(warnAfter, \"ImmutableStateInvariantMiddleware\");\n        measureUtils.measureTime(() => {\n          state = getState();\n          result = tracker.detectMutations();\n          tracker = track(state);\n          if (result.wasMutated) {\n            throw new Error( false ? 0 : `A state mutation was detected between dispatches, in the path '${result.path || \"\"}'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);\n          }\n        });\n        const dispatchedAction = next(action);\n        measureUtils.measureTime(() => {\n          state = getState();\n          result = tracker.detectMutations();\n          tracker = track(state);\n          if (result.wasMutated) {\n            throw new Error( false ? 0 : `A state mutation was detected inside a dispatch, in the path: ${result.path || \"\"}. Take a look at the reducer(s) handling the action ${stringify2(action)}. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);\n          }\n        });\n        measureUtils.warnIfExceeded();\n        return dispatchedAction;\n      };\n    };\n  }\n}\n\n// src/serializableStateInvariantMiddleware.ts\n\nfunction isPlain(val) {\n  const type = typeof val;\n  return val == null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(val) || (0,redux__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(val);\n}\nfunction findNonSerializableValue(value, path = \"\", isSerializable = isPlain, getEntries, ignoredPaths = [], cache) {\n  let foundNestedSerializable;\n  if (!isSerializable(value)) {\n    return {\n      keyPath: path || \"<root>\",\n      value\n    };\n  }\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  if (cache?.has(value)) return false;\n  const entries = getEntries != null ? getEntries(value) : Object.entries(value);\n  const hasIgnoredPaths = ignoredPaths.length > 0;\n  for (const [key, nestedValue] of entries) {\n    const nestedPath = path ? path + \".\" + key : key;\n    if (hasIgnoredPaths) {\n      const hasMatches = ignoredPaths.some((ignored) => {\n        if (ignored instanceof RegExp) {\n          return ignored.test(nestedPath);\n        }\n        return nestedPath === ignored;\n      });\n      if (hasMatches) {\n        continue;\n      }\n    }\n    if (!isSerializable(nestedValue)) {\n      return {\n        keyPath: nestedPath,\n        value: nestedValue\n      };\n    }\n    if (typeof nestedValue === \"object\") {\n      foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths, cache);\n      if (foundNestedSerializable) {\n        return foundNestedSerializable;\n      }\n    }\n  }\n  if (cache && isNestedFrozen(value)) cache.add(value);\n  return false;\n}\nfunction isNestedFrozen(value) {\n  if (!Object.isFrozen(value)) return false;\n  for (const nestedValue of Object.values(value)) {\n    if (typeof nestedValue !== \"object\" || nestedValue === null) continue;\n    if (!isNestedFrozen(nestedValue)) return false;\n  }\n  return true;\n}\nfunction createSerializableStateInvariantMiddleware(options = {}) {\n  if (false) {} else {\n    const {\n      isSerializable = isPlain,\n      getEntries,\n      ignoredActions = [],\n      ignoredActionPaths = [\"meta.arg\", \"meta.baseQueryMeta\"],\n      ignoredPaths = [],\n      warnAfter = 32,\n      ignoreState = false,\n      ignoreActions = false,\n      disableCache = false\n    } = options;\n    const cache = !disableCache && WeakSet ? /* @__PURE__ */ new WeakSet() : void 0;\n    return (storeAPI) => (next) => (action) => {\n      if (!(0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action)) {\n        return next(action);\n      }\n      const result = next(action);\n      const measureUtils = getTimeMeasureUtils(warnAfter, \"SerializableStateInvariantMiddleware\");\n      if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) {\n        measureUtils.measureTime(() => {\n          const foundActionNonSerializableValue = findNonSerializableValue(action, \"\", isSerializable, getEntries, ignoredActionPaths, cache);\n          if (foundActionNonSerializableValue) {\n            const {\n              keyPath,\n              value\n            } = foundActionNonSerializableValue;\n            console.error(`A non-serializable value was detected in an action, in the path: \\`${keyPath}\\`. Value:`, value, \"\\nTake a look at the logic that dispatched this action: \", action, \"\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)\", \"\\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)\");\n          }\n        });\n      }\n      if (!ignoreState) {\n        measureUtils.measureTime(() => {\n          const state = storeAPI.getState();\n          const foundStateNonSerializableValue = findNonSerializableValue(state, \"\", isSerializable, getEntries, ignoredPaths, cache);\n          if (foundStateNonSerializableValue) {\n            const {\n              keyPath,\n              value\n            } = foundStateNonSerializableValue;\n            console.error(`A non-serializable value was detected in the state, in the path: \\`${keyPath}\\`. Value:`, value, `\nTake a look at the reducer(s) handling this action type: ${action.type}.\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`);\n          }\n        });\n        measureUtils.warnIfExceeded();\n      }\n      return result;\n    };\n  }\n}\n\n// src/getDefaultMiddleware.ts\nfunction isBoolean(x) {\n  return typeof x === \"boolean\";\n}\nvar buildGetDefaultMiddleware = () => function getDefaultMiddleware(options) {\n  const {\n    thunk = true,\n    immutableCheck = true,\n    serializableCheck = true,\n    actionCreatorCheck = true\n  } = options ?? {};\n  let middlewareArray = new Tuple();\n  if (thunk) {\n    if (isBoolean(thunk)) {\n      middlewareArray.push(redux_thunk__WEBPACK_IMPORTED_MODULE_3__.thunk);\n    } else {\n      middlewareArray.push((0,redux_thunk__WEBPACK_IMPORTED_MODULE_3__.withExtraArgument)(thunk.extraArgument));\n    }\n  }\n  if (true) {\n    if (immutableCheck) {\n      let immutableOptions = {};\n      if (!isBoolean(immutableCheck)) {\n        immutableOptions = immutableCheck;\n      }\n      middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));\n    }\n    if (serializableCheck) {\n      let serializableOptions = {};\n      if (!isBoolean(serializableCheck)) {\n        serializableOptions = serializableCheck;\n      }\n      middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));\n    }\n    if (actionCreatorCheck) {\n      let actionCreatorOptions = {};\n      if (!isBoolean(actionCreatorCheck)) {\n        actionCreatorOptions = actionCreatorCheck;\n      }\n      middlewareArray.unshift(createActionCreatorInvariantMiddleware(actionCreatorOptions));\n    }\n  }\n  return middlewareArray;\n};\n\n// src/autoBatchEnhancer.ts\nvar SHOULD_AUTOBATCH = \"RTK_autoBatch\";\nvar prepareAutoBatched = () => (payload) => ({\n  payload,\n  meta: {\n    [SHOULD_AUTOBATCH]: true\n  }\n});\nvar createQueueWithTimer = (timeout) => {\n  return (notify) => {\n    setTimeout(notify, timeout);\n  };\n};\nvar autoBatchEnhancer = (options = {\n  type: \"raf\"\n}) => (next) => (...args) => {\n  const store = next(...args);\n  let notifying = true;\n  let shouldNotifyAtEndOfTick = false;\n  let notificationQueued = false;\n  const listeners = /* @__PURE__ */ new Set();\n  const queueCallback = options.type === \"tick\" ? queueMicrotask : options.type === \"raf\" ? (\n    // requestAnimationFrame won't exist in SSR environments. Fall back to a vague approximation just to keep from erroring.\n    typeof window !== \"undefined\" && window.requestAnimationFrame ? window.requestAnimationFrame : createQueueWithTimer(10)\n  ) : options.type === \"callback\" ? options.queueNotification : createQueueWithTimer(options.timeout);\n  const notifyListeners = () => {\n    notificationQueued = false;\n    if (shouldNotifyAtEndOfTick) {\n      shouldNotifyAtEndOfTick = false;\n      listeners.forEach((l) => l());\n    }\n  };\n  return Object.assign({}, store, {\n    // Override the base `store.subscribe` method to keep original listeners\n    // from running if we're delaying notifications\n    subscribe(listener2) {\n      const wrappedListener = () => notifying && listener2();\n      const unsubscribe = store.subscribe(wrappedListener);\n      listeners.add(listener2);\n      return () => {\n        unsubscribe();\n        listeners.delete(listener2);\n      };\n    },\n    // Override the base `store.dispatch` method so that we can check actions\n    // for the `shouldAutoBatch` flag and determine if batching is active\n    dispatch(action) {\n      try {\n        notifying = !action?.meta?.[SHOULD_AUTOBATCH];\n        shouldNotifyAtEndOfTick = !notifying;\n        if (shouldNotifyAtEndOfTick) {\n          if (!notificationQueued) {\n            notificationQueued = true;\n            queueCallback(notifyListeners);\n          }\n        }\n        return store.dispatch(action);\n      } finally {\n        notifying = true;\n      }\n    }\n  });\n};\n\n// src/getDefaultEnhancers.ts\nvar buildGetDefaultEnhancers = (middlewareEnhancer) => function getDefaultEnhancers(options) {\n  const {\n    autoBatch = true\n  } = options ?? {};\n  let enhancerArray = new Tuple(middlewareEnhancer);\n  if (autoBatch) {\n    enhancerArray.push(autoBatchEnhancer(typeof autoBatch === \"object\" ? autoBatch : void 0));\n  }\n  return enhancerArray;\n};\n\n// src/configureStore.ts\nfunction configureStore(options) {\n  const getDefaultMiddleware = buildGetDefaultMiddleware();\n  const {\n    reducer = void 0,\n    middleware,\n    devTools = true,\n    duplicateMiddlewareCheck = true,\n    preloadedState = void 0,\n    enhancers = void 0\n  } = options || {};\n  let rootReducer;\n  if (typeof reducer === \"function\") {\n    rootReducer = reducer;\n  } else if ((0,redux__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(reducer)) {\n    rootReducer = (0,redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers)(reducer);\n  } else {\n    throw new Error( false ? 0 : \"`reducer` is a required argument, and must be a function or an object of functions that can be passed to combineReducers\");\n  }\n  if ( true && middleware && typeof middleware !== \"function\") {\n    throw new Error( false ? 0 : \"`middleware` field must be a callback\");\n  }\n  let finalMiddleware;\n  if (typeof middleware === \"function\") {\n    finalMiddleware = middleware(getDefaultMiddleware);\n    if ( true && !Array.isArray(finalMiddleware)) {\n      throw new Error( false ? 0 : \"when using a middleware builder function, an array of middleware must be returned\");\n    }\n  } else {\n    finalMiddleware = getDefaultMiddleware();\n  }\n  if ( true && finalMiddleware.some((item) => typeof item !== \"function\")) {\n    throw new Error( false ? 0 : \"each middleware provided to configureStore must be a function\");\n  }\n  if ( true && duplicateMiddlewareCheck) {\n    let middlewareReferences = /* @__PURE__ */ new Set();\n    finalMiddleware.forEach((middleware2) => {\n      if (middlewareReferences.has(middleware2)) {\n        throw new Error( false ? 0 : \"Duplicate middleware references found when creating the store. Ensure that each middleware is only included once.\");\n      }\n      middlewareReferences.add(middleware2);\n    });\n  }\n  let finalCompose = redux__WEBPACK_IMPORTED_MODULE_0__.compose;\n  if (devTools) {\n    finalCompose = composeWithDevTools({\n      // Enable capture of stack traces for dispatched Redux actions\n      trace: \"development\" !== \"production\",\n      ...typeof devTools === \"object\" && devTools\n    });\n  }\n  const middlewareEnhancer = (0,redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware)(...finalMiddleware);\n  const getDefaultEnhancers = buildGetDefaultEnhancers(middlewareEnhancer);\n  if ( true && enhancers && typeof enhancers !== \"function\") {\n    throw new Error( false ? 0 : \"`enhancers` field must be a callback\");\n  }\n  let storeEnhancers = typeof enhancers === \"function\" ? enhancers(getDefaultEnhancers) : getDefaultEnhancers();\n  if ( true && !Array.isArray(storeEnhancers)) {\n    throw new Error( false ? 0 : \"`enhancers` callback must return an array\");\n  }\n  if ( true && storeEnhancers.some((item) => typeof item !== \"function\")) {\n    throw new Error( false ? 0 : \"each enhancer provided to configureStore must be a function\");\n  }\n  if ( true && finalMiddleware.length && !storeEnhancers.includes(middlewareEnhancer)) {\n    console.error(\"middlewares were provided, but middleware enhancer was not included in final enhancers - make sure to call `getDefaultEnhancers`\");\n  }\n  const composedEnhancer = finalCompose(...storeEnhancers);\n  return (0,redux__WEBPACK_IMPORTED_MODULE_0__.createStore)(rootReducer, preloadedState, composedEnhancer);\n}\n\n// src/createReducer.ts\n\n\n// src/mapBuilders.ts\nfunction executeReducerBuilderCallback(builderCallback) {\n  const actionsMap = {};\n  const actionMatchers = [];\n  let defaultCaseReducer;\n  const builder = {\n    addCase(typeOrActionCreator, reducer) {\n      if (true) {\n        if (actionMatchers.length > 0) {\n          throw new Error( false ? 0 : \"`builder.addCase` should only be called before calling `builder.addMatcher`\");\n        }\n        if (defaultCaseReducer) {\n          throw new Error( false ? 0 : \"`builder.addCase` should only be called before calling `builder.addDefaultCase`\");\n        }\n      }\n      const type = typeof typeOrActionCreator === \"string\" ? typeOrActionCreator : typeOrActionCreator.type;\n      if (!type) {\n        throw new Error( false ? 0 : \"`builder.addCase` cannot be called with an empty action type\");\n      }\n      if (type in actionsMap) {\n        throw new Error( false ? 0 : `\\`builder.addCase\\` cannot be called with two reducers for the same action type '${type}'`);\n      }\n      actionsMap[type] = reducer;\n      return builder;\n    },\n    addAsyncThunk(asyncThunk, reducers) {\n      if (true) {\n        if (defaultCaseReducer) {\n          throw new Error( false ? 0 : \"`builder.addAsyncThunk` should only be called before calling `builder.addDefaultCase`\");\n        }\n      }\n      if (reducers.pending) actionsMap[asyncThunk.pending.type] = reducers.pending;\n      if (reducers.rejected) actionsMap[asyncThunk.rejected.type] = reducers.rejected;\n      if (reducers.fulfilled) actionsMap[asyncThunk.fulfilled.type] = reducers.fulfilled;\n      if (reducers.settled) actionMatchers.push({\n        matcher: asyncThunk.settled,\n        reducer: reducers.settled\n      });\n      return builder;\n    },\n    addMatcher(matcher, reducer) {\n      if (true) {\n        if (defaultCaseReducer) {\n          throw new Error( false ? 0 : \"`builder.addMatcher` should only be called before calling `builder.addDefaultCase`\");\n        }\n      }\n      actionMatchers.push({\n        matcher,\n        reducer\n      });\n      return builder;\n    },\n    addDefaultCase(reducer) {\n      if (true) {\n        if (defaultCaseReducer) {\n          throw new Error( false ? 0 : \"`builder.addDefaultCase` can only be called once\");\n        }\n      }\n      defaultCaseReducer = reducer;\n      return builder;\n    }\n  };\n  builderCallback(builder);\n  return [actionsMap, actionMatchers, defaultCaseReducer];\n}\n\n// src/createReducer.ts\nfunction isStateFunction(x) {\n  return typeof x === \"function\";\n}\nfunction createReducer(initialState, mapOrBuilderCallback) {\n  if (true) {\n    if (typeof mapOrBuilderCallback === \"object\") {\n      throw new Error( false ? 0 : \"The object notation for `createReducer` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer\");\n    }\n  }\n  let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] = executeReducerBuilderCallback(mapOrBuilderCallback);\n  let getInitialState;\n  if (isStateFunction(initialState)) {\n    getInitialState = () => freezeDraftable(initialState());\n  } else {\n    const frozenInitialState = freezeDraftable(initialState);\n    getInitialState = () => frozenInitialState;\n  }\n  function reducer(state = getInitialState(), action) {\n    let caseReducers = [actionsMap[action.type], ...finalActionMatchers.filter(({\n      matcher\n    }) => matcher(action)).map(({\n      reducer: reducer2\n    }) => reducer2)];\n    if (caseReducers.filter((cr) => !!cr).length === 0) {\n      caseReducers = [finalDefaultCaseReducer];\n    }\n    return caseReducers.reduce((previousState, caseReducer) => {\n      if (caseReducer) {\n        if ((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(previousState)) {\n          const draft = previousState;\n          const result = caseReducer(draft, action);\n          if (result === void 0) {\n            return previousState;\n          }\n          return result;\n        } else if (!(0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(previousState)) {\n          const result = caseReducer(previousState, action);\n          if (result === void 0) {\n            if (previousState === null) {\n              return previousState;\n            }\n            throw Error(\"A case reducer on a non-draftable value must not return undefined\");\n          }\n          return result;\n        } else {\n          return (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(previousState, (draft) => {\n            return caseReducer(draft, action);\n          });\n        }\n      }\n      return previousState;\n    }, state);\n  }\n  reducer.getInitialState = getInitialState;\n  return reducer;\n}\n\n// src/matchers.ts\nvar matches = (matcher, action) => {\n  if (hasMatchFunction(matcher)) {\n    return matcher.match(action);\n  } else {\n    return matcher(action);\n  }\n};\nfunction isAnyOf(...matchers) {\n  return (action) => {\n    return matchers.some((matcher) => matches(matcher, action));\n  };\n}\nfunction isAllOf(...matchers) {\n  return (action) => {\n    return matchers.every((matcher) => matches(matcher, action));\n  };\n}\nfunction hasExpectedRequestMetadata(action, validStatus) {\n  if (!action || !action.meta) return false;\n  const hasValidRequestId = typeof action.meta.requestId === \"string\";\n  const hasValidRequestStatus = validStatus.indexOf(action.meta.requestStatus) > -1;\n  return hasValidRequestId && hasValidRequestStatus;\n}\nfunction isAsyncThunkArray(a) {\n  return typeof a[0] === \"function\" && \"pending\" in a[0] && \"fulfilled\" in a[0] && \"rejected\" in a[0];\n}\nfunction isPending(...asyncThunks) {\n  if (asyncThunks.length === 0) {\n    return (action) => hasExpectedRequestMetadata(action, [\"pending\"]);\n  }\n  if (!isAsyncThunkArray(asyncThunks)) {\n    return isPending()(asyncThunks[0]);\n  }\n  return isAnyOf(...asyncThunks.map((asyncThunk) => asyncThunk.pending));\n}\nfunction isRejected(...asyncThunks) {\n  if (asyncThunks.length === 0) {\n    return (action) => hasExpectedRequestMetadata(action, [\"rejected\"]);\n  }\n  if (!isAsyncThunkArray(asyncThunks)) {\n    return isRejected()(asyncThunks[0]);\n  }\n  return isAnyOf(...asyncThunks.map((asyncThunk) => asyncThunk.rejected));\n}\nfunction isRejectedWithValue(...asyncThunks) {\n  const hasFlag = (action) => {\n    return action && action.meta && action.meta.rejectedWithValue;\n  };\n  if (asyncThunks.length === 0) {\n    return isAllOf(isRejected(...asyncThunks), hasFlag);\n  }\n  if (!isAsyncThunkArray(asyncThunks)) {\n    return isRejectedWithValue()(asyncThunks[0]);\n  }\n  return isAllOf(isRejected(...asyncThunks), hasFlag);\n}\nfunction isFulfilled(...asyncThunks) {\n  if (asyncThunks.length === 0) {\n    return (action) => hasExpectedRequestMetadata(action, [\"fulfilled\"]);\n  }\n  if (!isAsyncThunkArray(asyncThunks)) {\n    return isFulfilled()(asyncThunks[0]);\n  }\n  return isAnyOf(...asyncThunks.map((asyncThunk) => asyncThunk.fulfilled));\n}\nfunction isAsyncThunkAction(...asyncThunks) {\n  if (asyncThunks.length === 0) {\n    return (action) => hasExpectedRequestMetadata(action, [\"pending\", \"fulfilled\", \"rejected\"]);\n  }\n  if (!isAsyncThunkArray(asyncThunks)) {\n    return isAsyncThunkAction()(asyncThunks[0]);\n  }\n  return isAnyOf(...asyncThunks.flatMap((asyncThunk) => [asyncThunk.pending, asyncThunk.rejected, asyncThunk.fulfilled]));\n}\n\n// src/nanoid.ts\nvar urlAlphabet = \"ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW\";\nvar nanoid = (size = 21) => {\n  let id = \"\";\n  let i = size;\n  while (i--) {\n    id += urlAlphabet[Math.random() * 64 | 0];\n  }\n  return id;\n};\n\n// src/createAsyncThunk.ts\nvar commonProperties = [\"name\", \"message\", \"stack\", \"code\"];\nvar RejectWithValue = class {\n  constructor(payload, meta) {\n    this.payload = payload;\n    this.meta = meta;\n  }\n  /*\n  type-only property to distinguish between RejectWithValue and FulfillWithMeta\n  does not exist at runtime\n  */\n  _type;\n};\nvar FulfillWithMeta = class {\n  constructor(payload, meta) {\n    this.payload = payload;\n    this.meta = meta;\n  }\n  /*\n  type-only property to distinguish between RejectWithValue and FulfillWithMeta\n  does not exist at runtime\n  */\n  _type;\n};\nvar miniSerializeError = (value) => {\n  if (typeof value === \"object\" && value !== null) {\n    const simpleError = {};\n    for (const property of commonProperties) {\n      if (typeof value[property] === \"string\") {\n        simpleError[property] = value[property];\n      }\n    }\n    return simpleError;\n  }\n  return {\n    message: String(value)\n  };\n};\nvar externalAbortMessage = \"External signal was aborted\";\nvar createAsyncThunk = /* @__PURE__ */ (() => {\n  function createAsyncThunk2(typePrefix, payloadCreator, options) {\n    const fulfilled = createAction(typePrefix + \"/fulfilled\", (payload, requestId, arg, meta) => ({\n      payload,\n      meta: {\n        ...meta || {},\n        arg,\n        requestId,\n        requestStatus: \"fulfilled\"\n      }\n    }));\n    const pending = createAction(typePrefix + \"/pending\", (requestId, arg, meta) => ({\n      payload: void 0,\n      meta: {\n        ...meta || {},\n        arg,\n        requestId,\n        requestStatus: \"pending\"\n      }\n    }));\n    const rejected = createAction(typePrefix + \"/rejected\", (error, requestId, arg, payload, meta) => ({\n      payload,\n      error: (options && options.serializeError || miniSerializeError)(error || \"Rejected\"),\n      meta: {\n        ...meta || {},\n        arg,\n        requestId,\n        rejectedWithValue: !!payload,\n        requestStatus: \"rejected\",\n        aborted: error?.name === \"AbortError\",\n        condition: error?.name === \"ConditionError\"\n      }\n    }));\n    function actionCreator(arg, {\n      signal\n    } = {}) {\n      return (dispatch, getState, extra) => {\n        const requestId = options?.idGenerator ? options.idGenerator(arg) : nanoid();\n        const abortController = new AbortController();\n        let abortHandler;\n        let abortReason;\n        function abort(reason) {\n          abortReason = reason;\n          abortController.abort();\n        }\n        if (signal) {\n          if (signal.aborted) {\n            abort(externalAbortMessage);\n          } else {\n            signal.addEventListener(\"abort\", () => abort(externalAbortMessage), {\n              once: true\n            });\n          }\n        }\n        const promise = async function() {\n          let finalAction;\n          try {\n            let conditionResult = options?.condition?.(arg, {\n              getState,\n              extra\n            });\n            if (isThenable(conditionResult)) {\n              conditionResult = await conditionResult;\n            }\n            if (conditionResult === false || abortController.signal.aborted) {\n              throw {\n                name: \"ConditionError\",\n                message: \"Aborted due to condition callback returning false.\"\n              };\n            }\n            const abortedPromise = new Promise((_, reject) => {\n              abortHandler = () => {\n                reject({\n                  name: \"AbortError\",\n                  message: abortReason || \"Aborted\"\n                });\n              };\n              abortController.signal.addEventListener(\"abort\", abortHandler);\n            });\n            dispatch(pending(requestId, arg, options?.getPendingMeta?.({\n              requestId,\n              arg\n            }, {\n              getState,\n              extra\n            })));\n            finalAction = await Promise.race([abortedPromise, Promise.resolve(payloadCreator(arg, {\n              dispatch,\n              getState,\n              extra,\n              requestId,\n              signal: abortController.signal,\n              abort,\n              rejectWithValue: (value, meta) => {\n                return new RejectWithValue(value, meta);\n              },\n              fulfillWithValue: (value, meta) => {\n                return new FulfillWithMeta(value, meta);\n              }\n            })).then((result) => {\n              if (result instanceof RejectWithValue) {\n                throw result;\n              }\n              if (result instanceof FulfillWithMeta) {\n                return fulfilled(result.payload, requestId, arg, result.meta);\n              }\n              return fulfilled(result, requestId, arg);\n            })]);\n          } catch (err) {\n            finalAction = err instanceof RejectWithValue ? rejected(null, requestId, arg, err.payload, err.meta) : rejected(err, requestId, arg);\n          } finally {\n            if (abortHandler) {\n              abortController.signal.removeEventListener(\"abort\", abortHandler);\n            }\n          }\n          const skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;\n          if (!skipDispatch) {\n            dispatch(finalAction);\n          }\n          return finalAction;\n        }();\n        return Object.assign(promise, {\n          abort,\n          requestId,\n          arg,\n          unwrap() {\n            return promise.then(unwrapResult);\n          }\n        });\n      };\n    }\n    return Object.assign(actionCreator, {\n      pending,\n      rejected,\n      fulfilled,\n      settled: isAnyOf(rejected, fulfilled),\n      typePrefix\n    });\n  }\n  createAsyncThunk2.withTypes = () => createAsyncThunk2;\n  return createAsyncThunk2;\n})();\nfunction unwrapResult(action) {\n  if (action.meta && action.meta.rejectedWithValue) {\n    throw action.payload;\n  }\n  if (action.error) {\n    throw action.error;\n  }\n  return action.payload;\n}\nfunction isThenable(value) {\n  return value !== null && typeof value === \"object\" && typeof value.then === \"function\";\n}\n\n// src/createSlice.ts\nvar asyncThunkSymbol = /* @__PURE__ */ Symbol.for(\"rtk-slice-createasyncthunk\");\nvar asyncThunkCreator = {\n  [asyncThunkSymbol]: createAsyncThunk\n};\nvar ReducerType = /* @__PURE__ */ ((ReducerType2) => {\n  ReducerType2[\"reducer\"] = \"reducer\";\n  ReducerType2[\"reducerWithPrepare\"] = \"reducerWithPrepare\";\n  ReducerType2[\"asyncThunk\"] = \"asyncThunk\";\n  return ReducerType2;\n})(ReducerType || {});\nfunction getType(slice, actionKey) {\n  return `${slice}/${actionKey}`;\n}\nfunction buildCreateSlice({\n  creators\n} = {}) {\n  const cAT = creators?.asyncThunk?.[asyncThunkSymbol];\n  return function createSlice2(options) {\n    const {\n      name,\n      reducerPath = name\n    } = options;\n    if (!name) {\n      throw new Error( false ? 0 : \"`name` is a required option for createSlice\");\n    }\n    if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n      if (options.initialState === void 0) {\n        console.error(\"You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`\");\n      }\n    }\n    const reducers = (typeof options.reducers === \"function\" ? options.reducers(buildReducerCreators()) : options.reducers) || {};\n    const reducerNames = Object.keys(reducers);\n    const context = {\n      sliceCaseReducersByName: {},\n      sliceCaseReducersByType: {},\n      actionCreators: {},\n      sliceMatchers: []\n    };\n    const contextMethods = {\n      addCase(typeOrActionCreator, reducer2) {\n        const type = typeof typeOrActionCreator === \"string\" ? typeOrActionCreator : typeOrActionCreator.type;\n        if (!type) {\n          throw new Error( false ? 0 : \"`context.addCase` cannot be called with an empty action type\");\n        }\n        if (type in context.sliceCaseReducersByType) {\n          throw new Error( false ? 0 : \"`context.addCase` cannot be called with two reducers for the same action type: \" + type);\n        }\n        context.sliceCaseReducersByType[type] = reducer2;\n        return contextMethods;\n      },\n      addMatcher(matcher, reducer2) {\n        context.sliceMatchers.push({\n          matcher,\n          reducer: reducer2\n        });\n        return contextMethods;\n      },\n      exposeAction(name2, actionCreator) {\n        context.actionCreators[name2] = actionCreator;\n        return contextMethods;\n      },\n      exposeCaseReducer(name2, reducer2) {\n        context.sliceCaseReducersByName[name2] = reducer2;\n        return contextMethods;\n      }\n    };\n    reducerNames.forEach((reducerName) => {\n      const reducerDefinition = reducers[reducerName];\n      const reducerDetails = {\n        reducerName,\n        type: getType(name, reducerName),\n        createNotation: typeof options.reducers === \"function\"\n      };\n      if (isAsyncThunkSliceReducerDefinition(reducerDefinition)) {\n        handleThunkCaseReducerDefinition(reducerDetails, reducerDefinition, contextMethods, cAT);\n      } else {\n        handleNormalReducerDefinition(reducerDetails, reducerDefinition, contextMethods);\n      }\n    });\n    function buildReducer() {\n      if (true) {\n        if (typeof options.extraReducers === \"object\") {\n          throw new Error( false ? 0 : \"The object notation for `createSlice.extraReducers` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice\");\n        }\n      }\n      const [extraReducers = {}, actionMatchers = [], defaultCaseReducer = void 0] = typeof options.extraReducers === \"function\" ? executeReducerBuilderCallback(options.extraReducers) : [options.extraReducers];\n      const finalCaseReducers = {\n        ...extraReducers,\n        ...context.sliceCaseReducersByType\n      };\n      return createReducer(options.initialState, (builder) => {\n        for (let key in finalCaseReducers) {\n          builder.addCase(key, finalCaseReducers[key]);\n        }\n        for (let sM of context.sliceMatchers) {\n          builder.addMatcher(sM.matcher, sM.reducer);\n        }\n        for (let m of actionMatchers) {\n          builder.addMatcher(m.matcher, m.reducer);\n        }\n        if (defaultCaseReducer) {\n          builder.addDefaultCase(defaultCaseReducer);\n        }\n      });\n    }\n    const selectSelf = (state) => state;\n    const injectedSelectorCache = /* @__PURE__ */ new Map();\n    const injectedStateCache = /* @__PURE__ */ new WeakMap();\n    let _reducer;\n    function reducer(state, action) {\n      if (!_reducer) _reducer = buildReducer();\n      return _reducer(state, action);\n    }\n    function getInitialState() {\n      if (!_reducer) _reducer = buildReducer();\n      return _reducer.getInitialState();\n    }\n    function makeSelectorProps(reducerPath2, injected = false) {\n      function selectSlice(state) {\n        let sliceState = state[reducerPath2];\n        if (typeof sliceState === \"undefined\") {\n          if (injected) {\n            sliceState = getOrInsertComputed(injectedStateCache, selectSlice, getInitialState);\n          } else if (true) {\n            throw new Error( false ? 0 : \"selectSlice returned undefined for an uninjected slice reducer\");\n          }\n        }\n        return sliceState;\n      }\n      function getSelectors(selectState = selectSelf) {\n        const selectorCache = getOrInsertComputed(injectedSelectorCache, injected, () => /* @__PURE__ */ new WeakMap());\n        return getOrInsertComputed(selectorCache, selectState, () => {\n          const map = {};\n          for (const [name2, selector] of Object.entries(options.selectors ?? {})) {\n            map[name2] = wrapSelector(selector, selectState, () => getOrInsertComputed(injectedStateCache, selectState, getInitialState), injected);\n          }\n          return map;\n        });\n      }\n      return {\n        reducerPath: reducerPath2,\n        getSelectors,\n        get selectors() {\n          return getSelectors(selectSlice);\n        },\n        selectSlice\n      };\n    }\n    const slice = {\n      name,\n      reducer,\n      actions: context.actionCreators,\n      caseReducers: context.sliceCaseReducersByName,\n      getInitialState,\n      ...makeSelectorProps(reducerPath),\n      injectInto(injectable, {\n        reducerPath: pathOpt,\n        ...config\n      } = {}) {\n        const newReducerPath = pathOpt ?? reducerPath;\n        injectable.inject({\n          reducerPath: newReducerPath,\n          reducer\n        }, config);\n        return {\n          ...slice,\n          ...makeSelectorProps(newReducerPath, true)\n        };\n      }\n    };\n    return slice;\n  };\n}\nfunction wrapSelector(selector, selectState, getInitialState, injected) {\n  function wrapper(rootState, ...args) {\n    let sliceState = selectState(rootState);\n    if (typeof sliceState === \"undefined\") {\n      if (injected) {\n        sliceState = getInitialState();\n      } else if (true) {\n        throw new Error( false ? 0 : \"selectState returned undefined for an uninjected slice reducer\");\n      }\n    }\n    return selector(sliceState, ...args);\n  }\n  wrapper.unwrapped = selector;\n  return wrapper;\n}\nvar createSlice = /* @__PURE__ */ buildCreateSlice();\nfunction buildReducerCreators() {\n  function asyncThunk(payloadCreator, config) {\n    return {\n      _reducerDefinitionType: \"asyncThunk\" /* asyncThunk */,\n      payloadCreator,\n      ...config\n    };\n  }\n  asyncThunk.withTypes = () => asyncThunk;\n  return {\n    reducer(caseReducer) {\n      return Object.assign({\n        // hack so the wrapping function has the same name as the original\n        // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original\n        [caseReducer.name](...args) {\n          return caseReducer(...args);\n        }\n      }[caseReducer.name], {\n        _reducerDefinitionType: \"reducer\" /* reducer */\n      });\n    },\n    preparedReducer(prepare, reducer) {\n      return {\n        _reducerDefinitionType: \"reducerWithPrepare\" /* reducerWithPrepare */,\n        prepare,\n        reducer\n      };\n    },\n    asyncThunk\n  };\n}\nfunction handleNormalReducerDefinition({\n  type,\n  reducerName,\n  createNotation\n}, maybeReducerWithPrepare, context) {\n  let caseReducer;\n  let prepareCallback;\n  if (\"reducer\" in maybeReducerWithPrepare) {\n    if (createNotation && !isCaseReducerWithPrepareDefinition(maybeReducerWithPrepare)) {\n      throw new Error( false ? 0 : \"Please use the `create.preparedReducer` notation for prepared action creators with the `create` notation.\");\n    }\n    caseReducer = maybeReducerWithPrepare.reducer;\n    prepareCallback = maybeReducerWithPrepare.prepare;\n  } else {\n    caseReducer = maybeReducerWithPrepare;\n  }\n  context.addCase(type, caseReducer).exposeCaseReducer(reducerName, caseReducer).exposeAction(reducerName, prepareCallback ? createAction(type, prepareCallback) : createAction(type));\n}\nfunction isAsyncThunkSliceReducerDefinition(reducerDefinition) {\n  return reducerDefinition._reducerDefinitionType === \"asyncThunk\" /* asyncThunk */;\n}\nfunction isCaseReducerWithPrepareDefinition(reducerDefinition) {\n  return reducerDefinition._reducerDefinitionType === \"reducerWithPrepare\" /* reducerWithPrepare */;\n}\nfunction handleThunkCaseReducerDefinition({\n  type,\n  reducerName\n}, reducerDefinition, context, cAT) {\n  if (!cAT) {\n    throw new Error( false ? 0 : \"Cannot use `create.asyncThunk` in the built-in `createSlice`. Use `buildCreateSlice({ creators: { asyncThunk: asyncThunkCreator } })` to create a customised version of `createSlice`.\");\n  }\n  const {\n    payloadCreator,\n    fulfilled,\n    pending,\n    rejected,\n    settled,\n    options\n  } = reducerDefinition;\n  const thunk = cAT(type, payloadCreator, options);\n  context.exposeAction(reducerName, thunk);\n  if (fulfilled) {\n    context.addCase(thunk.fulfilled, fulfilled);\n  }\n  if (pending) {\n    context.addCase(thunk.pending, pending);\n  }\n  if (rejected) {\n    context.addCase(thunk.rejected, rejected);\n  }\n  if (settled) {\n    context.addMatcher(thunk.settled, settled);\n  }\n  context.exposeCaseReducer(reducerName, {\n    fulfilled: fulfilled || noop,\n    pending: pending || noop,\n    rejected: rejected || noop,\n    settled: settled || noop\n  });\n}\nfunction noop() {\n}\n\n// src/entities/entity_state.ts\nfunction getInitialEntityState() {\n  return {\n    ids: [],\n    entities: {}\n  };\n}\nfunction createInitialStateFactory(stateAdapter) {\n  function getInitialState(additionalState = {}, entities) {\n    const state = Object.assign(getInitialEntityState(), additionalState);\n    return entities ? stateAdapter.setAll(state, entities) : state;\n  }\n  return {\n    getInitialState\n  };\n}\n\n// src/entities/state_selectors.ts\nfunction createSelectorsFactory() {\n  function getSelectors(selectState, options = {}) {\n    const {\n      createSelector: createSelector2 = createDraftSafeSelector\n    } = options;\n    const selectIds = (state) => state.ids;\n    const selectEntities = (state) => state.entities;\n    const selectAll = createSelector2(selectIds, selectEntities, (ids, entities) => ids.map((id) => entities[id]));\n    const selectId = (_, id) => id;\n    const selectById = (entities, id) => entities[id];\n    const selectTotal = createSelector2(selectIds, (ids) => ids.length);\n    if (!selectState) {\n      return {\n        selectIds,\n        selectEntities,\n        selectAll,\n        selectTotal,\n        selectById: createSelector2(selectEntities, selectId, selectById)\n      };\n    }\n    const selectGlobalizedEntities = createSelector2(selectState, selectEntities);\n    return {\n      selectIds: createSelector2(selectState, selectIds),\n      selectEntities: selectGlobalizedEntities,\n      selectAll: createSelector2(selectState, selectAll),\n      selectTotal: createSelector2(selectState, selectTotal),\n      selectById: createSelector2(selectGlobalizedEntities, selectId, selectById)\n    };\n  }\n  return {\n    getSelectors\n  };\n}\n\n// src/entities/state_adapter.ts\n\nvar isDraftTyped = immer__WEBPACK_IMPORTED_MODULE_2__.isDraft;\nfunction createSingleArgumentStateOperator(mutator) {\n  const operator = createStateOperator((_, state) => mutator(state));\n  return function operation(state) {\n    return operator(state, void 0);\n  };\n}\nfunction createStateOperator(mutator) {\n  return function operation(state, arg) {\n    function isPayloadActionArgument(arg2) {\n      return isFSA(arg2);\n    }\n    const runMutator = (draft) => {\n      if (isPayloadActionArgument(arg)) {\n        mutator(arg.payload, draft);\n      } else {\n        mutator(arg, draft);\n      }\n    };\n    if (isDraftTyped(state)) {\n      runMutator(state);\n      return state;\n    }\n    return (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(state, runMutator);\n  };\n}\n\n// src/entities/utils.ts\n\nfunction selectIdValue(entity, selectId) {\n  const key = selectId(entity);\n  if ( true && key === void 0) {\n    console.warn(\"The entity passed to the `selectId` implementation returned undefined.\", \"You should probably provide your own `selectId` implementation.\", \"The entity that was passed:\", entity, \"The `selectId` implementation:\", selectId.toString());\n  }\n  return key;\n}\nfunction ensureEntitiesArray(entities) {\n  if (!Array.isArray(entities)) {\n    entities = Object.values(entities);\n  }\n  return entities;\n}\nfunction getCurrent(value) {\n  return (0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(value) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.current)(value) : value;\n}\nfunction splitAddedUpdatedEntities(newEntities, selectId, state) {\n  newEntities = ensureEntitiesArray(newEntities);\n  const existingIdsArray = getCurrent(state.ids);\n  const existingIds = new Set(existingIdsArray);\n  const added = [];\n  const addedIds = /* @__PURE__ */ new Set([]);\n  const updated = [];\n  for (const entity of newEntities) {\n    const id = selectIdValue(entity, selectId);\n    if (existingIds.has(id) || addedIds.has(id)) {\n      updated.push({\n        id,\n        changes: entity\n      });\n    } else {\n      addedIds.add(id);\n      added.push(entity);\n    }\n  }\n  return [added, updated, existingIdsArray];\n}\n\n// src/entities/unsorted_state_adapter.ts\nfunction createUnsortedStateAdapter(selectId) {\n  function addOneMutably(entity, state) {\n    const key = selectIdValue(entity, selectId);\n    if (key in state.entities) {\n      return;\n    }\n    state.ids.push(key);\n    state.entities[key] = entity;\n  }\n  function addManyMutably(newEntities, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    for (const entity of newEntities) {\n      addOneMutably(entity, state);\n    }\n  }\n  function setOneMutably(entity, state) {\n    const key = selectIdValue(entity, selectId);\n    if (!(key in state.entities)) {\n      state.ids.push(key);\n    }\n    ;\n    state.entities[key] = entity;\n  }\n  function setManyMutably(newEntities, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    for (const entity of newEntities) {\n      setOneMutably(entity, state);\n    }\n  }\n  function setAllMutably(newEntities, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    state.ids = [];\n    state.entities = {};\n    addManyMutably(newEntities, state);\n  }\n  function removeOneMutably(key, state) {\n    return removeManyMutably([key], state);\n  }\n  function removeManyMutably(keys, state) {\n    let didMutate = false;\n    keys.forEach((key) => {\n      if (key in state.entities) {\n        delete state.entities[key];\n        didMutate = true;\n      }\n    });\n    if (didMutate) {\n      state.ids = state.ids.filter((id) => id in state.entities);\n    }\n  }\n  function removeAllMutably(state) {\n    Object.assign(state, {\n      ids: [],\n      entities: {}\n    });\n  }\n  function takeNewKey(keys, update, state) {\n    const original3 = state.entities[update.id];\n    if (original3 === void 0) {\n      return false;\n    }\n    const updated = Object.assign({}, original3, update.changes);\n    const newKey = selectIdValue(updated, selectId);\n    const hasNewKey = newKey !== update.id;\n    if (hasNewKey) {\n      keys[update.id] = newKey;\n      delete state.entities[update.id];\n    }\n    ;\n    state.entities[newKey] = updated;\n    return hasNewKey;\n  }\n  function updateOneMutably(update, state) {\n    return updateManyMutably([update], state);\n  }\n  function updateManyMutably(updates, state) {\n    const newKeys = {};\n    const updatesPerEntity = {};\n    updates.forEach((update) => {\n      if (update.id in state.entities) {\n        updatesPerEntity[update.id] = {\n          id: update.id,\n          // Spreads ignore falsy values, so this works even if there isn't\n          // an existing update already at this key\n          changes: {\n            ...updatesPerEntity[update.id]?.changes,\n            ...update.changes\n          }\n        };\n      }\n    });\n    updates = Object.values(updatesPerEntity);\n    const didMutateEntities = updates.length > 0;\n    if (didMutateEntities) {\n      const didMutateIds = updates.filter((update) => takeNewKey(newKeys, update, state)).length > 0;\n      if (didMutateIds) {\n        state.ids = Object.values(state.entities).map((e) => selectIdValue(e, selectId));\n      }\n    }\n  }\n  function upsertOneMutably(entity, state) {\n    return upsertManyMutably([entity], state);\n  }\n  function upsertManyMutably(newEntities, state) {\n    const [added, updated] = splitAddedUpdatedEntities(newEntities, selectId, state);\n    addManyMutably(added, state);\n    updateManyMutably(updated, state);\n  }\n  return {\n    removeAll: createSingleArgumentStateOperator(removeAllMutably),\n    addOne: createStateOperator(addOneMutably),\n    addMany: createStateOperator(addManyMutably),\n    setOne: createStateOperator(setOneMutably),\n    setMany: createStateOperator(setManyMutably),\n    setAll: createStateOperator(setAllMutably),\n    updateOne: createStateOperator(updateOneMutably),\n    updateMany: createStateOperator(updateManyMutably),\n    upsertOne: createStateOperator(upsertOneMutably),\n    upsertMany: createStateOperator(upsertManyMutably),\n    removeOne: createStateOperator(removeOneMutably),\n    removeMany: createStateOperator(removeManyMutably)\n  };\n}\n\n// src/entities/sorted_state_adapter.ts\nfunction findInsertIndex(sortedItems, item, comparisonFunction) {\n  let lowIndex = 0;\n  let highIndex = sortedItems.length;\n  while (lowIndex < highIndex) {\n    let middleIndex = lowIndex + highIndex >>> 1;\n    const currentItem = sortedItems[middleIndex];\n    const res = comparisonFunction(item, currentItem);\n    if (res >= 0) {\n      lowIndex = middleIndex + 1;\n    } else {\n      highIndex = middleIndex;\n    }\n  }\n  return lowIndex;\n}\nfunction insert(sortedItems, item, comparisonFunction) {\n  const insertAtIndex = findInsertIndex(sortedItems, item, comparisonFunction);\n  sortedItems.splice(insertAtIndex, 0, item);\n  return sortedItems;\n}\nfunction createSortedStateAdapter(selectId, comparer) {\n  const {\n    removeOne,\n    removeMany,\n    removeAll\n  } = createUnsortedStateAdapter(selectId);\n  function addOneMutably(entity, state) {\n    return addManyMutably([entity], state);\n  }\n  function addManyMutably(newEntities, state, existingIds) {\n    newEntities = ensureEntitiesArray(newEntities);\n    const existingKeys = new Set(existingIds ?? getCurrent(state.ids));\n    const addedKeys = /* @__PURE__ */ new Set();\n    const models = newEntities.filter((model) => {\n      const modelId = selectIdValue(model, selectId);\n      const notAdded = !addedKeys.has(modelId);\n      if (notAdded) addedKeys.add(modelId);\n      return !existingKeys.has(modelId) && notAdded;\n    });\n    if (models.length !== 0) {\n      mergeFunction(state, models);\n    }\n  }\n  function setOneMutably(entity, state) {\n    return setManyMutably([entity], state);\n  }\n  function setManyMutably(newEntities, state) {\n    let deduplicatedEntities = {};\n    newEntities = ensureEntitiesArray(newEntities);\n    if (newEntities.length !== 0) {\n      for (const item of newEntities) {\n        const entityId = selectId(item);\n        deduplicatedEntities[entityId] = item;\n        delete state.entities[entityId];\n      }\n      newEntities = ensureEntitiesArray(deduplicatedEntities);\n      mergeFunction(state, newEntities);\n    }\n  }\n  function setAllMutably(newEntities, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    state.entities = {};\n    state.ids = [];\n    addManyMutably(newEntities, state, []);\n  }\n  function updateOneMutably(update, state) {\n    return updateManyMutably([update], state);\n  }\n  function updateManyMutably(updates, state) {\n    let appliedUpdates = false;\n    let replacedIds = false;\n    for (let update of updates) {\n      const entity = state.entities[update.id];\n      if (!entity) {\n        continue;\n      }\n      appliedUpdates = true;\n      Object.assign(entity, update.changes);\n      const newId = selectId(entity);\n      if (update.id !== newId) {\n        replacedIds = true;\n        delete state.entities[update.id];\n        const oldIndex = state.ids.indexOf(update.id);\n        state.ids[oldIndex] = newId;\n        state.entities[newId] = entity;\n      }\n    }\n    if (appliedUpdates) {\n      mergeFunction(state, [], appliedUpdates, replacedIds);\n    }\n  }\n  function upsertOneMutably(entity, state) {\n    return upsertManyMutably([entity], state);\n  }\n  function upsertManyMutably(newEntities, state) {\n    const [added, updated, existingIdsArray] = splitAddedUpdatedEntities(newEntities, selectId, state);\n    if (added.length) {\n      addManyMutably(added, state, existingIdsArray);\n    }\n    if (updated.length) {\n      updateManyMutably(updated, state);\n    }\n  }\n  function areArraysEqual(a, b) {\n    if (a.length !== b.length) {\n      return false;\n    }\n    for (let i = 0; i < a.length; i++) {\n      if (a[i] === b[i]) {\n        continue;\n      }\n      return false;\n    }\n    return true;\n  }\n  const mergeFunction = (state, addedItems, appliedUpdates, replacedIds) => {\n    const currentEntities = getCurrent(state.entities);\n    const currentIds = getCurrent(state.ids);\n    const stateEntities = state.entities;\n    let ids = currentIds;\n    if (replacedIds) {\n      ids = new Set(currentIds);\n    }\n    let sortedEntities = [];\n    for (const id of ids) {\n      const entity = currentEntities[id];\n      if (entity) {\n        sortedEntities.push(entity);\n      }\n    }\n    const wasPreviouslyEmpty = sortedEntities.length === 0;\n    for (const item of addedItems) {\n      stateEntities[selectId(item)] = item;\n      if (!wasPreviouslyEmpty) {\n        insert(sortedEntities, item, comparer);\n      }\n    }\n    if (wasPreviouslyEmpty) {\n      sortedEntities = addedItems.slice().sort(comparer);\n    } else if (appliedUpdates) {\n      sortedEntities.sort(comparer);\n    }\n    const newSortedIds = sortedEntities.map(selectId);\n    if (!areArraysEqual(currentIds, newSortedIds)) {\n      state.ids = newSortedIds;\n    }\n  };\n  return {\n    removeOne,\n    removeMany,\n    removeAll,\n    addOne: createStateOperator(addOneMutably),\n    updateOne: createStateOperator(updateOneMutably),\n    upsertOne: createStateOperator(upsertOneMutably),\n    setOne: createStateOperator(setOneMutably),\n    setMany: createStateOperator(setManyMutably),\n    setAll: createStateOperator(setAllMutably),\n    addMany: createStateOperator(addManyMutably),\n    updateMany: createStateOperator(updateManyMutably),\n    upsertMany: createStateOperator(upsertManyMutably)\n  };\n}\n\n// src/entities/create_adapter.ts\nfunction createEntityAdapter(options = {}) {\n  const {\n    selectId,\n    sortComparer\n  } = {\n    sortComparer: false,\n    selectId: (instance) => instance.id,\n    ...options\n  };\n  const stateAdapter = sortComparer ? createSortedStateAdapter(selectId, sortComparer) : createUnsortedStateAdapter(selectId);\n  const stateFactory = createInitialStateFactory(stateAdapter);\n  const selectorsFactory = createSelectorsFactory();\n  return {\n    selectId,\n    sortComparer,\n    ...stateFactory,\n    ...selectorsFactory,\n    ...stateAdapter\n  };\n}\n\n// src/listenerMiddleware/index.ts\n\n\n// src/listenerMiddleware/exceptions.ts\nvar task = \"task\";\nvar listener = \"listener\";\nvar completed = \"completed\";\nvar cancelled = \"cancelled\";\nvar taskCancelled = `task-${cancelled}`;\nvar taskCompleted = `task-${completed}`;\nvar listenerCancelled = `${listener}-${cancelled}`;\nvar listenerCompleted = `${listener}-${completed}`;\nvar TaskAbortError = class {\n  constructor(code) {\n    this.code = code;\n    this.message = `${task} ${cancelled} (reason: ${code})`;\n  }\n  name = \"TaskAbortError\";\n  message;\n};\n\n// src/listenerMiddleware/utils.ts\nvar assertFunction = (func, expected) => {\n  if (typeof func !== \"function\") {\n    throw new TypeError( false ? 0 : `${expected} is not a function`);\n  }\n};\nvar noop2 = () => {\n};\nvar catchRejection = (promise, onError = noop2) => {\n  promise.catch(onError);\n  return promise;\n};\nvar addAbortSignalListener = (abortSignal, callback) => {\n  abortSignal.addEventListener(\"abort\", callback, {\n    once: true\n  });\n  return () => abortSignal.removeEventListener(\"abort\", callback);\n};\nvar abortControllerWithReason = (abortController, reason) => {\n  const signal = abortController.signal;\n  if (signal.aborted) {\n    return;\n  }\n  if (!(\"reason\" in signal)) {\n    Object.defineProperty(signal, \"reason\", {\n      enumerable: true,\n      value: reason,\n      configurable: true,\n      writable: true\n    });\n  }\n  ;\n  abortController.abort(reason);\n};\n\n// src/listenerMiddleware/task.ts\nvar validateActive = (signal) => {\n  if (signal.aborted) {\n    const {\n      reason\n    } = signal;\n    throw new TaskAbortError(reason);\n  }\n};\nfunction raceWithSignal(signal, promise) {\n  let cleanup = noop2;\n  return new Promise((resolve, reject) => {\n    const notifyRejection = () => reject(new TaskAbortError(signal.reason));\n    if (signal.aborted) {\n      notifyRejection();\n      return;\n    }\n    cleanup = addAbortSignalListener(signal, notifyRejection);\n    promise.finally(() => cleanup()).then(resolve, reject);\n  }).finally(() => {\n    cleanup = noop2;\n  });\n}\nvar runTask = async (task2, cleanUp) => {\n  try {\n    await Promise.resolve();\n    const value = await task2();\n    return {\n      status: \"ok\",\n      value\n    };\n  } catch (error) {\n    return {\n      status: error instanceof TaskAbortError ? \"cancelled\" : \"rejected\",\n      error\n    };\n  } finally {\n    cleanUp?.();\n  }\n};\nvar createPause = (signal) => {\n  return (promise) => {\n    return catchRejection(raceWithSignal(signal, promise).then((output) => {\n      validateActive(signal);\n      return output;\n    }));\n  };\n};\nvar createDelay = (signal) => {\n  const pause = createPause(signal);\n  return (timeoutMs) => {\n    return pause(new Promise((resolve) => setTimeout(resolve, timeoutMs)));\n  };\n};\n\n// src/listenerMiddleware/index.ts\nvar {\n  assign\n} = Object;\nvar INTERNAL_NIL_TOKEN = {};\nvar alm = \"listenerMiddleware\";\nvar createFork = (parentAbortSignal, parentBlockingPromises) => {\n  const linkControllers = (controller) => addAbortSignalListener(parentAbortSignal, () => abortControllerWithReason(controller, parentAbortSignal.reason));\n  return (taskExecutor, opts) => {\n    assertFunction(taskExecutor, \"taskExecutor\");\n    const childAbortController = new AbortController();\n    linkControllers(childAbortController);\n    const result = runTask(async () => {\n      validateActive(parentAbortSignal);\n      validateActive(childAbortController.signal);\n      const result2 = await taskExecutor({\n        pause: createPause(childAbortController.signal),\n        delay: createDelay(childAbortController.signal),\n        signal: childAbortController.signal\n      });\n      validateActive(childAbortController.signal);\n      return result2;\n    }, () => abortControllerWithReason(childAbortController, taskCompleted));\n    if (opts?.autoJoin) {\n      parentBlockingPromises.push(result.catch(noop2));\n    }\n    return {\n      result: createPause(parentAbortSignal)(result),\n      cancel() {\n        abortControllerWithReason(childAbortController, taskCancelled);\n      }\n    };\n  };\n};\nvar createTakePattern = (startListening, signal) => {\n  const take = async (predicate, timeout) => {\n    validateActive(signal);\n    let unsubscribe = () => {\n    };\n    const tuplePromise = new Promise((resolve, reject) => {\n      let stopListening = startListening({\n        predicate,\n        effect: (action, listenerApi) => {\n          listenerApi.unsubscribe();\n          resolve([action, listenerApi.getState(), listenerApi.getOriginalState()]);\n        }\n      });\n      unsubscribe = () => {\n        stopListening();\n        reject();\n      };\n    });\n    const promises = [tuplePromise];\n    if (timeout != null) {\n      promises.push(new Promise((resolve) => setTimeout(resolve, timeout, null)));\n    }\n    try {\n      const output = await raceWithSignal(signal, Promise.race(promises));\n      validateActive(signal);\n      return output;\n    } finally {\n      unsubscribe();\n    }\n  };\n  return (predicate, timeout) => catchRejection(take(predicate, timeout));\n};\nvar getListenerEntryPropsFrom = (options) => {\n  let {\n    type,\n    actionCreator,\n    matcher,\n    predicate,\n    effect\n  } = options;\n  if (type) {\n    predicate = createAction(type).match;\n  } else if (actionCreator) {\n    type = actionCreator.type;\n    predicate = actionCreator.match;\n  } else if (matcher) {\n    predicate = matcher;\n  } else if (predicate) {\n  } else {\n    throw new Error( false ? 0 : \"Creating or removing a listener requires one of the known fields for matching an action\");\n  }\n  assertFunction(effect, \"options.listener\");\n  return {\n    predicate,\n    type,\n    effect\n  };\n};\nvar createListenerEntry = /* @__PURE__ */ assign((options) => {\n  const {\n    type,\n    predicate,\n    effect\n  } = getListenerEntryPropsFrom(options);\n  const entry = {\n    id: nanoid(),\n    effect,\n    type,\n    predicate,\n    pending: /* @__PURE__ */ new Set(),\n    unsubscribe: () => {\n      throw new Error( false ? 0 : \"Unsubscribe not initialized\");\n    }\n  };\n  return entry;\n}, {\n  withTypes: () => createListenerEntry\n});\nvar findListenerEntry = (listenerMap, options) => {\n  const {\n    type,\n    effect,\n    predicate\n  } = getListenerEntryPropsFrom(options);\n  return Array.from(listenerMap.values()).find((entry) => {\n    const matchPredicateOrType = typeof type === \"string\" ? entry.type === type : entry.predicate === predicate;\n    return matchPredicateOrType && entry.effect === effect;\n  });\n};\nvar cancelActiveListeners = (entry) => {\n  entry.pending.forEach((controller) => {\n    abortControllerWithReason(controller, listenerCancelled);\n  });\n};\nvar createClearListenerMiddleware = (listenerMap, executingListeners) => {\n  return () => {\n    for (const listener2 of executingListeners.keys()) {\n      cancelActiveListeners(listener2);\n    }\n    listenerMap.clear();\n  };\n};\nvar safelyNotifyError = (errorHandler, errorToNotify, errorInfo) => {\n  try {\n    errorHandler(errorToNotify, errorInfo);\n  } catch (errorHandlerError) {\n    setTimeout(() => {\n      throw errorHandlerError;\n    }, 0);\n  }\n};\nvar addListener = /* @__PURE__ */ assign(/* @__PURE__ */ createAction(`${alm}/add`), {\n  withTypes: () => addListener\n});\nvar clearAllListeners = /* @__PURE__ */ createAction(`${alm}/removeAll`);\nvar removeListener = /* @__PURE__ */ assign(/* @__PURE__ */ createAction(`${alm}/remove`), {\n  withTypes: () => removeListener\n});\nvar defaultErrorHandler = (...args) => {\n  console.error(`${alm}/error`, ...args);\n};\nvar createListenerMiddleware = (middlewareOptions = {}) => {\n  const listenerMap = /* @__PURE__ */ new Map();\n  const executingListeners = /* @__PURE__ */ new Map();\n  const trackExecutingListener = (entry) => {\n    const count = executingListeners.get(entry) ?? 0;\n    executingListeners.set(entry, count + 1);\n  };\n  const untrackExecutingListener = (entry) => {\n    const count = executingListeners.get(entry) ?? 1;\n    if (count === 1) {\n      executingListeners.delete(entry);\n    } else {\n      executingListeners.set(entry, count - 1);\n    }\n  };\n  const {\n    extra,\n    onError = defaultErrorHandler\n  } = middlewareOptions;\n  assertFunction(onError, \"onError\");\n  const insertEntry = (entry) => {\n    entry.unsubscribe = () => listenerMap.delete(entry.id);\n    listenerMap.set(entry.id, entry);\n    return (cancelOptions) => {\n      entry.unsubscribe();\n      if (cancelOptions?.cancelActive) {\n        cancelActiveListeners(entry);\n      }\n    };\n  };\n  const startListening = (options) => {\n    const entry = findListenerEntry(listenerMap, options) ?? createListenerEntry(options);\n    return insertEntry(entry);\n  };\n  assign(startListening, {\n    withTypes: () => startListening\n  });\n  const stopListening = (options) => {\n    const entry = findListenerEntry(listenerMap, options);\n    if (entry) {\n      entry.unsubscribe();\n      if (options.cancelActive) {\n        cancelActiveListeners(entry);\n      }\n    }\n    return !!entry;\n  };\n  assign(stopListening, {\n    withTypes: () => stopListening\n  });\n  const notifyListener = async (entry, action, api, getOriginalState) => {\n    const internalTaskController = new AbortController();\n    const take = createTakePattern(startListening, internalTaskController.signal);\n    const autoJoinPromises = [];\n    try {\n      entry.pending.add(internalTaskController);\n      trackExecutingListener(entry);\n      await Promise.resolve(entry.effect(\n        action,\n        // Use assign() rather than ... to avoid extra helper functions added to bundle\n        assign({}, api, {\n          getOriginalState,\n          condition: (predicate, timeout) => take(predicate, timeout).then(Boolean),\n          take,\n          delay: createDelay(internalTaskController.signal),\n          pause: createPause(internalTaskController.signal),\n          extra,\n          signal: internalTaskController.signal,\n          fork: createFork(internalTaskController.signal, autoJoinPromises),\n          unsubscribe: entry.unsubscribe,\n          subscribe: () => {\n            listenerMap.set(entry.id, entry);\n          },\n          cancelActiveListeners: () => {\n            entry.pending.forEach((controller, _, set) => {\n              if (controller !== internalTaskController) {\n                abortControllerWithReason(controller, listenerCancelled);\n                set.delete(controller);\n              }\n            });\n          },\n          cancel: () => {\n            abortControllerWithReason(internalTaskController, listenerCancelled);\n            entry.pending.delete(internalTaskController);\n          },\n          throwIfCancelled: () => {\n            validateActive(internalTaskController.signal);\n          }\n        })\n      ));\n    } catch (listenerError) {\n      if (!(listenerError instanceof TaskAbortError)) {\n        safelyNotifyError(onError, listenerError, {\n          raisedBy: \"effect\"\n        });\n      }\n    } finally {\n      await Promise.all(autoJoinPromises);\n      abortControllerWithReason(internalTaskController, listenerCompleted);\n      untrackExecutingListener(entry);\n      entry.pending.delete(internalTaskController);\n    }\n  };\n  const clearListenerMiddleware = createClearListenerMiddleware(listenerMap, executingListeners);\n  const middleware = (api) => (next) => (action) => {\n    if (!(0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action)) {\n      return next(action);\n    }\n    if (addListener.match(action)) {\n      return startListening(action.payload);\n    }\n    if (clearAllListeners.match(action)) {\n      clearListenerMiddleware();\n      return;\n    }\n    if (removeListener.match(action)) {\n      return stopListening(action.payload);\n    }\n    let originalState = api.getState();\n    const getOriginalState = () => {\n      if (originalState === INTERNAL_NIL_TOKEN) {\n        throw new Error( false ? 0 : `${alm}: getOriginalState can only be called synchronously`);\n      }\n      return originalState;\n    };\n    let result;\n    try {\n      result = next(action);\n      if (listenerMap.size > 0) {\n        const currentState = api.getState();\n        const listenerEntries = Array.from(listenerMap.values());\n        for (const entry of listenerEntries) {\n          let runListener = false;\n          try {\n            runListener = entry.predicate(action, currentState, originalState);\n          } catch (predicateError) {\n            runListener = false;\n            safelyNotifyError(onError, predicateError, {\n              raisedBy: \"predicate\"\n            });\n          }\n          if (!runListener) {\n            continue;\n          }\n          notifyListener(entry, action, api, getOriginalState);\n        }\n      }\n    } finally {\n      originalState = INTERNAL_NIL_TOKEN;\n    }\n    return result;\n  };\n  return {\n    middleware,\n    startListening,\n    stopListening,\n    clearListeners: clearListenerMiddleware\n  };\n};\n\n// src/dynamicMiddleware/index.ts\n\nvar createMiddlewareEntry = (middleware) => ({\n  middleware,\n  applied: /* @__PURE__ */ new Map()\n});\nvar matchInstance = (instanceId) => (action) => action?.meta?.instanceId === instanceId;\nvar createDynamicMiddleware = () => {\n  const instanceId = nanoid();\n  const middlewareMap = /* @__PURE__ */ new Map();\n  const withMiddleware = Object.assign(createAction(\"dynamicMiddleware/add\", (...middlewares) => ({\n    payload: middlewares,\n    meta: {\n      instanceId\n    }\n  })), {\n    withTypes: () => withMiddleware\n  });\n  const addMiddleware = Object.assign(function addMiddleware2(...middlewares) {\n    middlewares.forEach((middleware2) => {\n      getOrInsertComputed(middlewareMap, middleware2, createMiddlewareEntry);\n    });\n  }, {\n    withTypes: () => addMiddleware\n  });\n  const getFinalMiddleware = (api) => {\n    const appliedMiddleware = Array.from(middlewareMap.values()).map((entry) => getOrInsertComputed(entry.applied, api, entry.middleware));\n    return (0,redux__WEBPACK_IMPORTED_MODULE_0__.compose)(...appliedMiddleware);\n  };\n  const isWithMiddleware = isAllOf(withMiddleware, matchInstance(instanceId));\n  const middleware = (api) => (next) => (action) => {\n    if (isWithMiddleware(action)) {\n      addMiddleware(...action.payload);\n      return api.dispatch;\n    }\n    return getFinalMiddleware(api)(next)(action);\n  };\n  return {\n    middleware,\n    addMiddleware,\n    withMiddleware,\n    instanceId\n  };\n};\n\n// src/combineSlices.ts\n\nvar isSliceLike = (maybeSliceLike) => \"reducerPath\" in maybeSliceLike && typeof maybeSliceLike.reducerPath === \"string\";\nvar getReducers = (slices) => slices.flatMap((sliceOrMap) => isSliceLike(sliceOrMap) ? [[sliceOrMap.reducerPath, sliceOrMap.reducer]] : Object.entries(sliceOrMap));\nvar ORIGINAL_STATE = Symbol.for(\"rtk-state-proxy-original\");\nvar isStateProxy = (value) => !!value && !!value[ORIGINAL_STATE];\nvar stateProxyMap = /* @__PURE__ */ new WeakMap();\nvar createStateProxy = (state, reducerMap, initialStateCache) => getOrInsertComputed(stateProxyMap, state, () => new Proxy(state, {\n  get: (target, prop, receiver) => {\n    if (prop === ORIGINAL_STATE) return target;\n    const result = Reflect.get(target, prop, receiver);\n    if (typeof result === \"undefined\") {\n      const cached = initialStateCache[prop];\n      if (typeof cached !== \"undefined\") return cached;\n      const reducer = reducerMap[prop];\n      if (reducer) {\n        const reducerResult = reducer(void 0, {\n          type: nanoid()\n        });\n        if (typeof reducerResult === \"undefined\") {\n          throw new Error( false ? 0 : `The slice reducer for key \"${prop.toString()}\" returned undefined when called for selector(). If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);\n        }\n        initialStateCache[prop] = reducerResult;\n        return reducerResult;\n      }\n    }\n    return result;\n  }\n}));\nvar original = (state) => {\n  if (!isStateProxy(state)) {\n    throw new Error( false ? 0 : \"original must be used on state Proxy\");\n  }\n  return state[ORIGINAL_STATE];\n};\nvar emptyObject = {};\nvar noopReducer = (state = emptyObject) => state;\nfunction combineSlices(...slices) {\n  const reducerMap = Object.fromEntries(getReducers(slices));\n  const getReducer = () => Object.keys(reducerMap).length ? (0,redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers)(reducerMap) : noopReducer;\n  let reducer = getReducer();\n  function combinedReducer(state, action) {\n    return reducer(state, action);\n  }\n  combinedReducer.withLazyLoadedSlices = () => combinedReducer;\n  const initialStateCache = {};\n  const inject = (slice, config = {}) => {\n    const {\n      reducerPath,\n      reducer: reducerToInject\n    } = slice;\n    const currentReducer = reducerMap[reducerPath];\n    if (!config.overrideExisting && currentReducer && currentReducer !== reducerToInject) {\n      if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n        console.error(`called \\`inject\\` to override already-existing reducer ${reducerPath} without specifying \\`overrideExisting: true\\``);\n      }\n      return combinedReducer;\n    }\n    if (config.overrideExisting && currentReducer !== reducerToInject) {\n      delete initialStateCache[reducerPath];\n    }\n    reducerMap[reducerPath] = reducerToInject;\n    reducer = getReducer();\n    return combinedReducer;\n  };\n  const selector = Object.assign(function makeSelector(selectorFn, selectState) {\n    return function selector2(state, ...args) {\n      return selectorFn(createStateProxy(selectState ? selectState(state, ...args) : state, reducerMap, initialStateCache), ...args);\n    };\n  }, {\n    original\n  });\n  return Object.assign(combinedReducer, {\n    inject,\n    selector\n  });\n}\n\n// src/formatProdErrorMessage.ts\nfunction formatProdErrorMessage(code) {\n  return `Minified Redux Toolkit error #${code}; visit https://redux-toolkit.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;\n}\n\n//# sourceMappingURL=redux-toolkit.modern.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9kaXN0L3JlZHV4LXRvb2xraXQubW9kZXJuLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNzQjtBQUNtRjtBQUNpQzs7QUFFMUk7QUFDeUM7QUFDd0I7QUFDakU7QUFDQSwwQkFBMEIsK0RBQXFCO0FBQy9DO0FBQ0E7QUFDQSx5REFBeUQsOENBQU8sVUFBVSw4Q0FBTztBQUNqRjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw2RUFBNkUsb0RBQWM7O0FBRTNGO0FBQzRIOztBQUU1SDtBQUNnQztBQUNoQztBQUNBO0FBQ0EsK0NBQStDLDBDQUFPO0FBQ3RELFNBQVMsMENBQU87QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzBFOztBQUUxRTtBQUNpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE1BQXFDLEdBQUcsQ0FBeUI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEtBQUs7QUFDekM7QUFDQSxvQ0FBb0MsK0NBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLCtDQUFRO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsS0FBSztBQUNuQztBQUNBLGtEQUFrRCxrQkFBa0I7QUFDcEUsa0ZBQWtGLFdBQVcsOEJBQThCLFdBQVc7QUFDdEk7QUFDQSw0REFBNEQ7QUFDNUQsTUFBTSxLQUFxQyxFQUFFLEVBRTFDO0FBQ0g7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdCQUF3QixRQUFRLE9BQU8sUUFBUSxrREFBa0QsU0FBUztBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsa0RBQVcsUUFBUSw4Q0FBZTtBQUMzQyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdELE1BQU0sS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQXFDLEdBQUcsQ0FBMEIscUVBQXFFLGtCQUFrQjtBQUNyTDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBcUMsR0FBRyxDQUEwQixvRUFBb0Usa0JBQWtCLHNEQUFzRCxtQkFBbUI7QUFDN1A7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzZEO0FBQzdEO0FBQ0E7QUFDQSw4R0FBOEcsb0RBQWE7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRSxNQUFNLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxXQUFXLCtDQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsZ0dBQWdHLFFBQVE7QUFDeEc7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGdHQUFnRyxRQUFRO0FBQ3hHLDJEQUEyRCxZQUFZO0FBQ3ZFO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4Q0FBZTtBQUMxQyxNQUFNO0FBQ04sMkJBQTJCLDhEQUFpQjtBQUM1QztBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJLFNBQVMsb0RBQWM7QUFDM0Isa0JBQWtCLHNEQUFlO0FBQ2pDLElBQUk7QUFDSixvQkFBb0IsTUFBcUMsR0FBRyxDQUF5QjtBQUNyRjtBQUNBLE1BQU0sS0FBcUM7QUFDM0Msb0JBQW9CLE1BQXFDLEdBQUcsQ0FBeUI7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXFDO0FBQzdDLHNCQUFzQixNQUFxQyxHQUFHLENBQXlCO0FBQ3ZGO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDLG9CQUFvQixNQUFxQyxHQUFHLENBQXlCO0FBQ3JGO0FBQ0EsTUFBTSxLQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsTUFBcUMsR0FBRyxDQUEwQjtBQUMxRjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EscUJBQXFCLDBDQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBb0I7QUFDakM7QUFDQSxLQUFLO0FBQ0w7QUFDQSw2QkFBNkIsc0RBQWU7QUFDNUM7QUFDQSxNQUFNLEtBQXFDO0FBQzNDLG9CQUFvQixNQUFxQyxHQUFHLENBQXlCO0FBQ3JGO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDLG9CQUFvQixNQUFxQyxHQUFHLENBQXlCO0FBQ3JGO0FBQ0EsTUFBTSxLQUFxQztBQUMzQyxvQkFBb0IsTUFBcUMsR0FBRyxDQUF5QjtBQUNyRjtBQUNBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsU0FBUyxrREFBVztBQUNwQjs7QUFFQTtBQUNzRzs7QUFFdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLElBQXFDO0FBQy9DO0FBQ0EsMEJBQTBCLE1BQXFDLEdBQUcsQ0FBMEI7QUFDNUY7QUFDQTtBQUNBLDBCQUEwQixNQUFxQyxHQUFHLENBQTBCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE1BQXFDLEdBQUcsQ0FBMEI7QUFDMUY7QUFDQTtBQUNBLHdCQUF3QixNQUFxQyxHQUFHLENBQTBCLHVGQUF1RixLQUFLO0FBQ3RMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFVBQVUsSUFBcUM7QUFDL0M7QUFDQSwwQkFBMEIsTUFBcUMsR0FBRyxDQUEwQjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0EsVUFBVSxJQUFxQztBQUMvQztBQUNBLDBCQUEwQixNQUFxQyxHQUFHLENBQTBCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQSxVQUFVLElBQXFDO0FBQy9DO0FBQ0EsMEJBQTBCLE1BQXFDLEdBQUcsQ0FBMEI7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0Esc0JBQXNCLE1BQXFDLEdBQUcsQ0FBeUI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4Q0FBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFVBQVUsa0RBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixpQkFBaUIsOENBQWdCO0FBQ2pDO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsTUFBTSxJQUFJO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4Q0FBZ0I7QUFDM0I7QUFDQTs7QUFFQTtBQUNpRTtBQUNqRTtBQUNBO0FBQ0EsTUFBTSxLQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4Q0FBUSxVQUFVLDhDQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNB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dXJjZXMiOlsiL2hvbWUvcHJvamVjdC9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9kaXN0L3JlZHV4LXRvb2xraXQubW9kZXJuLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJyZWR1eFwiO1xuaW1wb3J0IHsgcHJvZHVjZSwgY3VycmVudCBhcyBjdXJyZW50MywgZnJlZXplLCBvcmlnaW5hbCBhcyBvcmlnaW5hbDIsIGlzRHJhZnQgYXMgaXNEcmFmdDUgfSBmcm9tIFwiaW1tZXJcIjtcbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yLCBjcmVhdGVTZWxlY3RvckNyZWF0b3IgYXMgY3JlYXRlU2VsZWN0b3JDcmVhdG9yMiwgbHJ1TWVtb2l6ZSwgd2Vha01hcE1lbW9pemUgYXMgd2Vha01hcE1lbW9pemUyIH0gZnJvbSBcInJlc2VsZWN0XCI7XG5cbi8vIHNyYy9jcmVhdGVEcmFmdFNhZmVTZWxlY3Rvci50c1xuaW1wb3J0IHsgY3VycmVudCwgaXNEcmFmdCB9IGZyb20gXCJpbW1lclwiO1xuaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3JDcmVhdG9yLCB3ZWFrTWFwTWVtb2l6ZSB9IGZyb20gXCJyZXNlbGVjdFwiO1xudmFyIGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yQ3JlYXRvciA9ICguLi5hcmdzKSA9PiB7XG4gIGNvbnN0IGNyZWF0ZVNlbGVjdG9yMiA9IGNyZWF0ZVNlbGVjdG9yQ3JlYXRvciguLi5hcmdzKTtcbiAgY29uc3QgY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IyID0gT2JqZWN0LmFzc2lnbigoLi4uYXJnczIpID0+IHtcbiAgICBjb25zdCBzZWxlY3RvciA9IGNyZWF0ZVNlbGVjdG9yMiguLi5hcmdzMik7XG4gICAgY29uc3Qgd3JhcHBlZFNlbGVjdG9yID0gKHZhbHVlLCAuLi5yZXN0KSA9PiBzZWxlY3Rvcihpc0RyYWZ0KHZhbHVlKSA/IGN1cnJlbnQodmFsdWUpIDogdmFsdWUsIC4uLnJlc3QpO1xuICAgIE9iamVjdC5hc3NpZ24od3JhcHBlZFNlbGVjdG9yLCBzZWxlY3Rvcik7XG4gICAgcmV0dXJuIHdyYXBwZWRTZWxlY3RvcjtcbiAgfSwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IyXG4gIH0pO1xuICByZXR1cm4gY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IyO1xufTtcbnZhciBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvciA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvckNyZWF0b3Iod2Vha01hcE1lbW9pemUpO1xuXG4vLyBzcmMvY29uZmlndXJlU3RvcmUudHNcbmltcG9ydCB7IGFwcGx5TWlkZGxld2FyZSwgY3JlYXRlU3RvcmUsIGNvbXBvc2UgYXMgY29tcG9zZTIsIGNvbWJpbmVSZWR1Y2VycywgaXNQbGFpbk9iamVjdCBhcyBpc1BsYWluT2JqZWN0MiB9IGZyb20gXCJyZWR1eFwiO1xuXG4vLyBzcmMvZGV2dG9vbHNFeHRlbnNpb24udHNcbmltcG9ydCB7IGNvbXBvc2UgfSBmcm9tIFwicmVkdXhcIjtcbnZhciBjb21wb3NlV2l0aERldlRvb2xzID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fID8gd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX0NPTVBPU0VfXyA6IGZ1bmN0aW9uKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHZvaWQgMDtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09IFwib2JqZWN0XCIpIHJldHVybiBjb21wb3NlO1xuICByZXR1cm4gY29tcG9zZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcbnZhciBkZXZUb29sc0VuaGFuY2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXyA/IHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fIDogZnVuY3Rpb24oKSB7XG4gIHJldHVybiBmdW5jdGlvbihub29wMykge1xuICAgIHJldHVybiBub29wMztcbiAgfTtcbn07XG5cbi8vIHNyYy9nZXREZWZhdWx0TWlkZGxld2FyZS50c1xuaW1wb3J0IHsgdGh1bmsgYXMgdGh1bmtNaWRkbGV3YXJlLCB3aXRoRXh0cmFBcmd1bWVudCB9IGZyb20gXCJyZWR1eC10aHVua1wiO1xuXG4vLyBzcmMvY3JlYXRlQWN0aW9uLnRzXG5pbXBvcnQgeyBpc0FjdGlvbiB9IGZyb20gXCJyZWR1eFwiO1xuXG4vLyBzcmMvdHNIZWxwZXJzLnRzXG52YXIgaGFzTWF0Y2hGdW5jdGlvbiA9ICh2KSA9PiB7XG4gIHJldHVybiB2ICYmIHR5cGVvZiB2Lm1hdGNoID09PSBcImZ1bmN0aW9uXCI7XG59O1xuXG4vLyBzcmMvY3JlYXRlQWN0aW9uLnRzXG5mdW5jdGlvbiBjcmVhdGVBY3Rpb24odHlwZSwgcHJlcGFyZUFjdGlvbikge1xuICBmdW5jdGlvbiBhY3Rpb25DcmVhdG9yKC4uLmFyZ3MpIHtcbiAgICBpZiAocHJlcGFyZUFjdGlvbikge1xuICAgICAgbGV0IHByZXBhcmVkID0gcHJlcGFyZUFjdGlvbiguLi5hcmdzKTtcbiAgICAgIGlmICghcHJlcGFyZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMCkgOiBcInByZXBhcmVBY3Rpb24gZGlkIG5vdCByZXR1cm4gYW4gb2JqZWN0XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcGF5bG9hZDogcHJlcGFyZWQucGF5bG9hZCxcbiAgICAgICAgLi4uXCJtZXRhXCIgaW4gcHJlcGFyZWQgJiYge1xuICAgICAgICAgIG1ldGE6IHByZXBhcmVkLm1ldGFcbiAgICAgICAgfSxcbiAgICAgICAgLi4uXCJlcnJvclwiIGluIHByZXBhcmVkICYmIHtcbiAgICAgICAgICBlcnJvcjogcHJlcGFyZWQuZXJyb3JcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGUsXG4gICAgICBwYXlsb2FkOiBhcmdzWzBdXG4gICAgfTtcbiAgfVxuICBhY3Rpb25DcmVhdG9yLnRvU3RyaW5nID0gKCkgPT4gYCR7dHlwZX1gO1xuICBhY3Rpb25DcmVhdG9yLnR5cGUgPSB0eXBlO1xuICBhY3Rpb25DcmVhdG9yLm1hdGNoID0gKGFjdGlvbikgPT4gaXNBY3Rpb24oYWN0aW9uKSAmJiBhY3Rpb24udHlwZSA9PT0gdHlwZTtcbiAgcmV0dXJuIGFjdGlvbkNyZWF0b3I7XG59XG5mdW5jdGlvbiBpc0FjdGlvbkNyZWF0b3IoYWN0aW9uKSB7XG4gIHJldHVybiB0eXBlb2YgYWN0aW9uID09PSBcImZ1bmN0aW9uXCIgJiYgXCJ0eXBlXCIgaW4gYWN0aW9uICYmIC8vIGhhc01hdGNoRnVuY3Rpb24gb25seSB3YW50cyBNYXRjaGVycyBidXQgSSBkb24ndCBzZWUgdGhlIHBvaW50IGluIHJld3JpdGluZyBpdFxuICBoYXNNYXRjaEZ1bmN0aW9uKGFjdGlvbik7XG59XG5mdW5jdGlvbiBpc0ZTQShhY3Rpb24pIHtcbiAgcmV0dXJuIGlzQWN0aW9uKGFjdGlvbikgJiYgT2JqZWN0LmtleXMoYWN0aW9uKS5ldmVyeShpc1ZhbGlkS2V5KTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRLZXkoa2V5KSB7XG4gIHJldHVybiBbXCJ0eXBlXCIsIFwicGF5bG9hZFwiLCBcImVycm9yXCIsIFwibWV0YVwiXS5pbmRleE9mKGtleSkgPiAtMTtcbn1cblxuLy8gc3JjL2FjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBnZXRNZXNzYWdlKHR5cGUpIHtcbiAgY29uc3Qgc3BsaXRUeXBlID0gdHlwZSA/IGAke3R5cGV9YC5zcGxpdChcIi9cIikgOiBbXTtcbiAgY29uc3QgYWN0aW9uTmFtZSA9IHNwbGl0VHlwZVtzcGxpdFR5cGUubGVuZ3RoIC0gMV0gfHwgXCJhY3Rpb25DcmVhdG9yXCI7XG4gIHJldHVybiBgRGV0ZWN0ZWQgYW4gYWN0aW9uIGNyZWF0b3Igd2l0aCB0eXBlIFwiJHt0eXBlIHx8IFwidW5rbm93blwifVwiIGJlaW5nIGRpc3BhdGNoZWQuIFxuTWFrZSBzdXJlIHlvdSdyZSBjYWxsaW5nIHRoZSBhY3Rpb24gY3JlYXRvciBiZWZvcmUgZGlzcGF0Y2hpbmcsIGkuZS4gXFxgZGlzcGF0Y2goJHthY3Rpb25OYW1lfSgpKVxcYCBpbnN0ZWFkIG9mIFxcYGRpc3BhdGNoKCR7YWN0aW9uTmFtZX0pXFxgLiBUaGlzIGlzIG5lY2Vzc2FyeSBldmVuIGlmIHRoZSBhY3Rpb24gaGFzIG5vIHBheWxvYWQuYDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlKG9wdGlvbnMgPSB7fSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgcmV0dXJuICgpID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiBuZXh0KGFjdGlvbik7XG4gIH1cbiAgY29uc3Qge1xuICAgIGlzQWN0aW9uQ3JlYXRvcjogaXNBY3Rpb25DcmVhdG9yMiA9IGlzQWN0aW9uQ3JlYXRvclxuICB9ID0gb3B0aW9ucztcbiAgcmV0dXJuICgpID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiB7XG4gICAgaWYgKGlzQWN0aW9uQ3JlYXRvcjIoYWN0aW9uKSkge1xuICAgICAgY29uc29sZS53YXJuKGdldE1lc3NhZ2UoYWN0aW9uLnR5cGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQoYWN0aW9uKTtcbiAgfTtcbn1cblxuLy8gc3JjL3V0aWxzLnRzXG5pbXBvcnQgeyBwcm9kdWNlIGFzIGNyZWF0ZU5leHRTdGF0ZSwgaXNEcmFmdGFibGUgfSBmcm9tIFwiaW1tZXJcIjtcbmZ1bmN0aW9uIGdldFRpbWVNZWFzdXJlVXRpbHMobWF4RGVsYXksIGZuTmFtZSkge1xuICBsZXQgZWxhcHNlZCA9IDA7XG4gIHJldHVybiB7XG4gICAgbWVhc3VyZVRpbWUoZm4pIHtcbiAgICAgIGNvbnN0IHN0YXJ0ZWQgPSBEYXRlLm5vdygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjb25zdCBmaW5pc2hlZCA9IERhdGUubm93KCk7XG4gICAgICAgIGVsYXBzZWQgKz0gZmluaXNoZWQgLSBzdGFydGVkO1xuICAgICAgfVxuICAgIH0sXG4gICAgd2FybklmRXhjZWVkZWQoKSB7XG4gICAgICBpZiAoZWxhcHNlZCA+IG1heERlbGF5KSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgJHtmbk5hbWV9IHRvb2sgJHtlbGFwc2VkfW1zLCB3aGljaCBpcyBtb3JlIHRoYW4gdGhlIHdhcm5pbmcgdGhyZXNob2xkIG9mICR7bWF4RGVsYXl9bXMuIFxuSWYgeW91ciBzdGF0ZSBvciBhY3Rpb25zIGFyZSB2ZXJ5IGxhcmdlLCB5b3UgbWF5IHdhbnQgdG8gZGlzYWJsZSB0aGUgbWlkZGxld2FyZSBhcyBpdCBtaWdodCBjYXVzZSB0b28gbXVjaCBvZiBhIHNsb3dkb3duIGluIGRldmVsb3BtZW50IG1vZGUuIFNlZSBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL2FwaS9nZXREZWZhdWx0TWlkZGxld2FyZSBmb3IgaW5zdHJ1Y3Rpb25zLlxuSXQgaXMgZGlzYWJsZWQgaW4gcHJvZHVjdGlvbiBidWlsZHMsIHNvIHlvdSBkb24ndCBuZWVkIHRvIHdvcnJ5IGFib3V0IHRoYXQuYCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxudmFyIFR1cGxlID0gY2xhc3MgX1R1cGxlIGV4dGVuZHMgQXJyYXkge1xuICBjb25zdHJ1Y3RvciguLi5pdGVtcykge1xuICAgIHN1cGVyKC4uLml0ZW1zKTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgX1R1cGxlLnByb3RvdHlwZSk7XG4gIH1cbiAgc3RhdGljIGdldCBbU3ltYm9sLnNwZWNpZXNdKCkge1xuICAgIHJldHVybiBfVHVwbGU7XG4gIH1cbiAgY29uY2F0KC4uLmFycikge1xuICAgIHJldHVybiBzdXBlci5jb25jYXQuYXBwbHkodGhpcywgYXJyKTtcbiAgfVxuICBwcmVwZW5kKC4uLmFycikge1xuICAgIGlmIChhcnIubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkoYXJyWzBdKSkge1xuICAgICAgcmV0dXJuIG5ldyBfVHVwbGUoLi4uYXJyWzBdLmNvbmNhdCh0aGlzKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgX1R1cGxlKC4uLmFyci5jb25jYXQodGhpcykpO1xuICB9XG59O1xuZnVuY3Rpb24gZnJlZXplRHJhZnRhYmxlKHZhbCkge1xuICByZXR1cm4gaXNEcmFmdGFibGUodmFsKSA/IGNyZWF0ZU5leHRTdGF0ZSh2YWwsICgpID0+IHtcbiAgfSkgOiB2YWw7XG59XG5mdW5jdGlvbiBnZXRPckluc2VydENvbXB1dGVkKG1hcCwga2V5LCBjb21wdXRlKSB7XG4gIGlmIChtYXAuaGFzKGtleSkpIHJldHVybiBtYXAuZ2V0KGtleSk7XG4gIHJldHVybiBtYXAuc2V0KGtleSwgY29tcHV0ZShrZXkpKS5nZXQoa2V5KTtcbn1cblxuLy8gc3JjL2ltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZS50c1xuZnVuY3Rpb24gaXNJbW11dGFibGVEZWZhdWx0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT0gbnVsbCB8fCBPYmplY3QuaXNGcm96ZW4odmFsdWUpO1xufVxuZnVuY3Rpb24gdHJhY2tGb3JNdXRhdGlvbnMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzLCBvYmopIHtcbiAgY29uc3QgdHJhY2tlZFByb3BlcnRpZXMgPSB0cmFja1Byb3BlcnRpZXMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzLCBvYmopO1xuICByZXR1cm4ge1xuICAgIGRldGVjdE11dGF0aW9ucygpIHtcbiAgICAgIHJldHVybiBkZXRlY3RNdXRhdGlvbnMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzLCB0cmFja2VkUHJvcGVydGllcywgb2JqKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiB0cmFja1Byb3BlcnRpZXMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzID0gW10sIG9iaiwgcGF0aCA9IFwiXCIsIGNoZWNrZWRPYmplY3RzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSkge1xuICBjb25zdCB0cmFja2VkID0ge1xuICAgIHZhbHVlOiBvYmpcbiAgfTtcbiAgaWYgKCFpc0ltbXV0YWJsZShvYmopICYmICFjaGVja2VkT2JqZWN0cy5oYXMob2JqKSkge1xuICAgIGNoZWNrZWRPYmplY3RzLmFkZChvYmopO1xuICAgIHRyYWNrZWQuY2hpbGRyZW4gPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgIGNvbnN0IGNoaWxkUGF0aCA9IHBhdGggPyBwYXRoICsgXCIuXCIgKyBrZXkgOiBrZXk7XG4gICAgICBpZiAoaWdub3JlUGF0aHMubGVuZ3RoICYmIGlnbm9yZVBhdGhzLmluZGV4T2YoY2hpbGRQYXRoKSAhPT0gLTEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0cmFja2VkLmNoaWxkcmVuW2tleV0gPSB0cmFja1Byb3BlcnRpZXMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzLCBvYmpba2V5XSwgY2hpbGRQYXRoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRyYWNrZWQ7XG59XG5mdW5jdGlvbiBkZXRlY3RNdXRhdGlvbnMoaXNJbW11dGFibGUsIGlnbm9yZWRQYXRocyA9IFtdLCB0cmFja2VkUHJvcGVydHksIG9iaiwgc2FtZVBhcmVudFJlZiA9IGZhbHNlLCBwYXRoID0gXCJcIikge1xuICBjb25zdCBwcmV2T2JqID0gdHJhY2tlZFByb3BlcnR5ID8gdHJhY2tlZFByb3BlcnR5LnZhbHVlIDogdm9pZCAwO1xuICBjb25zdCBzYW1lUmVmID0gcHJldk9iaiA9PT0gb2JqO1xuICBpZiAoc2FtZVBhcmVudFJlZiAmJiAhc2FtZVJlZiAmJiAhTnVtYmVyLmlzTmFOKG9iaikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2FzTXV0YXRlZDogdHJ1ZSxcbiAgICAgIHBhdGhcbiAgICB9O1xuICB9XG4gIGlmIChpc0ltbXV0YWJsZShwcmV2T2JqKSB8fCBpc0ltbXV0YWJsZShvYmopKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdhc011dGF0ZWQ6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBjb25zdCBrZXlzVG9EZXRlY3QgPSB7fTtcbiAgZm9yIChsZXQga2V5IGluIHRyYWNrZWRQcm9wZXJ0eS5jaGlsZHJlbikge1xuICAgIGtleXNUb0RldGVjdFtrZXldID0gdHJ1ZTtcbiAgfVxuICBmb3IgKGxldCBrZXkgaW4gb2JqKSB7XG4gICAga2V5c1RvRGV0ZWN0W2tleV0gPSB0cnVlO1xuICB9XG4gIGNvbnN0IGhhc0lnbm9yZWRQYXRocyA9IGlnbm9yZWRQYXRocy5sZW5ndGggPiAwO1xuICBmb3IgKGxldCBrZXkgaW4ga2V5c1RvRGV0ZWN0KSB7XG4gICAgY29uc3QgbmVzdGVkUGF0aCA9IHBhdGggPyBwYXRoICsgXCIuXCIgKyBrZXkgOiBrZXk7XG4gICAgaWYgKGhhc0lnbm9yZWRQYXRocykge1xuICAgICAgY29uc3QgaGFzTWF0Y2hlcyA9IGlnbm9yZWRQYXRocy5zb21lKChpZ25vcmVkKSA9PiB7XG4gICAgICAgIGlmIChpZ25vcmVkIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgcmV0dXJuIGlnbm9yZWQudGVzdChuZXN0ZWRQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmVzdGVkUGF0aCA9PT0gaWdub3JlZDtcbiAgICAgIH0pO1xuICAgICAgaWYgKGhhc01hdGNoZXMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGRldGVjdE11dGF0aW9ucyhpc0ltbXV0YWJsZSwgaWdub3JlZFBhdGhzLCB0cmFja2VkUHJvcGVydHkuY2hpbGRyZW5ba2V5XSwgb2JqW2tleV0sIHNhbWVSZWYsIG5lc3RlZFBhdGgpO1xuICAgIGlmIChyZXN1bHQud2FzTXV0YXRlZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3YXNNdXRhdGVkOiBmYWxzZVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKG9wdGlvbnMgPSB7fSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgcmV0dXJuICgpID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiBuZXh0KGFjdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHN0cmluZ2lmeTIgPSBmdW5jdGlvbihvYmosIHNlcmlhbGl6ZXIsIGluZGVudCwgZGVjeWNsZXIpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmosIGdldFNlcmlhbGl6ZTIoc2VyaWFsaXplciwgZGVjeWNsZXIpLCBpbmRlbnQpO1xuICAgIH0sIGdldFNlcmlhbGl6ZTIgPSBmdW5jdGlvbihzZXJpYWxpemVyLCBkZWN5Y2xlcikge1xuICAgICAgbGV0IHN0YWNrID0gW10sIGtleXMgPSBbXTtcbiAgICAgIGlmICghZGVjeWNsZXIpIGRlY3ljbGVyID0gZnVuY3Rpb24oXywgdmFsdWUpIHtcbiAgICAgICAgaWYgKHN0YWNrWzBdID09PSB2YWx1ZSkgcmV0dXJuIFwiW0NpcmN1bGFyIH5dXCI7XG4gICAgICAgIHJldHVybiBcIltDaXJjdWxhciB+LlwiICsga2V5cy5zbGljZSgwLCBzdGFjay5pbmRleE9mKHZhbHVlKSkuam9pbihcIi5cIikgKyBcIl1cIjtcbiAgICAgIH07XG4gICAgICByZXR1cm4gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciB0aGlzUG9zID0gc3RhY2suaW5kZXhPZih0aGlzKTtcbiAgICAgICAgICB+dGhpc1BvcyA/IHN0YWNrLnNwbGljZSh0aGlzUG9zICsgMSkgOiBzdGFjay5wdXNoKHRoaXMpO1xuICAgICAgICAgIH50aGlzUG9zID8ga2V5cy5zcGxpY2UodGhpc1BvcywgSW5maW5pdHksIGtleSkgOiBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICBpZiAofnN0YWNrLmluZGV4T2YodmFsdWUpKSB2YWx1ZSA9IGRlY3ljbGVyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZXIgPT0gbnVsbCA/IHZhbHVlIDogc2VyaWFsaXplci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIHZhciBzdHJpbmdpZnkgPSBzdHJpbmdpZnkyLCBnZXRTZXJpYWxpemUgPSBnZXRTZXJpYWxpemUyO1xuICAgIGxldCB7XG4gICAgICBpc0ltbXV0YWJsZSA9IGlzSW1tdXRhYmxlRGVmYXVsdCxcbiAgICAgIGlnbm9yZWRQYXRocyxcbiAgICAgIHdhcm5BZnRlciA9IDMyXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgdHJhY2sgPSB0cmFja0Zvck11dGF0aW9ucy5iaW5kKG51bGwsIGlzSW1tdXRhYmxlLCBpZ25vcmVkUGF0aHMpO1xuICAgIHJldHVybiAoe1xuICAgICAgZ2V0U3RhdGVcbiAgICB9KSA9PiB7XG4gICAgICBsZXQgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgICAgbGV0IHRyYWNrZXIgPSB0cmFjayhzdGF0ZSk7XG4gICAgICBsZXQgcmVzdWx0O1xuICAgICAgcmV0dXJuIChuZXh0KSA9PiAoYWN0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IG1lYXN1cmVVdGlscyA9IGdldFRpbWVNZWFzdXJlVXRpbHMod2FybkFmdGVyLCBcIkltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZVwiKTtcbiAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKCgpID0+IHtcbiAgICAgICAgICBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gICAgICAgICAgcmVzdWx0ID0gdHJhY2tlci5kZXRlY3RNdXRhdGlvbnMoKTtcbiAgICAgICAgICB0cmFja2VyID0gdHJhY2soc3RhdGUpO1xuICAgICAgICAgIGlmIChyZXN1bHQud2FzTXV0YXRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTkpIDogYEEgc3RhdGUgbXV0YXRpb24gd2FzIGRldGVjdGVkIGJldHdlZW4gZGlzcGF0Y2hlcywgaW4gdGhlIHBhdGggJyR7cmVzdWx0LnBhdGggfHwgXCJcIn0nLiAgVGhpcyBtYXkgY2F1c2UgaW5jb3JyZWN0IGJlaGF2aW9yLiAoaHR0cHM6Ly9yZWR1eC5qcy5vcmcvc3R5bGUtZ3VpZGUvc3R5bGUtZ3VpZGUjZG8tbm90LW11dGF0ZS1zdGF0ZSlgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkaXNwYXRjaGVkQWN0aW9uID0gbmV4dChhY3Rpb24pO1xuICAgICAgICBtZWFzdXJlVXRpbHMubWVhc3VyZVRpbWUoKCkgPT4ge1xuICAgICAgICAgIHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgICAgICAgICByZXN1bHQgPSB0cmFja2VyLmRldGVjdE11dGF0aW9ucygpO1xuICAgICAgICAgIHRyYWNrZXIgPSB0cmFjayhzdGF0ZSk7XG4gICAgICAgICAgaWYgKHJlc3VsdC53YXNNdXRhdGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyMCkgOiBgQSBzdGF0ZSBtdXRhdGlvbiB3YXMgZGV0ZWN0ZWQgaW5zaWRlIGEgZGlzcGF0Y2gsIGluIHRoZSBwYXRoOiAke3Jlc3VsdC5wYXRoIHx8IFwiXCJ9LiBUYWtlIGEgbG9vayBhdCB0aGUgcmVkdWNlcihzKSBoYW5kbGluZyB0aGUgYWN0aW9uICR7c3RyaW5naWZ5MihhY3Rpb24pfS4gKGh0dHBzOi8vcmVkdXguanMub3JnL3N0eWxlLWd1aWRlL3N0eWxlLWd1aWRlI2RvLW5vdC1tdXRhdGUtc3RhdGUpYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbWVhc3VyZVV0aWxzLndhcm5JZkV4Y2VlZGVkKCk7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaGVkQWN0aW9uO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG59XG5cbi8vIHNyYy9zZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUudHNcbmltcG9ydCB7IGlzQWN0aW9uIGFzIGlzQWN0aW9uMiwgaXNQbGFpbk9iamVjdCB9IGZyb20gXCJyZWR1eFwiO1xuZnVuY3Rpb24gaXNQbGFpbih2YWwpIHtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIHJldHVybiB2YWwgPT0gbnVsbCB8fCB0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiIHx8IHR5cGUgPT09IFwibnVtYmVyXCIgfHwgQXJyYXkuaXNBcnJheSh2YWwpIHx8IGlzUGxhaW5PYmplY3QodmFsKTtcbn1cbmZ1bmN0aW9uIGZpbmROb25TZXJpYWxpemFibGVWYWx1ZSh2YWx1ZSwgcGF0aCA9IFwiXCIsIGlzU2VyaWFsaXphYmxlID0gaXNQbGFpbiwgZ2V0RW50cmllcywgaWdub3JlZFBhdGhzID0gW10sIGNhY2hlKSB7XG4gIGxldCBmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZTtcbiAgaWYgKCFpc1NlcmlhbGl6YWJsZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2V5UGF0aDogcGF0aCB8fCBcIjxyb290PlwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGNhY2hlPy5oYXModmFsdWUpKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGVudHJpZXMgPSBnZXRFbnRyaWVzICE9IG51bGwgPyBnZXRFbnRyaWVzKHZhbHVlKSA6IE9iamVjdC5lbnRyaWVzKHZhbHVlKTtcbiAgY29uc3QgaGFzSWdub3JlZFBhdGhzID0gaWdub3JlZFBhdGhzLmxlbmd0aCA+IDA7XG4gIGZvciAoY29uc3QgW2tleSwgbmVzdGVkVmFsdWVdIG9mIGVudHJpZXMpIHtcbiAgICBjb25zdCBuZXN0ZWRQYXRoID0gcGF0aCA/IHBhdGggKyBcIi5cIiArIGtleSA6IGtleTtcbiAgICBpZiAoaGFzSWdub3JlZFBhdGhzKSB7XG4gICAgICBjb25zdCBoYXNNYXRjaGVzID0gaWdub3JlZFBhdGhzLnNvbWUoKGlnbm9yZWQpID0+IHtcbiAgICAgICAgaWYgKGlnbm9yZWQgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICByZXR1cm4gaWdub3JlZC50ZXN0KG5lc3RlZFBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXN0ZWRQYXRoID09PSBpZ25vcmVkO1xuICAgICAgfSk7XG4gICAgICBpZiAoaGFzTWF0Y2hlcykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc1NlcmlhbGl6YWJsZShuZXN0ZWRWYWx1ZSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtleVBhdGg6IG5lc3RlZFBhdGgsXG4gICAgICAgIHZhbHVlOiBuZXN0ZWRWYWx1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXN0ZWRWYWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgZm91bmROZXN0ZWRTZXJpYWxpemFibGUgPSBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUobmVzdGVkVmFsdWUsIG5lc3RlZFBhdGgsIGlzU2VyaWFsaXphYmxlLCBnZXRFbnRyaWVzLCBpZ25vcmVkUGF0aHMsIGNhY2hlKTtcbiAgICAgIGlmIChmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZSkge1xuICAgICAgICByZXR1cm4gZm91bmROZXN0ZWRTZXJpYWxpemFibGU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChjYWNoZSAmJiBpc05lc3RlZEZyb3plbih2YWx1ZSkpIGNhY2hlLmFkZCh2YWx1ZSk7XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzTmVzdGVkRnJvemVuKHZhbHVlKSB7XG4gIGlmICghT2JqZWN0LmlzRnJvemVuKHZhbHVlKSkgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGNvbnN0IG5lc3RlZFZhbHVlIG9mIE9iamVjdC52YWx1ZXModmFsdWUpKSB7XG4gICAgaWYgKHR5cGVvZiBuZXN0ZWRWYWx1ZSAhPT0gXCJvYmplY3RcIiB8fCBuZXN0ZWRWYWx1ZSA9PT0gbnVsbCkgY29udGludWU7XG4gICAgaWYgKCFpc05lc3RlZEZyb3plbihuZXN0ZWRWYWx1ZSkpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShvcHRpb25zID0ge30pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHJldHVybiAoKSA9PiAobmV4dCkgPT4gKGFjdGlvbikgPT4gbmV4dChhY3Rpb24pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzU2VyaWFsaXphYmxlID0gaXNQbGFpbixcbiAgICAgIGdldEVudHJpZXMsXG4gICAgICBpZ25vcmVkQWN0aW9ucyA9IFtdLFxuICAgICAgaWdub3JlZEFjdGlvblBhdGhzID0gW1wibWV0YS5hcmdcIiwgXCJtZXRhLmJhc2VRdWVyeU1ldGFcIl0sXG4gICAgICBpZ25vcmVkUGF0aHMgPSBbXSxcbiAgICAgIHdhcm5BZnRlciA9IDMyLFxuICAgICAgaWdub3JlU3RhdGUgPSBmYWxzZSxcbiAgICAgIGlnbm9yZUFjdGlvbnMgPSBmYWxzZSxcbiAgICAgIGRpc2FibGVDYWNoZSA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgY2FjaGUgPSAhZGlzYWJsZUNhY2hlICYmIFdlYWtTZXQgPyAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gKHN0b3JlQVBJKSA9PiAobmV4dCkgPT4gKGFjdGlvbikgPT4ge1xuICAgICAgaWYgKCFpc0FjdGlvbjIoYWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gbmV4dChhY3Rpb24pO1xuICAgICAgY29uc3QgbWVhc3VyZVV0aWxzID0gZ2V0VGltZU1lYXN1cmVVdGlscyh3YXJuQWZ0ZXIsIFwiU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlXCIpO1xuICAgICAgaWYgKCFpZ25vcmVBY3Rpb25zICYmICEoaWdub3JlZEFjdGlvbnMubGVuZ3RoICYmIGlnbm9yZWRBY3Rpb25zLmluZGV4T2YoYWN0aW9uLnR5cGUpICE9PSAtMSkpIHtcbiAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKGFjdGlvbiwgXCJcIiwgaXNTZXJpYWxpemFibGUsIGdldEVudHJpZXMsIGlnbm9yZWRBY3Rpb25QYXRocywgY2FjaGUpO1xuICAgICAgICAgIGlmIChmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9ID0gZm91bmRBY3Rpb25Ob25TZXJpYWxpemFibGVWYWx1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEEgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZSB3YXMgZGV0ZWN0ZWQgaW4gYW4gYWN0aW9uLCBpbiB0aGUgcGF0aDogXFxgJHtrZXlQYXRofVxcYC4gVmFsdWU6YCwgdmFsdWUsIFwiXFxuVGFrZSBhIGxvb2sgYXQgdGhlIGxvZ2ljIHRoYXQgZGlzcGF0Y2hlZCB0aGlzIGFjdGlvbjogXCIsIGFjdGlvbiwgXCJcXG4oU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2ZhcS9hY3Rpb25zI3doeS1zaG91bGQtdHlwZS1iZS1hLXN0cmluZy1vci1hdC1sZWFzdC1zZXJpYWxpemFibGUtd2h5LXNob3VsZC1teS1hY3Rpb24tdHlwZXMtYmUtY29uc3RhbnRzKVwiLCBcIlxcbihUbyBhbGxvdyBub24tc2VyaWFsaXphYmxlIHZhbHVlcyBzZWU6IGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvdXNhZ2UvdXNhZ2UtZ3VpZGUjd29ya2luZy13aXRoLW5vbi1zZXJpYWxpemFibGUtZGF0YSlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghaWdub3JlU3RhdGUpIHtcbiAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IHN0b3JlQVBJLmdldFN0YXRlKCk7XG4gICAgICAgICAgY29uc3QgZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKHN0YXRlLCBcIlwiLCBpc1NlcmlhbGl6YWJsZSwgZ2V0RW50cmllcywgaWdub3JlZFBhdGhzLCBjYWNoZSk7XG4gICAgICAgICAgaWYgKGZvdW5kU3RhdGVOb25TZXJpYWxpemFibGVWYWx1ZSkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfSA9IGZvdW5kU3RhdGVOb25TZXJpYWxpemFibGVWYWx1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEEgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZSB3YXMgZGV0ZWN0ZWQgaW4gdGhlIHN0YXRlLCBpbiB0aGUgcGF0aDogXFxgJHtrZXlQYXRofVxcYC4gVmFsdWU6YCwgdmFsdWUsIGBcblRha2UgYSBsb29rIGF0IHRoZSByZWR1Y2VyKHMpIGhhbmRsaW5nIHRoaXMgYWN0aW9uIHR5cGU6ICR7YWN0aW9uLnR5cGV9LlxuKFNlZSBodHRwczovL3JlZHV4LmpzLm9yZy9mYXEvb3JnYW5pemluZy1zdGF0ZSNjYW4taS1wdXQtZnVuY3Rpb25zLXByb21pc2VzLW9yLW90aGVyLW5vbi1zZXJpYWxpemFibGUtaXRlbXMtaW4tbXktc3RvcmUtc3RhdGUpYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbWVhc3VyZVV0aWxzLndhcm5JZkV4Y2VlZGVkKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH1cbn1cblxuLy8gc3JjL2dldERlZmF1bHRNaWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBpc0Jvb2xlYW4oeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09IFwiYm9vbGVhblwiO1xufVxudmFyIGJ1aWxkR2V0RGVmYXVsdE1pZGRsZXdhcmUgPSAoKSA9PiBmdW5jdGlvbiBnZXREZWZhdWx0TWlkZGxld2FyZShvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICB0aHVuayA9IHRydWUsXG4gICAgaW1tdXRhYmxlQ2hlY2sgPSB0cnVlLFxuICAgIHNlcmlhbGl6YWJsZUNoZWNrID0gdHJ1ZSxcbiAgICBhY3Rpb25DcmVhdG9yQ2hlY2sgPSB0cnVlXG4gIH0gPSBvcHRpb25zID8/IHt9O1xuICBsZXQgbWlkZGxld2FyZUFycmF5ID0gbmV3IFR1cGxlKCk7XG4gIGlmICh0aHVuaykge1xuICAgIGlmIChpc0Jvb2xlYW4odGh1bmspKSB7XG4gICAgICBtaWRkbGV3YXJlQXJyYXkucHVzaCh0aHVua01pZGRsZXdhcmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtaWRkbGV3YXJlQXJyYXkucHVzaCh3aXRoRXh0cmFBcmd1bWVudCh0aHVuay5leHRyYUFyZ3VtZW50KSk7XG4gICAgfVxuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoaW1tdXRhYmxlQ2hlY2spIHtcbiAgICAgIGxldCBpbW11dGFibGVPcHRpb25zID0ge307XG4gICAgICBpZiAoIWlzQm9vbGVhbihpbW11dGFibGVDaGVjaykpIHtcbiAgICAgICAgaW1tdXRhYmxlT3B0aW9ucyA9IGltbXV0YWJsZUNoZWNrO1xuICAgICAgfVxuICAgICAgbWlkZGxld2FyZUFycmF5LnVuc2hpZnQoY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKGltbXV0YWJsZU9wdGlvbnMpKTtcbiAgICB9XG4gICAgaWYgKHNlcmlhbGl6YWJsZUNoZWNrKSB7XG4gICAgICBsZXQgc2VyaWFsaXphYmxlT3B0aW9ucyA9IHt9O1xuICAgICAgaWYgKCFpc0Jvb2xlYW4oc2VyaWFsaXphYmxlQ2hlY2spKSB7XG4gICAgICAgIHNlcmlhbGl6YWJsZU9wdGlvbnMgPSBzZXJpYWxpemFibGVDaGVjaztcbiAgICAgIH1cbiAgICAgIG1pZGRsZXdhcmVBcnJheS5wdXNoKGNyZWF0ZVNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShzZXJpYWxpemFibGVPcHRpb25zKSk7XG4gICAgfVxuICAgIGlmIChhY3Rpb25DcmVhdG9yQ2hlY2spIHtcbiAgICAgIGxldCBhY3Rpb25DcmVhdG9yT3B0aW9ucyA9IHt9O1xuICAgICAgaWYgKCFpc0Jvb2xlYW4oYWN0aW9uQ3JlYXRvckNoZWNrKSkge1xuICAgICAgICBhY3Rpb25DcmVhdG9yT3B0aW9ucyA9IGFjdGlvbkNyZWF0b3JDaGVjaztcbiAgICAgIH1cbiAgICAgIG1pZGRsZXdhcmVBcnJheS51bnNoaWZ0KGNyZWF0ZUFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlKGFjdGlvbkNyZWF0b3JPcHRpb25zKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtaWRkbGV3YXJlQXJyYXk7XG59O1xuXG4vLyBzcmMvYXV0b0JhdGNoRW5oYW5jZXIudHNcbnZhciBTSE9VTERfQVVUT0JBVENIID0gXCJSVEtfYXV0b0JhdGNoXCI7XG52YXIgcHJlcGFyZUF1dG9CYXRjaGVkID0gKCkgPT4gKHBheWxvYWQpID0+ICh7XG4gIHBheWxvYWQsXG4gIG1ldGE6IHtcbiAgICBbU0hPVUxEX0FVVE9CQVRDSF06IHRydWVcbiAgfVxufSk7XG52YXIgY3JlYXRlUXVldWVXaXRoVGltZXIgPSAodGltZW91dCkgPT4ge1xuICByZXR1cm4gKG5vdGlmeSkgPT4ge1xuICAgIHNldFRpbWVvdXQobm90aWZ5LCB0aW1lb3V0KTtcbiAgfTtcbn07XG52YXIgYXV0b0JhdGNoRW5oYW5jZXIgPSAob3B0aW9ucyA9IHtcbiAgdHlwZTogXCJyYWZcIlxufSkgPT4gKG5leHQpID0+ICguLi5hcmdzKSA9PiB7XG4gIGNvbnN0IHN0b3JlID0gbmV4dCguLi5hcmdzKTtcbiAgbGV0IG5vdGlmeWluZyA9IHRydWU7XG4gIGxldCBzaG91bGROb3RpZnlBdEVuZE9mVGljayA9IGZhbHNlO1xuICBsZXQgbm90aWZpY2F0aW9uUXVldWVkID0gZmFsc2U7XG4gIGNvbnN0IGxpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IHF1ZXVlQ2FsbGJhY2sgPSBvcHRpb25zLnR5cGUgPT09IFwidGlja1wiID8gcXVldWVNaWNyb3Rhc2sgOiBvcHRpb25zLnR5cGUgPT09IFwicmFmXCIgPyAoXG4gICAgLy8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHdvbid0IGV4aXN0IGluIFNTUiBlbnZpcm9ubWVudHMuIEZhbGwgYmFjayB0byBhIHZhZ3VlIGFwcHJveGltYXRpb24ganVzdCB0byBrZWVwIGZyb20gZXJyb3JpbmcuXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA6IGNyZWF0ZVF1ZXVlV2l0aFRpbWVyKDEwKVxuICApIDogb3B0aW9ucy50eXBlID09PSBcImNhbGxiYWNrXCIgPyBvcHRpb25zLnF1ZXVlTm90aWZpY2F0aW9uIDogY3JlYXRlUXVldWVXaXRoVGltZXIob3B0aW9ucy50aW1lb3V0KTtcbiAgY29uc3Qgbm90aWZ5TGlzdGVuZXJzID0gKCkgPT4ge1xuICAgIG5vdGlmaWNhdGlvblF1ZXVlZCA9IGZhbHNlO1xuICAgIGlmIChzaG91bGROb3RpZnlBdEVuZE9mVGljaykge1xuICAgICAgc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2sgPSBmYWxzZTtcbiAgICAgIGxpc3RlbmVycy5mb3JFYWNoKChsKSA9PiBsKCkpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0b3JlLCB7XG4gICAgLy8gT3ZlcnJpZGUgdGhlIGJhc2UgYHN0b3JlLnN1YnNjcmliZWAgbWV0aG9kIHRvIGtlZXAgb3JpZ2luYWwgbGlzdGVuZXJzXG4gICAgLy8gZnJvbSBydW5uaW5nIGlmIHdlJ3JlIGRlbGF5aW5nIG5vdGlmaWNhdGlvbnNcbiAgICBzdWJzY3JpYmUobGlzdGVuZXIyKSB7XG4gICAgICBjb25zdCB3cmFwcGVkTGlzdGVuZXIgPSAoKSA9PiBub3RpZnlpbmcgJiYgbGlzdGVuZXIyKCk7XG4gICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHN0b3JlLnN1YnNjcmliZSh3cmFwcGVkTGlzdGVuZXIpO1xuICAgICAgbGlzdGVuZXJzLmFkZChsaXN0ZW5lcjIpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcjIpO1xuICAgICAgfTtcbiAgICB9LFxuICAgIC8vIE92ZXJyaWRlIHRoZSBiYXNlIGBzdG9yZS5kaXNwYXRjaGAgbWV0aG9kIHNvIHRoYXQgd2UgY2FuIGNoZWNrIGFjdGlvbnNcbiAgICAvLyBmb3IgdGhlIGBzaG91bGRBdXRvQmF0Y2hgIGZsYWcgYW5kIGRldGVybWluZSBpZiBiYXRjaGluZyBpcyBhY3RpdmVcbiAgICBkaXNwYXRjaChhY3Rpb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5vdGlmeWluZyA9ICFhY3Rpb24/Lm1ldGE/LltTSE9VTERfQVVUT0JBVENIXTtcbiAgICAgICAgc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2sgPSAhbm90aWZ5aW5nO1xuICAgICAgICBpZiAoc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2spIHtcbiAgICAgICAgICBpZiAoIW5vdGlmaWNhdGlvblF1ZXVlZCkge1xuICAgICAgICAgICAgbm90aWZpY2F0aW9uUXVldWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHF1ZXVlQ2FsbGJhY2sobm90aWZ5TGlzdGVuZXJzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0b3JlLmRpc3BhdGNoKGFjdGlvbik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBub3RpZnlpbmcgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG4vLyBzcmMvZ2V0RGVmYXVsdEVuaGFuY2Vycy50c1xudmFyIGJ1aWxkR2V0RGVmYXVsdEVuaGFuY2VycyA9IChtaWRkbGV3YXJlRW5oYW5jZXIpID0+IGZ1bmN0aW9uIGdldERlZmF1bHRFbmhhbmNlcnMob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgYXV0b0JhdGNoID0gdHJ1ZVxuICB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgbGV0IGVuaGFuY2VyQXJyYXkgPSBuZXcgVHVwbGUobWlkZGxld2FyZUVuaGFuY2VyKTtcbiAgaWYgKGF1dG9CYXRjaCkge1xuICAgIGVuaGFuY2VyQXJyYXkucHVzaChhdXRvQmF0Y2hFbmhhbmNlcih0eXBlb2YgYXV0b0JhdGNoID09PSBcIm9iamVjdFwiID8gYXV0b0JhdGNoIDogdm9pZCAwKSk7XG4gIH1cbiAgcmV0dXJuIGVuaGFuY2VyQXJyYXk7XG59O1xuXG4vLyBzcmMvY29uZmlndXJlU3RvcmUudHNcbmZ1bmN0aW9uIGNvbmZpZ3VyZVN0b3JlKG9wdGlvbnMpIHtcbiAgY29uc3QgZ2V0RGVmYXVsdE1pZGRsZXdhcmUgPSBidWlsZEdldERlZmF1bHRNaWRkbGV3YXJlKCk7XG4gIGNvbnN0IHtcbiAgICByZWR1Y2VyID0gdm9pZCAwLFxuICAgIG1pZGRsZXdhcmUsXG4gICAgZGV2VG9vbHMgPSB0cnVlLFxuICAgIGR1cGxpY2F0ZU1pZGRsZXdhcmVDaGVjayA9IHRydWUsXG4gICAgcHJlbG9hZGVkU3RhdGUgPSB2b2lkIDAsXG4gICAgZW5oYW5jZXJzID0gdm9pZCAwXG4gIH0gPSBvcHRpb25zIHx8IHt9O1xuICBsZXQgcm9vdFJlZHVjZXI7XG4gIGlmICh0eXBlb2YgcmVkdWNlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcm9vdFJlZHVjZXIgPSByZWR1Y2VyO1xuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QyKHJlZHVjZXIpKSB7XG4gICAgcm9vdFJlZHVjZXIgPSBjb21iaW5lUmVkdWNlcnMocmVkdWNlcik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMSkgOiBcImByZWR1Y2VyYCBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50LCBhbmQgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCBvZiBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIGNvbWJpbmVSZWR1Y2Vyc1wiKTtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG1pZGRsZXdhcmUgJiYgdHlwZW9mIG1pZGRsZXdhcmUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDIpIDogXCJgbWlkZGxld2FyZWAgZmllbGQgbXVzdCBiZSBhIGNhbGxiYWNrXCIpO1xuICB9XG4gIGxldCBmaW5hbE1pZGRsZXdhcmU7XG4gIGlmICh0eXBlb2YgbWlkZGxld2FyZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZmluYWxNaWRkbGV3YXJlID0gbWlkZGxld2FyZShnZXREZWZhdWx0TWlkZGxld2FyZSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhQXJyYXkuaXNBcnJheShmaW5hbE1pZGRsZXdhcmUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzKSA6IFwid2hlbiB1c2luZyBhIG1pZGRsZXdhcmUgYnVpbGRlciBmdW5jdGlvbiwgYW4gYXJyYXkgb2YgbWlkZGxld2FyZSBtdXN0IGJlIHJldHVybmVkXCIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmaW5hbE1pZGRsZXdhcmUgPSBnZXREZWZhdWx0TWlkZGxld2FyZSgpO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZmluYWxNaWRkbGV3YXJlLnNvbWUoKGl0ZW0pID0+IHR5cGVvZiBpdGVtICE9PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNCkgOiBcImVhY2ggbWlkZGxld2FyZSBwcm92aWRlZCB0byBjb25maWd1cmVTdG9yZSBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBkdXBsaWNhdGVNaWRkbGV3YXJlQ2hlY2spIHtcbiAgICBsZXQgbWlkZGxld2FyZVJlZmVyZW5jZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGZpbmFsTWlkZGxld2FyZS5mb3JFYWNoKChtaWRkbGV3YXJlMikgPT4ge1xuICAgICAgaWYgKG1pZGRsZXdhcmVSZWZlcmVuY2VzLmhhcyhtaWRkbGV3YXJlMikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNDIpIDogXCJEdXBsaWNhdGUgbWlkZGxld2FyZSByZWZlcmVuY2VzIGZvdW5kIHdoZW4gY3JlYXRpbmcgdGhlIHN0b3JlLiBFbnN1cmUgdGhhdCBlYWNoIG1pZGRsZXdhcmUgaXMgb25seSBpbmNsdWRlZCBvbmNlLlwiKTtcbiAgICAgIH1cbiAgICAgIG1pZGRsZXdhcmVSZWZlcmVuY2VzLmFkZChtaWRkbGV3YXJlMik7XG4gICAgfSk7XG4gIH1cbiAgbGV0IGZpbmFsQ29tcG9zZSA9IGNvbXBvc2UyO1xuICBpZiAoZGV2VG9vbHMpIHtcbiAgICBmaW5hbENvbXBvc2UgPSBjb21wb3NlV2l0aERldlRvb2xzKHtcbiAgICAgIC8vIEVuYWJsZSBjYXB0dXJlIG9mIHN0YWNrIHRyYWNlcyBmb3IgZGlzcGF0Y2hlZCBSZWR1eCBhY3Rpb25zXG4gICAgICB0cmFjZTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiLFxuICAgICAgLi4udHlwZW9mIGRldlRvb2xzID09PSBcIm9iamVjdFwiICYmIGRldlRvb2xzXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgbWlkZGxld2FyZUVuaGFuY2VyID0gYXBwbHlNaWRkbGV3YXJlKC4uLmZpbmFsTWlkZGxld2FyZSk7XG4gIGNvbnN0IGdldERlZmF1bHRFbmhhbmNlcnMgPSBidWlsZEdldERlZmF1bHRFbmhhbmNlcnMobWlkZGxld2FyZUVuaGFuY2VyKTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBlbmhhbmNlcnMgJiYgdHlwZW9mIGVuaGFuY2VycyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNSkgOiBcImBlbmhhbmNlcnNgIGZpZWxkIG11c3QgYmUgYSBjYWxsYmFja1wiKTtcbiAgfVxuICBsZXQgc3RvcmVFbmhhbmNlcnMgPSB0eXBlb2YgZW5oYW5jZXJzID09PSBcImZ1bmN0aW9uXCIgPyBlbmhhbmNlcnMoZ2V0RGVmYXVsdEVuaGFuY2VycykgOiBnZXREZWZhdWx0RW5oYW5jZXJzKCk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIUFycmF5LmlzQXJyYXkoc3RvcmVFbmhhbmNlcnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNikgOiBcImBlbmhhbmNlcnNgIGNhbGxiYWNrIG11c3QgcmV0dXJuIGFuIGFycmF5XCIpO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgc3RvcmVFbmhhbmNlcnMuc29tZSgoaXRlbSkgPT4gdHlwZW9mIGl0ZW0gIT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg3KSA6IFwiZWFjaCBlbmhhbmNlciBwcm92aWRlZCB0byBjb25maWd1cmVTdG9yZSBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBmaW5hbE1pZGRsZXdhcmUubGVuZ3RoICYmICFzdG9yZUVuaGFuY2Vycy5pbmNsdWRlcyhtaWRkbGV3YXJlRW5oYW5jZXIpKSB7XG4gICAgY29uc29sZS5lcnJvcihcIm1pZGRsZXdhcmVzIHdlcmUgcHJvdmlkZWQsIGJ1dCBtaWRkbGV3YXJlIGVuaGFuY2VyIHdhcyBub3QgaW5jbHVkZWQgaW4gZmluYWwgZW5oYW5jZXJzIC0gbWFrZSBzdXJlIHRvIGNhbGwgYGdldERlZmF1bHRFbmhhbmNlcnNgXCIpO1xuICB9XG4gIGNvbnN0IGNvbXBvc2VkRW5oYW5jZXIgPSBmaW5hbENvbXBvc2UoLi4uc3RvcmVFbmhhbmNlcnMpO1xuICByZXR1cm4gY3JlYXRlU3RvcmUocm9vdFJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBjb21wb3NlZEVuaGFuY2VyKTtcbn1cblxuLy8gc3JjL2NyZWF0ZVJlZHVjZXIudHNcbmltcG9ydCB7IHByb2R1Y2UgYXMgY3JlYXRlTmV4dFN0YXRlMiwgaXNEcmFmdCBhcyBpc0RyYWZ0MiwgaXNEcmFmdGFibGUgYXMgaXNEcmFmdGFibGUyIH0gZnJvbSBcImltbWVyXCI7XG5cbi8vIHNyYy9tYXBCdWlsZGVycy50c1xuZnVuY3Rpb24gZXhlY3V0ZVJlZHVjZXJCdWlsZGVyQ2FsbGJhY2soYnVpbGRlckNhbGxiYWNrKSB7XG4gIGNvbnN0IGFjdGlvbnNNYXAgPSB7fTtcbiAgY29uc3QgYWN0aW9uTWF0Y2hlcnMgPSBbXTtcbiAgbGV0IGRlZmF1bHRDYXNlUmVkdWNlcjtcbiAgY29uc3QgYnVpbGRlciA9IHtcbiAgICBhZGRDYXNlKHR5cGVPckFjdGlvbkNyZWF0b3IsIHJlZHVjZXIpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgaWYgKGFjdGlvbk1hdGNoZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyNikgOiBcImBidWlsZGVyLmFkZENhc2VgIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgY2FsbGluZyBgYnVpbGRlci5hZGRNYXRjaGVyYFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmYXVsdENhc2VSZWR1Y2VyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjcpIDogXCJgYnVpbGRlci5hZGRDYXNlYCBzaG91bGQgb25seSBiZSBjYWxsZWQgYmVmb3JlIGNhbGxpbmcgYGJ1aWxkZXIuYWRkRGVmYXVsdENhc2VgXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB0eXBlID0gdHlwZW9mIHR5cGVPckFjdGlvbkNyZWF0b3IgPT09IFwic3RyaW5nXCIgPyB0eXBlT3JBY3Rpb25DcmVhdG9yIDogdHlwZU9yQWN0aW9uQ3JlYXRvci50eXBlO1xuICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDI4KSA6IFwiYGJ1aWxkZXIuYWRkQ2FzZWAgY2Fubm90IGJlIGNhbGxlZCB3aXRoIGFuIGVtcHR5IGFjdGlvbiB0eXBlXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgaW4gYWN0aW9uc01hcCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyOSkgOiBgXFxgYnVpbGRlci5hZGRDYXNlXFxgIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCB0d28gcmVkdWNlcnMgZm9yIHRoZSBzYW1lIGFjdGlvbiB0eXBlICcke3R5cGV9J2ApO1xuICAgICAgfVxuICAgICAgYWN0aW9uc01hcFt0eXBlXSA9IHJlZHVjZXI7XG4gICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICB9LFxuICAgIGFkZEFzeW5jVGh1bmsoYXN5bmNUaHVuaywgcmVkdWNlcnMpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQzKSA6IFwiYGJ1aWxkZXIuYWRkQXN5bmNUaHVua2Agc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJlZm9yZSBjYWxsaW5nIGBidWlsZGVyLmFkZERlZmF1bHRDYXNlYFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJlZHVjZXJzLnBlbmRpbmcpIGFjdGlvbnNNYXBbYXN5bmNUaHVuay5wZW5kaW5nLnR5cGVdID0gcmVkdWNlcnMucGVuZGluZztcbiAgICAgIGlmIChyZWR1Y2Vycy5yZWplY3RlZCkgYWN0aW9uc01hcFthc3luY1RodW5rLnJlamVjdGVkLnR5cGVdID0gcmVkdWNlcnMucmVqZWN0ZWQ7XG4gICAgICBpZiAocmVkdWNlcnMuZnVsZmlsbGVkKSBhY3Rpb25zTWFwW2FzeW5jVGh1bmsuZnVsZmlsbGVkLnR5cGVdID0gcmVkdWNlcnMuZnVsZmlsbGVkO1xuICAgICAgaWYgKHJlZHVjZXJzLnNldHRsZWQpIGFjdGlvbk1hdGNoZXJzLnB1c2goe1xuICAgICAgICBtYXRjaGVyOiBhc3luY1RodW5rLnNldHRsZWQsXG4gICAgICAgIHJlZHVjZXI6IHJlZHVjZXJzLnNldHRsZWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGJ1aWxkZXI7XG4gICAgfSxcbiAgICBhZGRNYXRjaGVyKG1hdGNoZXIsIHJlZHVjZXIpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMwKSA6IFwiYGJ1aWxkZXIuYWRkTWF0Y2hlcmAgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJlZm9yZSBjYWxsaW5nIGBidWlsZGVyLmFkZERlZmF1bHRDYXNlYFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYWN0aW9uTWF0Y2hlcnMucHVzaCh7XG4gICAgICAgIG1hdGNoZXIsXG4gICAgICAgIHJlZHVjZXJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGJ1aWxkZXI7XG4gICAgfSxcbiAgICBhZGREZWZhdWx0Q2FzZShyZWR1Y2VyKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGlmIChkZWZhdWx0Q2FzZVJlZHVjZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzMSkgOiBcImBidWlsZGVyLmFkZERlZmF1bHRDYXNlYCBjYW4gb25seSBiZSBjYWxsZWQgb25jZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVmYXVsdENhc2VSZWR1Y2VyID0gcmVkdWNlcjtcbiAgICAgIHJldHVybiBidWlsZGVyO1xuICAgIH1cbiAgfTtcbiAgYnVpbGRlckNhbGxiYWNrKGJ1aWxkZXIpO1xuICByZXR1cm4gW2FjdGlvbnNNYXAsIGFjdGlvbk1hdGNoZXJzLCBkZWZhdWx0Q2FzZVJlZHVjZXJdO1xufVxuXG4vLyBzcmMvY3JlYXRlUmVkdWNlci50c1xuZnVuY3Rpb24gaXNTdGF0ZUZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWR1Y2VyKGluaXRpYWxTdGF0ZSwgbWFwT3JCdWlsZGVyQ2FsbGJhY2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICh0eXBlb2YgbWFwT3JCdWlsZGVyQ2FsbGJhY2sgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDgpIDogXCJUaGUgb2JqZWN0IG5vdGF0aW9uIGZvciBgY3JlYXRlUmVkdWNlcmAgaGFzIGJlZW4gcmVtb3ZlZC4gUGxlYXNlIHVzZSB0aGUgJ2J1aWxkZXIgY2FsbGJhY2snIG5vdGF0aW9uIGluc3RlYWQ6IGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvYXBpL2NyZWF0ZVJlZHVjZXJcIik7XG4gICAgfVxuICB9XG4gIGxldCBbYWN0aW9uc01hcCwgZmluYWxBY3Rpb25NYXRjaGVycywgZmluYWxEZWZhdWx0Q2FzZVJlZHVjZXJdID0gZXhlY3V0ZVJlZHVjZXJCdWlsZGVyQ2FsbGJhY2sobWFwT3JCdWlsZGVyQ2FsbGJhY2spO1xuICBsZXQgZ2V0SW5pdGlhbFN0YXRlO1xuICBpZiAoaXNTdGF0ZUZ1bmN0aW9uKGluaXRpYWxTdGF0ZSkpIHtcbiAgICBnZXRJbml0aWFsU3RhdGUgPSAoKSA9PiBmcmVlemVEcmFmdGFibGUoaW5pdGlhbFN0YXRlKCkpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGZyb3plbkluaXRpYWxTdGF0ZSA9IGZyZWV6ZURyYWZ0YWJsZShpbml0aWFsU3RhdGUpO1xuICAgIGdldEluaXRpYWxTdGF0ZSA9ICgpID0+IGZyb3plbkluaXRpYWxTdGF0ZTtcbiAgfVxuICBmdW5jdGlvbiByZWR1Y2VyKHN0YXRlID0gZ2V0SW5pdGlhbFN0YXRlKCksIGFjdGlvbikge1xuICAgIGxldCBjYXNlUmVkdWNlcnMgPSBbYWN0aW9uc01hcFthY3Rpb24udHlwZV0sIC4uLmZpbmFsQWN0aW9uTWF0Y2hlcnMuZmlsdGVyKCh7XG4gICAgICBtYXRjaGVyXG4gICAgfSkgPT4gbWF0Y2hlcihhY3Rpb24pKS5tYXAoKHtcbiAgICAgIHJlZHVjZXI6IHJlZHVjZXIyXG4gICAgfSkgPT4gcmVkdWNlcjIpXTtcbiAgICBpZiAoY2FzZVJlZHVjZXJzLmZpbHRlcigoY3IpID0+ICEhY3IpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY2FzZVJlZHVjZXJzID0gW2ZpbmFsRGVmYXVsdENhc2VSZWR1Y2VyXTtcbiAgICB9XG4gICAgcmV0dXJuIGNhc2VSZWR1Y2Vycy5yZWR1Y2UoKHByZXZpb3VzU3RhdGUsIGNhc2VSZWR1Y2VyKSA9PiB7XG4gICAgICBpZiAoY2FzZVJlZHVjZXIpIHtcbiAgICAgICAgaWYgKGlzRHJhZnQyKHByZXZpb3VzU3RhdGUpKSB7XG4gICAgICAgICAgY29uc3QgZHJhZnQgPSBwcmV2aW91c1N0YXRlO1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNhc2VSZWR1Y2VyKGRyYWZ0LCBhY3Rpb24pO1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzU3RhdGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzRHJhZnRhYmxlMihwcmV2aW91c1N0YXRlKSkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNhc2VSZWR1Y2VyKHByZXZpb3VzU3RhdGUsIGFjdGlvbik7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpZiAocHJldmlvdXNTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gcHJldmlvdXNTdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiQSBjYXNlIHJlZHVjZXIgb24gYSBub24tZHJhZnRhYmxlIHZhbHVlIG11c3Qgbm90IHJldHVybiB1bmRlZmluZWRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZU5leHRTdGF0ZTIocHJldmlvdXNTdGF0ZSwgKGRyYWZ0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY2FzZVJlZHVjZXIoZHJhZnQsIGFjdGlvbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwcmV2aW91c1N0YXRlO1xuICAgIH0sIHN0YXRlKTtcbiAgfVxuICByZWR1Y2VyLmdldEluaXRpYWxTdGF0ZSA9IGdldEluaXRpYWxTdGF0ZTtcbiAgcmV0dXJuIHJlZHVjZXI7XG59XG5cbi8vIHNyYy9tYXRjaGVycy50c1xudmFyIG1hdGNoZXMgPSAobWF0Y2hlciwgYWN0aW9uKSA9PiB7XG4gIGlmIChoYXNNYXRjaEZ1bmN0aW9uKG1hdGNoZXIpKSB7XG4gICAgcmV0dXJuIG1hdGNoZXIubWF0Y2goYWN0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbWF0Y2hlcihhY3Rpb24pO1xuICB9XG59O1xuZnVuY3Rpb24gaXNBbnlPZiguLi5tYXRjaGVycykge1xuICByZXR1cm4gKGFjdGlvbikgPT4ge1xuICAgIHJldHVybiBtYXRjaGVycy5zb21lKChtYXRjaGVyKSA9PiBtYXRjaGVzKG1hdGNoZXIsIGFjdGlvbikpO1xuICB9O1xufVxuZnVuY3Rpb24gaXNBbGxPZiguLi5tYXRjaGVycykge1xuICByZXR1cm4gKGFjdGlvbikgPT4ge1xuICAgIHJldHVybiBtYXRjaGVycy5ldmVyeSgobWF0Y2hlcikgPT4gbWF0Y2hlcyhtYXRjaGVyLCBhY3Rpb24pKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgdmFsaWRTdGF0dXMpIHtcbiAgaWYgKCFhY3Rpb24gfHwgIWFjdGlvbi5tZXRhKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGhhc1ZhbGlkUmVxdWVzdElkID0gdHlwZW9mIGFjdGlvbi5tZXRhLnJlcXVlc3RJZCA9PT0gXCJzdHJpbmdcIjtcbiAgY29uc3QgaGFzVmFsaWRSZXF1ZXN0U3RhdHVzID0gdmFsaWRTdGF0dXMuaW5kZXhPZihhY3Rpb24ubWV0YS5yZXF1ZXN0U3RhdHVzKSA+IC0xO1xuICByZXR1cm4gaGFzVmFsaWRSZXF1ZXN0SWQgJiYgaGFzVmFsaWRSZXF1ZXN0U3RhdHVzO1xufVxuZnVuY3Rpb24gaXNBc3luY1RodW5rQXJyYXkoYSkge1xuICByZXR1cm4gdHlwZW9mIGFbMF0gPT09IFwiZnVuY3Rpb25cIiAmJiBcInBlbmRpbmdcIiBpbiBhWzBdICYmIFwiZnVsZmlsbGVkXCIgaW4gYVswXSAmJiBcInJlamVjdGVkXCIgaW4gYVswXTtcbn1cbmZ1bmN0aW9uIGlzUGVuZGluZyguLi5hc3luY1RodW5rcykge1xuICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIChhY3Rpb24pID0+IGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgW1wicGVuZGluZ1wiXSk7XG4gIH1cbiAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcbiAgICByZXR1cm4gaXNQZW5kaW5nKCkoYXN5bmNUaHVua3NbMF0pO1xuICB9XG4gIHJldHVybiBpc0FueU9mKC4uLmFzeW5jVGh1bmtzLm1hcCgoYXN5bmNUaHVuaykgPT4gYXN5bmNUaHVuay5wZW5kaW5nKSk7XG59XG5mdW5jdGlvbiBpc1JlamVjdGVkKC4uLmFzeW5jVGh1bmtzKSB7XG4gIGlmIChhc3luY1RodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gKGFjdGlvbikgPT4gaGFzRXhwZWN0ZWRSZXF1ZXN0TWV0YWRhdGEoYWN0aW9uLCBbXCJyZWplY3RlZFwiXSk7XG4gIH1cbiAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcbiAgICByZXR1cm4gaXNSZWplY3RlZCgpKGFzeW5jVGh1bmtzWzBdKTtcbiAgfVxuICByZXR1cm4gaXNBbnlPZiguLi5hc3luY1RodW5rcy5tYXAoKGFzeW5jVGh1bmspID0+IGFzeW5jVGh1bmsucmVqZWN0ZWQpKTtcbn1cbmZ1bmN0aW9uIGlzUmVqZWN0ZWRXaXRoVmFsdWUoLi4uYXN5bmNUaHVua3MpIHtcbiAgY29uc3QgaGFzRmxhZyA9IChhY3Rpb24pID0+IHtcbiAgICByZXR1cm4gYWN0aW9uICYmIGFjdGlvbi5tZXRhICYmIGFjdGlvbi5tZXRhLnJlamVjdGVkV2l0aFZhbHVlO1xuICB9O1xuICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGlzQWxsT2YoaXNSZWplY3RlZCguLi5hc3luY1RodW5rcyksIGhhc0ZsYWcpO1xuICB9XG4gIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XG4gICAgcmV0dXJuIGlzUmVqZWN0ZWRXaXRoVmFsdWUoKShhc3luY1RodW5rc1swXSk7XG4gIH1cbiAgcmV0dXJuIGlzQWxsT2YoaXNSZWplY3RlZCguLi5hc3luY1RodW5rcyksIGhhc0ZsYWcpO1xufVxuZnVuY3Rpb24gaXNGdWxmaWxsZWQoLi4uYXN5bmNUaHVua3MpIHtcbiAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAoYWN0aW9uKSA9PiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIFtcImZ1bGZpbGxlZFwiXSk7XG4gIH1cbiAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcbiAgICByZXR1cm4gaXNGdWxmaWxsZWQoKShhc3luY1RodW5rc1swXSk7XG4gIH1cbiAgcmV0dXJuIGlzQW55T2YoLi4uYXN5bmNUaHVua3MubWFwKChhc3luY1RodW5rKSA9PiBhc3luY1RodW5rLmZ1bGZpbGxlZCkpO1xufVxuZnVuY3Rpb24gaXNBc3luY1RodW5rQWN0aW9uKC4uLmFzeW5jVGh1bmtzKSB7XG4gIGlmIChhc3luY1RodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gKGFjdGlvbikgPT4gaGFzRXhwZWN0ZWRSZXF1ZXN0TWV0YWRhdGEoYWN0aW9uLCBbXCJwZW5kaW5nXCIsIFwiZnVsZmlsbGVkXCIsIFwicmVqZWN0ZWRcIl0pO1xuICB9XG4gIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XG4gICAgcmV0dXJuIGlzQXN5bmNUaHVua0FjdGlvbigpKGFzeW5jVGh1bmtzWzBdKTtcbiAgfVxuICByZXR1cm4gaXNBbnlPZiguLi5hc3luY1RodW5rcy5mbGF0TWFwKChhc3luY1RodW5rKSA9PiBbYXN5bmNUaHVuay5wZW5kaW5nLCBhc3luY1RodW5rLnJlamVjdGVkLCBhc3luY1RodW5rLmZ1bGZpbGxlZF0pKTtcbn1cblxuLy8gc3JjL25hbm9pZC50c1xudmFyIHVybEFscGhhYmV0ID0gXCJNb2R1bGVTeW1iaGFzT3duUHItMDEyMzQ1Njc4OUFCQ0RFRkdITlJWZmdjdGlVdnpfS3FZVEprTHhwWlhJalFXXCI7XG52YXIgbmFub2lkID0gKHNpemUgPSAyMSkgPT4ge1xuICBsZXQgaWQgPSBcIlwiO1xuICBsZXQgaSA9IHNpemU7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZCArPSB1cmxBbHBoYWJldFtNYXRoLnJhbmRvbSgpICogNjQgfCAwXTtcbiAgfVxuICByZXR1cm4gaWQ7XG59O1xuXG4vLyBzcmMvY3JlYXRlQXN5bmNUaHVuay50c1xudmFyIGNvbW1vblByb3BlcnRpZXMgPSBbXCJuYW1lXCIsIFwibWVzc2FnZVwiLCBcInN0YWNrXCIsIFwiY29kZVwiXTtcbnZhciBSZWplY3RXaXRoVmFsdWUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHBheWxvYWQsIG1ldGEpIHtcbiAgICB0aGlzLnBheWxvYWQgPSBwYXlsb2FkO1xuICAgIHRoaXMubWV0YSA9IG1ldGE7XG4gIH1cbiAgLypcbiAgdHlwZS1vbmx5IHByb3BlcnR5IHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gUmVqZWN0V2l0aFZhbHVlIGFuZCBGdWxmaWxsV2l0aE1ldGFcbiAgZG9lcyBub3QgZXhpc3QgYXQgcnVudGltZVxuICAqL1xuICBfdHlwZTtcbn07XG52YXIgRnVsZmlsbFdpdGhNZXRhID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihwYXlsb2FkLCBtZXRhKSB7XG4gICAgdGhpcy5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICB0aGlzLm1ldGEgPSBtZXRhO1xuICB9XG4gIC8qXG4gIHR5cGUtb25seSBwcm9wZXJ0eSB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIFJlamVjdFdpdGhWYWx1ZSBhbmQgRnVsZmlsbFdpdGhNZXRhXG4gIGRvZXMgbm90IGV4aXN0IGF0IHJ1bnRpbWVcbiAgKi9cbiAgX3R5cGU7XG59O1xudmFyIG1pbmlTZXJpYWxpemVFcnJvciA9ICh2YWx1ZSkgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgY29uc3Qgc2ltcGxlRXJyb3IgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIGNvbW1vblByb3BlcnRpZXMpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWVbcHJvcGVydHldID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHNpbXBsZUVycm9yW3Byb3BlcnR5XSA9IHZhbHVlW3Byb3BlcnR5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNpbXBsZUVycm9yO1xuICB9XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZTogU3RyaW5nKHZhbHVlKVxuICB9O1xufTtcbnZhciBleHRlcm5hbEFib3J0TWVzc2FnZSA9IFwiRXh0ZXJuYWwgc2lnbmFsIHdhcyBhYm9ydGVkXCI7XG52YXIgY3JlYXRlQXN5bmNUaHVuayA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4ge1xuICBmdW5jdGlvbiBjcmVhdGVBc3luY1RodW5rMih0eXBlUHJlZml4LCBwYXlsb2FkQ3JlYXRvciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGZ1bGZpbGxlZCA9IGNyZWF0ZUFjdGlvbih0eXBlUHJlZml4ICsgXCIvZnVsZmlsbGVkXCIsIChwYXlsb2FkLCByZXF1ZXN0SWQsIGFyZywgbWV0YSkgPT4gKHtcbiAgICAgIHBheWxvYWQsXG4gICAgICBtZXRhOiB7XG4gICAgICAgIC4uLm1ldGEgfHwge30sXG4gICAgICAgIGFyZyxcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICByZXF1ZXN0U3RhdHVzOiBcImZ1bGZpbGxlZFwiXG4gICAgICB9XG4gICAgfSkpO1xuICAgIGNvbnN0IHBlbmRpbmcgPSBjcmVhdGVBY3Rpb24odHlwZVByZWZpeCArIFwiL3BlbmRpbmdcIiwgKHJlcXVlc3RJZCwgYXJnLCBtZXRhKSA9PiAoe1xuICAgICAgcGF5bG9hZDogdm9pZCAwLFxuICAgICAgbWV0YToge1xuICAgICAgICAuLi5tZXRhIHx8IHt9LFxuICAgICAgICBhcmcsXG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgcmVxdWVzdFN0YXR1czogXCJwZW5kaW5nXCJcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgY29uc3QgcmVqZWN0ZWQgPSBjcmVhdGVBY3Rpb24odHlwZVByZWZpeCArIFwiL3JlamVjdGVkXCIsIChlcnJvciwgcmVxdWVzdElkLCBhcmcsIHBheWxvYWQsIG1ldGEpID0+ICh7XG4gICAgICBwYXlsb2FkLFxuICAgICAgZXJyb3I6IChvcHRpb25zICYmIG9wdGlvbnMuc2VyaWFsaXplRXJyb3IgfHwgbWluaVNlcmlhbGl6ZUVycm9yKShlcnJvciB8fCBcIlJlamVjdGVkXCIpLFxuICAgICAgbWV0YToge1xuICAgICAgICAuLi5tZXRhIHx8IHt9LFxuICAgICAgICBhcmcsXG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgcmVqZWN0ZWRXaXRoVmFsdWU6ICEhcGF5bG9hZCxcbiAgICAgICAgcmVxdWVzdFN0YXR1czogXCJyZWplY3RlZFwiLFxuICAgICAgICBhYm9ydGVkOiBlcnJvcj8ubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIsXG4gICAgICAgIGNvbmRpdGlvbjogZXJyb3I/Lm5hbWUgPT09IFwiQ29uZGl0aW9uRXJyb3JcIlxuICAgICAgfVxuICAgIH0pKTtcbiAgICBmdW5jdGlvbiBhY3Rpb25DcmVhdG9yKGFyZywge1xuICAgICAgc2lnbmFsXG4gICAgfSA9IHt9KSB7XG4gICAgICByZXR1cm4gKGRpc3BhdGNoLCBnZXRTdGF0ZSwgZXh0cmEpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gb3B0aW9ucz8uaWRHZW5lcmF0b3IgPyBvcHRpb25zLmlkR2VuZXJhdG9yKGFyZykgOiBuYW5vaWQoKTtcbiAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBsZXQgYWJvcnRIYW5kbGVyO1xuICAgICAgICBsZXQgYWJvcnRSZWFzb247XG4gICAgICAgIGZ1bmN0aW9uIGFib3J0KHJlYXNvbikge1xuICAgICAgICAgIGFib3J0UmVhc29uID0gcmVhc29uO1xuICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaWduYWwpIHtcbiAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIGFib3J0KGV4dGVybmFsQWJvcnRNZXNzYWdlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiBhYm9ydChleHRlcm5hbEFib3J0TWVzc2FnZSksIHtcbiAgICAgICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgICAgICAgICBsZXQgZmluYWxBY3Rpb247XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBjb25kaXRpb25SZXN1bHQgPSBvcHRpb25zPy5jb25kaXRpb24/LihhcmcsIHtcbiAgICAgICAgICAgICAgZ2V0U3RhdGUsXG4gICAgICAgICAgICAgIGV4dHJhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpc1RoZW5hYmxlKGNvbmRpdGlvblJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgY29uZGl0aW9uUmVzdWx0ID0gYXdhaXQgY29uZGl0aW9uUmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmRpdGlvblJlc3VsdCA9PT0gZmFsc2UgfHwgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIkNvbmRpdGlvbkVycm9yXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJBYm9ydGVkIGR1ZSB0byBjb25kaXRpb24gY2FsbGJhY2sgcmV0dXJuaW5nIGZhbHNlLlwiXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhYm9ydGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgYWJvcnRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICAgICAgICBuYW1lOiBcIkFib3J0RXJyb3JcIixcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGFib3J0UmVhc29uIHx8IFwiQWJvcnRlZFwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0SGFuZGxlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRpc3BhdGNoKHBlbmRpbmcocmVxdWVzdElkLCBhcmcsIG9wdGlvbnM/LmdldFBlbmRpbmdNZXRhPy4oe1xuICAgICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgIGFyZ1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBnZXRTdGF0ZSxcbiAgICAgICAgICAgICAgZXh0cmFcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICBmaW5hbEFjdGlvbiA9IGF3YWl0IFByb21pc2UucmFjZShbYWJvcnRlZFByb21pc2UsIFByb21pc2UucmVzb2x2ZShwYXlsb2FkQ3JlYXRvcihhcmcsIHtcbiAgICAgICAgICAgICAgZGlzcGF0Y2gsXG4gICAgICAgICAgICAgIGdldFN0YXRlLFxuICAgICAgICAgICAgICBleHRyYSxcbiAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgICAgIGFib3J0LFxuICAgICAgICAgICAgICByZWplY3RXaXRoVmFsdWU6ICh2YWx1ZSwgbWV0YSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVqZWN0V2l0aFZhbHVlKHZhbHVlLCBtZXRhKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZnVsZmlsbFdpdGhWYWx1ZTogKHZhbHVlLCBtZXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGdWxmaWxsV2l0aE1ldGEodmFsdWUsIG1ldGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBSZWplY3RXaXRoVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyByZXN1bHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEZ1bGZpbGxXaXRoTWV0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdWxmaWxsZWQocmVzdWx0LnBheWxvYWQsIHJlcXVlc3RJZCwgYXJnLCByZXN1bHQubWV0YSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bGZpbGxlZChyZXN1bHQsIHJlcXVlc3RJZCwgYXJnKTtcbiAgICAgICAgICAgIH0pXSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBmaW5hbEFjdGlvbiA9IGVyciBpbnN0YW5jZW9mIFJlamVjdFdpdGhWYWx1ZSA/IHJlamVjdGVkKG51bGwsIHJlcXVlc3RJZCwgYXJnLCBlcnIucGF5bG9hZCwgZXJyLm1ldGEpIDogcmVqZWN0ZWQoZXJyLCByZXF1ZXN0SWQsIGFyZyk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChhYm9ydEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgYWJvcnRIYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc2tpcERpc3BhdGNoID0gb3B0aW9ucyAmJiAhb3B0aW9ucy5kaXNwYXRjaENvbmRpdGlvblJlamVjdGlvbiAmJiByZWplY3RlZC5tYXRjaChmaW5hbEFjdGlvbikgJiYgZmluYWxBY3Rpb24ubWV0YS5jb25kaXRpb247XG4gICAgICAgICAgaWYgKCFza2lwRGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKGZpbmFsQWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZpbmFsQWN0aW9uO1xuICAgICAgICB9KCk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHByb21pc2UsIHtcbiAgICAgICAgICBhYm9ydCxcbiAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgYXJnLFxuICAgICAgICAgIHVud3JhcCgpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4odW53cmFwUmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYWN0aW9uQ3JlYXRvciwge1xuICAgICAgcGVuZGluZyxcbiAgICAgIHJlamVjdGVkLFxuICAgICAgZnVsZmlsbGVkLFxuICAgICAgc2V0dGxlZDogaXNBbnlPZihyZWplY3RlZCwgZnVsZmlsbGVkKSxcbiAgICAgIHR5cGVQcmVmaXhcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVBc3luY1RodW5rMi53aXRoVHlwZXMgPSAoKSA9PiBjcmVhdGVBc3luY1RodW5rMjtcbiAgcmV0dXJuIGNyZWF0ZUFzeW5jVGh1bmsyO1xufSkoKTtcbmZ1bmN0aW9uIHVud3JhcFJlc3VsdChhY3Rpb24pIHtcbiAgaWYgKGFjdGlvbi5tZXRhICYmIGFjdGlvbi5tZXRhLnJlamVjdGVkV2l0aFZhbHVlKSB7XG4gICAgdGhyb3cgYWN0aW9uLnBheWxvYWQ7XG4gIH1cbiAgaWYgKGFjdGlvbi5lcnJvcikge1xuICAgIHRocm93IGFjdGlvbi5lcnJvcjtcbiAgfVxuICByZXR1cm4gYWN0aW9uLnBheWxvYWQ7XG59XG5mdW5jdGlvbiBpc1RoZW5hYmxlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuLy8gc3JjL2NyZWF0ZVNsaWNlLnRzXG52YXIgYXN5bmNUaHVua1N5bWJvbCA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwicnRrLXNsaWNlLWNyZWF0ZWFzeW5jdGh1bmtcIik7XG52YXIgYXN5bmNUaHVua0NyZWF0b3IgPSB7XG4gIFthc3luY1RodW5rU3ltYm9sXTogY3JlYXRlQXN5bmNUaHVua1xufTtcbnZhciBSZWR1Y2VyVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFJlZHVjZXJUeXBlMikgPT4ge1xuICBSZWR1Y2VyVHlwZTJbXCJyZWR1Y2VyXCJdID0gXCJyZWR1Y2VyXCI7XG4gIFJlZHVjZXJUeXBlMltcInJlZHVjZXJXaXRoUHJlcGFyZVwiXSA9IFwicmVkdWNlcldpdGhQcmVwYXJlXCI7XG4gIFJlZHVjZXJUeXBlMltcImFzeW5jVGh1bmtcIl0gPSBcImFzeW5jVGh1bmtcIjtcbiAgcmV0dXJuIFJlZHVjZXJUeXBlMjtcbn0pKFJlZHVjZXJUeXBlIHx8IHt9KTtcbmZ1bmN0aW9uIGdldFR5cGUoc2xpY2UsIGFjdGlvbktleSkge1xuICByZXR1cm4gYCR7c2xpY2V9LyR7YWN0aW9uS2V5fWA7XG59XG5mdW5jdGlvbiBidWlsZENyZWF0ZVNsaWNlKHtcbiAgY3JlYXRvcnNcbn0gPSB7fSkge1xuICBjb25zdCBjQVQgPSBjcmVhdG9ycz8uYXN5bmNUaHVuaz8uW2FzeW5jVGh1bmtTeW1ib2xdO1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlU2xpY2UyKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgcmVkdWNlclBhdGggPSBuYW1lXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMSkgOiBcImBuYW1lYCBpcyBhIHJlcXVpcmVkIG9wdGlvbiBmb3IgY3JlYXRlU2xpY2VcIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICBpZiAob3B0aW9ucy5pbml0aWFsU3RhdGUgPT09IHZvaWQgMCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiWW91IG11c3QgcHJvdmlkZSBhbiBgaW5pdGlhbFN0YXRlYCB2YWx1ZSB0aGF0IGlzIG5vdCBgdW5kZWZpbmVkYC4gWW91IG1heSBoYXZlIG1pc3NwZWxsZWQgYGluaXRpYWxTdGF0ZWBcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlZHVjZXJzID0gKHR5cGVvZiBvcHRpb25zLnJlZHVjZXJzID09PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zLnJlZHVjZXJzKGJ1aWxkUmVkdWNlckNyZWF0b3JzKCkpIDogb3B0aW9ucy5yZWR1Y2VycykgfHwge307XG4gICAgY29uc3QgcmVkdWNlck5hbWVzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBzbGljZUNhc2VSZWR1Y2Vyc0J5TmFtZToge30sXG4gICAgICBzbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZToge30sXG4gICAgICBhY3Rpb25DcmVhdG9yczoge30sXG4gICAgICBzbGljZU1hdGNoZXJzOiBbXVxuICAgIH07XG4gICAgY29uc3QgY29udGV4dE1ldGhvZHMgPSB7XG4gICAgICBhZGRDYXNlKHR5cGVPckFjdGlvbkNyZWF0b3IsIHJlZHVjZXIyKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdHlwZU9yQWN0aW9uQ3JlYXRvciA9PT0gXCJzdHJpbmdcIiA/IHR5cGVPckFjdGlvbkNyZWF0b3IgOiB0eXBlT3JBY3Rpb25DcmVhdG9yLnR5cGU7XG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEyKSA6IFwiYGNvbnRleHQuYWRkQ2FzZWAgY2Fubm90IGJlIGNhbGxlZCB3aXRoIGFuIGVtcHR5IGFjdGlvbiB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlIGluIGNvbnRleHQuc2xpY2VDYXNlUmVkdWNlcnNCeVR5cGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMykgOiBcImBjb250ZXh0LmFkZENhc2VgIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCB0d28gcmVkdWNlcnMgZm9yIHRoZSBzYW1lIGFjdGlvbiB0eXBlOiBcIiArIHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuc2xpY2VDYXNlUmVkdWNlcnNCeVR5cGVbdHlwZV0gPSByZWR1Y2VyMjtcbiAgICAgICAgcmV0dXJuIGNvbnRleHRNZXRob2RzO1xuICAgICAgfSxcbiAgICAgIGFkZE1hdGNoZXIobWF0Y2hlciwgcmVkdWNlcjIpIHtcbiAgICAgICAgY29udGV4dC5zbGljZU1hdGNoZXJzLnB1c2goe1xuICAgICAgICAgIG1hdGNoZXIsXG4gICAgICAgICAgcmVkdWNlcjogcmVkdWNlcjJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb250ZXh0TWV0aG9kcztcbiAgICAgIH0sXG4gICAgICBleHBvc2VBY3Rpb24obmFtZTIsIGFjdGlvbkNyZWF0b3IpIHtcbiAgICAgICAgY29udGV4dC5hY3Rpb25DcmVhdG9yc1tuYW1lMl0gPSBhY3Rpb25DcmVhdG9yO1xuICAgICAgICByZXR1cm4gY29udGV4dE1ldGhvZHM7XG4gICAgICB9LFxuICAgICAgZXhwb3NlQ2FzZVJlZHVjZXIobmFtZTIsIHJlZHVjZXIyKSB7XG4gICAgICAgIGNvbnRleHQuc2xpY2VDYXNlUmVkdWNlcnNCeU5hbWVbbmFtZTJdID0gcmVkdWNlcjI7XG4gICAgICAgIHJldHVybiBjb250ZXh0TWV0aG9kcztcbiAgICAgIH1cbiAgICB9O1xuICAgIHJlZHVjZXJOYW1lcy5mb3JFYWNoKChyZWR1Y2VyTmFtZSkgPT4ge1xuICAgICAgY29uc3QgcmVkdWNlckRlZmluaXRpb24gPSByZWR1Y2Vyc1tyZWR1Y2VyTmFtZV07XG4gICAgICBjb25zdCByZWR1Y2VyRGV0YWlscyA9IHtcbiAgICAgICAgcmVkdWNlck5hbWUsXG4gICAgICAgIHR5cGU6IGdldFR5cGUobmFtZSwgcmVkdWNlck5hbWUpLFxuICAgICAgICBjcmVhdGVOb3RhdGlvbjogdHlwZW9mIG9wdGlvbnMucmVkdWNlcnMgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgfTtcbiAgICAgIGlmIChpc0FzeW5jVGh1bmtTbGljZVJlZHVjZXJEZWZpbml0aW9uKHJlZHVjZXJEZWZpbml0aW9uKSkge1xuICAgICAgICBoYW5kbGVUaHVua0Nhc2VSZWR1Y2VyRGVmaW5pdGlvbihyZWR1Y2VyRGV0YWlscywgcmVkdWNlckRlZmluaXRpb24sIGNvbnRleHRNZXRob2RzLCBjQVQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlTm9ybWFsUmVkdWNlckRlZmluaXRpb24ocmVkdWNlckRldGFpbHMsIHJlZHVjZXJEZWZpbml0aW9uLCBjb250ZXh0TWV0aG9kcyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gYnVpbGRSZWR1Y2VyKCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZXh0cmFSZWR1Y2VycyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE0KSA6IFwiVGhlIG9iamVjdCBub3RhdGlvbiBmb3IgYGNyZWF0ZVNsaWNlLmV4dHJhUmVkdWNlcnNgIGhhcyBiZWVuIHJlbW92ZWQuIFBsZWFzZSB1c2UgdGhlICdidWlsZGVyIGNhbGxiYWNrJyBub3RhdGlvbiBpbnN0ZWFkOiBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL2FwaS9jcmVhdGVTbGljZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgW2V4dHJhUmVkdWNlcnMgPSB7fSwgYWN0aW9uTWF0Y2hlcnMgPSBbXSwgZGVmYXVsdENhc2VSZWR1Y2VyID0gdm9pZCAwXSA9IHR5cGVvZiBvcHRpb25zLmV4dHJhUmVkdWNlcnMgPT09IFwiZnVuY3Rpb25cIiA/IGV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrKG9wdGlvbnMuZXh0cmFSZWR1Y2VycykgOiBbb3B0aW9ucy5leHRyYVJlZHVjZXJzXTtcbiAgICAgIGNvbnN0IGZpbmFsQ2FzZVJlZHVjZXJzID0ge1xuICAgICAgICAuLi5leHRyYVJlZHVjZXJzLFxuICAgICAgICAuLi5jb250ZXh0LnNsaWNlQ2FzZVJlZHVjZXJzQnlUeXBlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlZHVjZXIob3B0aW9ucy5pbml0aWFsU3RhdGUsIChidWlsZGVyKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBmaW5hbENhc2VSZWR1Y2Vycykge1xuICAgICAgICAgIGJ1aWxkZXIuYWRkQ2FzZShrZXksIGZpbmFsQ2FzZVJlZHVjZXJzW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHNNIG9mIGNvbnRleHQuc2xpY2VNYXRjaGVycykge1xuICAgICAgICAgIGJ1aWxkZXIuYWRkTWF0Y2hlcihzTS5tYXRjaGVyLCBzTS5yZWR1Y2VyKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBtIG9mIGFjdGlvbk1hdGNoZXJzKSB7XG4gICAgICAgICAgYnVpbGRlci5hZGRNYXRjaGVyKG0ubWF0Y2hlciwgbS5yZWR1Y2VyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmYXVsdENhc2VSZWR1Y2VyKSB7XG4gICAgICAgICAgYnVpbGRlci5hZGREZWZhdWx0Q2FzZShkZWZhdWx0Q2FzZVJlZHVjZXIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0U2VsZiA9IChzdGF0ZSkgPT4gc3RhdGU7XG4gICAgY29uc3QgaW5qZWN0ZWRTZWxlY3RvckNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBpbmplY3RlZFN0YXRlQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgICBsZXQgX3JlZHVjZXI7XG4gICAgZnVuY3Rpb24gcmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICBpZiAoIV9yZWR1Y2VyKSBfcmVkdWNlciA9IGJ1aWxkUmVkdWNlcigpO1xuICAgICAgcmV0dXJuIF9yZWR1Y2VyKHN0YXRlLCBhY3Rpb24pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgICBpZiAoIV9yZWR1Y2VyKSBfcmVkdWNlciA9IGJ1aWxkUmVkdWNlcigpO1xuICAgICAgcmV0dXJuIF9yZWR1Y2VyLmdldEluaXRpYWxTdGF0ZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlU2VsZWN0b3JQcm9wcyhyZWR1Y2VyUGF0aDIsIGluamVjdGVkID0gZmFsc2UpIHtcbiAgICAgIGZ1bmN0aW9uIHNlbGVjdFNsaWNlKHN0YXRlKSB7XG4gICAgICAgIGxldCBzbGljZVN0YXRlID0gc3RhdGVbcmVkdWNlclBhdGgyXTtcbiAgICAgICAgaWYgKHR5cGVvZiBzbGljZVN0YXRlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgaWYgKGluamVjdGVkKSB7XG4gICAgICAgICAgICBzbGljZVN0YXRlID0gZ2V0T3JJbnNlcnRDb21wdXRlZChpbmplY3RlZFN0YXRlQ2FjaGUsIHNlbGVjdFNsaWNlLCBnZXRJbml0aWFsU3RhdGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNSkgOiBcInNlbGVjdFNsaWNlIHJldHVybmVkIHVuZGVmaW5lZCBmb3IgYW4gdW5pbmplY3RlZCBzbGljZSByZWR1Y2VyXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2xpY2VTdGF0ZTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGdldFNlbGVjdG9ycyhzZWxlY3RTdGF0ZSA9IHNlbGVjdFNlbGYpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3JDYWNoZSA9IGdldE9ySW5zZXJ0Q29tcHV0ZWQoaW5qZWN0ZWRTZWxlY3RvckNhY2hlLCBpbmplY3RlZCwgKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCkpO1xuICAgICAgICByZXR1cm4gZ2V0T3JJbnNlcnRDb21wdXRlZChzZWxlY3RvckNhY2hlLCBzZWxlY3RTdGF0ZSwgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IG1hcCA9IHt9O1xuICAgICAgICAgIGZvciAoY29uc3QgW25hbWUyLCBzZWxlY3Rvcl0gb2YgT2JqZWN0LmVudHJpZXMob3B0aW9ucy5zZWxlY3RvcnMgPz8ge30pKSB7XG4gICAgICAgICAgICBtYXBbbmFtZTJdID0gd3JhcFNlbGVjdG9yKHNlbGVjdG9yLCBzZWxlY3RTdGF0ZSwgKCkgPT4gZ2V0T3JJbnNlcnRDb21wdXRlZChpbmplY3RlZFN0YXRlQ2FjaGUsIHNlbGVjdFN0YXRlLCBnZXRJbml0aWFsU3RhdGUpLCBpbmplY3RlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVkdWNlclBhdGg6IHJlZHVjZXJQYXRoMixcbiAgICAgICAgZ2V0U2VsZWN0b3JzLFxuICAgICAgICBnZXQgc2VsZWN0b3JzKCkge1xuICAgICAgICAgIHJldHVybiBnZXRTZWxlY3RvcnMoc2VsZWN0U2xpY2UpO1xuICAgICAgICB9LFxuICAgICAgICBzZWxlY3RTbGljZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgc2xpY2UgPSB7XG4gICAgICBuYW1lLFxuICAgICAgcmVkdWNlcixcbiAgICAgIGFjdGlvbnM6IGNvbnRleHQuYWN0aW9uQ3JlYXRvcnMsXG4gICAgICBjYXNlUmVkdWNlcnM6IGNvbnRleHQuc2xpY2VDYXNlUmVkdWNlcnNCeU5hbWUsXG4gICAgICBnZXRJbml0aWFsU3RhdGUsXG4gICAgICAuLi5tYWtlU2VsZWN0b3JQcm9wcyhyZWR1Y2VyUGF0aCksXG4gICAgICBpbmplY3RJbnRvKGluamVjdGFibGUsIHtcbiAgICAgICAgcmVkdWNlclBhdGg6IHBhdGhPcHQsXG4gICAgICAgIC4uLmNvbmZpZ1xuICAgICAgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG5ld1JlZHVjZXJQYXRoID0gcGF0aE9wdCA/PyByZWR1Y2VyUGF0aDtcbiAgICAgICAgaW5qZWN0YWJsZS5pbmplY3Qoe1xuICAgICAgICAgIHJlZHVjZXJQYXRoOiBuZXdSZWR1Y2VyUGF0aCxcbiAgICAgICAgICByZWR1Y2VyXG4gICAgICAgIH0sIGNvbmZpZyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uc2xpY2UsXG4gICAgICAgICAgLi4ubWFrZVNlbGVjdG9yUHJvcHMobmV3UmVkdWNlclBhdGgsIHRydWUpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gc2xpY2U7XG4gIH07XG59XG5mdW5jdGlvbiB3cmFwU2VsZWN0b3Ioc2VsZWN0b3IsIHNlbGVjdFN0YXRlLCBnZXRJbml0aWFsU3RhdGUsIGluamVjdGVkKSB7XG4gIGZ1bmN0aW9uIHdyYXBwZXIocm9vdFN0YXRlLCAuLi5hcmdzKSB7XG4gICAgbGV0IHNsaWNlU3RhdGUgPSBzZWxlY3RTdGF0ZShyb290U3RhdGUpO1xuICAgIGlmICh0eXBlb2Ygc2xpY2VTdGF0ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKGluamVjdGVkKSB7XG4gICAgICAgIHNsaWNlU3RhdGUgPSBnZXRJbml0aWFsU3RhdGUoKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE2KSA6IFwic2VsZWN0U3RhdGUgcmV0dXJuZWQgdW5kZWZpbmVkIGZvciBhbiB1bmluamVjdGVkIHNsaWNlIHJlZHVjZXJcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RvcihzbGljZVN0YXRlLCAuLi5hcmdzKTtcbiAgfVxuICB3cmFwcGVyLnVud3JhcHBlZCA9IHNlbGVjdG9yO1xuICByZXR1cm4gd3JhcHBlcjtcbn1cbnZhciBjcmVhdGVTbGljZSA9IC8qIEBfX1BVUkVfXyAqLyBidWlsZENyZWF0ZVNsaWNlKCk7XG5mdW5jdGlvbiBidWlsZFJlZHVjZXJDcmVhdG9ycygpIHtcbiAgZnVuY3Rpb24gYXN5bmNUaHVuayhwYXlsb2FkQ3JlYXRvciwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9yZWR1Y2VyRGVmaW5pdGlvblR5cGU6IFwiYXN5bmNUaHVua1wiIC8qIGFzeW5jVGh1bmsgKi8sXG4gICAgICBwYXlsb2FkQ3JlYXRvcixcbiAgICAgIC4uLmNvbmZpZ1xuICAgIH07XG4gIH1cbiAgYXN5bmNUaHVuay53aXRoVHlwZXMgPSAoKSA9PiBhc3luY1RodW5rO1xuICByZXR1cm4ge1xuICAgIHJlZHVjZXIoY2FzZVJlZHVjZXIpIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgLy8gaGFjayBzbyB0aGUgd3JhcHBpbmcgZnVuY3Rpb24gaGFzIHRoZSBzYW1lIG5hbWUgYXMgdGhlIG9yaWdpbmFsXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gY3JlYXRlIGEgd3JhcHBlciBzbyB0aGUgYHJlZHVjZXJEZWZpbml0aW9uVHlwZWAgaXMgbm90IGFzc2lnbmVkIHRvIHRoZSBvcmlnaW5hbFxuICAgICAgICBbY2FzZVJlZHVjZXIubmFtZV0oLi4uYXJncykge1xuICAgICAgICAgIHJldHVybiBjYXNlUmVkdWNlciguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgfVtjYXNlUmVkdWNlci5uYW1lXSwge1xuICAgICAgICBfcmVkdWNlckRlZmluaXRpb25UeXBlOiBcInJlZHVjZXJcIiAvKiByZWR1Y2VyICovXG4gICAgICB9KTtcbiAgICB9LFxuICAgIHByZXBhcmVkUmVkdWNlcihwcmVwYXJlLCByZWR1Y2VyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBfcmVkdWNlckRlZmluaXRpb25UeXBlOiBcInJlZHVjZXJXaXRoUHJlcGFyZVwiIC8qIHJlZHVjZXJXaXRoUHJlcGFyZSAqLyxcbiAgICAgICAgcHJlcGFyZSxcbiAgICAgICAgcmVkdWNlclxuICAgICAgfTtcbiAgICB9LFxuICAgIGFzeW5jVGh1bmtcbiAgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU5vcm1hbFJlZHVjZXJEZWZpbml0aW9uKHtcbiAgdHlwZSxcbiAgcmVkdWNlck5hbWUsXG4gIGNyZWF0ZU5vdGF0aW9uXG59LCBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSwgY29udGV4dCkge1xuICBsZXQgY2FzZVJlZHVjZXI7XG4gIGxldCBwcmVwYXJlQ2FsbGJhY2s7XG4gIGlmIChcInJlZHVjZXJcIiBpbiBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSkge1xuICAgIGlmIChjcmVhdGVOb3RhdGlvbiAmJiAhaXNDYXNlUmVkdWNlcldpdGhQcmVwYXJlRGVmaW5pdGlvbihtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE3KSA6IFwiUGxlYXNlIHVzZSB0aGUgYGNyZWF0ZS5wcmVwYXJlZFJlZHVjZXJgIG5vdGF0aW9uIGZvciBwcmVwYXJlZCBhY3Rpb24gY3JlYXRvcnMgd2l0aCB0aGUgYGNyZWF0ZWAgbm90YXRpb24uXCIpO1xuICAgIH1cbiAgICBjYXNlUmVkdWNlciA9IG1heWJlUmVkdWNlcldpdGhQcmVwYXJlLnJlZHVjZXI7XG4gICAgcHJlcGFyZUNhbGxiYWNrID0gbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUucHJlcGFyZTtcbiAgfSBlbHNlIHtcbiAgICBjYXNlUmVkdWNlciA9IG1heWJlUmVkdWNlcldpdGhQcmVwYXJlO1xuICB9XG4gIGNvbnRleHQuYWRkQ2FzZSh0eXBlLCBjYXNlUmVkdWNlcikuZXhwb3NlQ2FzZVJlZHVjZXIocmVkdWNlck5hbWUsIGNhc2VSZWR1Y2VyKS5leHBvc2VBY3Rpb24ocmVkdWNlck5hbWUsIHByZXBhcmVDYWxsYmFjayA/IGNyZWF0ZUFjdGlvbih0eXBlLCBwcmVwYXJlQ2FsbGJhY2spIDogY3JlYXRlQWN0aW9uKHR5cGUpKTtcbn1cbmZ1bmN0aW9uIGlzQXN5bmNUaHVua1NsaWNlUmVkdWNlckRlZmluaXRpb24ocmVkdWNlckRlZmluaXRpb24pIHtcbiAgcmV0dXJuIHJlZHVjZXJEZWZpbml0aW9uLl9yZWR1Y2VyRGVmaW5pdGlvblR5cGUgPT09IFwiYXN5bmNUaHVua1wiIC8qIGFzeW5jVGh1bmsgKi87XG59XG5mdW5jdGlvbiBpc0Nhc2VSZWR1Y2VyV2l0aFByZXBhcmVEZWZpbml0aW9uKHJlZHVjZXJEZWZpbml0aW9uKSB7XG4gIHJldHVybiByZWR1Y2VyRGVmaW5pdGlvbi5fcmVkdWNlckRlZmluaXRpb25UeXBlID09PSBcInJlZHVjZXJXaXRoUHJlcGFyZVwiIC8qIHJlZHVjZXJXaXRoUHJlcGFyZSAqLztcbn1cbmZ1bmN0aW9uIGhhbmRsZVRodW5rQ2FzZVJlZHVjZXJEZWZpbml0aW9uKHtcbiAgdHlwZSxcbiAgcmVkdWNlck5hbWVcbn0sIHJlZHVjZXJEZWZpbml0aW9uLCBjb250ZXh0LCBjQVQpIHtcbiAgaWYgKCFjQVQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxOCkgOiBcIkNhbm5vdCB1c2UgYGNyZWF0ZS5hc3luY1RodW5rYCBpbiB0aGUgYnVpbHQtaW4gYGNyZWF0ZVNsaWNlYC4gVXNlIGBidWlsZENyZWF0ZVNsaWNlKHsgY3JlYXRvcnM6IHsgYXN5bmNUaHVuazogYXN5bmNUaHVua0NyZWF0b3IgfSB9KWAgdG8gY3JlYXRlIGEgY3VzdG9taXNlZCB2ZXJzaW9uIG9mIGBjcmVhdGVTbGljZWAuXCIpO1xuICB9XG4gIGNvbnN0IHtcbiAgICBwYXlsb2FkQ3JlYXRvcixcbiAgICBmdWxmaWxsZWQsXG4gICAgcGVuZGluZyxcbiAgICByZWplY3RlZCxcbiAgICBzZXR0bGVkLFxuICAgIG9wdGlvbnNcbiAgfSA9IHJlZHVjZXJEZWZpbml0aW9uO1xuICBjb25zdCB0aHVuayA9IGNBVCh0eXBlLCBwYXlsb2FkQ3JlYXRvciwgb3B0aW9ucyk7XG4gIGNvbnRleHQuZXhwb3NlQWN0aW9uKHJlZHVjZXJOYW1lLCB0aHVuayk7XG4gIGlmIChmdWxmaWxsZWQpIHtcbiAgICBjb250ZXh0LmFkZENhc2UodGh1bmsuZnVsZmlsbGVkLCBmdWxmaWxsZWQpO1xuICB9XG4gIGlmIChwZW5kaW5nKSB7XG4gICAgY29udGV4dC5hZGRDYXNlKHRodW5rLnBlbmRpbmcsIHBlbmRpbmcpO1xuICB9XG4gIGlmIChyZWplY3RlZCkge1xuICAgIGNvbnRleHQuYWRkQ2FzZSh0aHVuay5yZWplY3RlZCwgcmVqZWN0ZWQpO1xuICB9XG4gIGlmIChzZXR0bGVkKSB7XG4gICAgY29udGV4dC5hZGRNYXRjaGVyKHRodW5rLnNldHRsZWQsIHNldHRsZWQpO1xuICB9XG4gIGNvbnRleHQuZXhwb3NlQ2FzZVJlZHVjZXIocmVkdWNlck5hbWUsIHtcbiAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCB8fCBub29wLFxuICAgIHBlbmRpbmc6IHBlbmRpbmcgfHwgbm9vcCxcbiAgICByZWplY3RlZDogcmVqZWN0ZWQgfHwgbm9vcCxcbiAgICBzZXR0bGVkOiBzZXR0bGVkIHx8IG5vb3BcbiAgfSk7XG59XG5mdW5jdGlvbiBub29wKCkge1xufVxuXG4vLyBzcmMvZW50aXRpZXMvZW50aXR5X3N0YXRlLnRzXG5mdW5jdGlvbiBnZXRJbml0aWFsRW50aXR5U3RhdGUoKSB7XG4gIHJldHVybiB7XG4gICAgaWRzOiBbXSxcbiAgICBlbnRpdGllczoge31cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUluaXRpYWxTdGF0ZUZhY3Rvcnkoc3RhdGVBZGFwdGVyKSB7XG4gIGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZShhZGRpdGlvbmFsU3RhdGUgPSB7fSwgZW50aXRpZXMpIHtcbiAgICBjb25zdCBzdGF0ZSA9IE9iamVjdC5hc3NpZ24oZ2V0SW5pdGlhbEVudGl0eVN0YXRlKCksIGFkZGl0aW9uYWxTdGF0ZSk7XG4gICAgcmV0dXJuIGVudGl0aWVzID8gc3RhdGVBZGFwdGVyLnNldEFsbChzdGF0ZSwgZW50aXRpZXMpIDogc3RhdGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXRJbml0aWFsU3RhdGVcbiAgfTtcbn1cblxuLy8gc3JjL2VudGl0aWVzL3N0YXRlX3NlbGVjdG9ycy50c1xuZnVuY3Rpb24gY3JlYXRlU2VsZWN0b3JzRmFjdG9yeSgpIHtcbiAgZnVuY3Rpb24gZ2V0U2VsZWN0b3JzKHNlbGVjdFN0YXRlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICBjcmVhdGVTZWxlY3RvcjogY3JlYXRlU2VsZWN0b3IyID0gY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3JcbiAgICB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBzZWxlY3RJZHMgPSAoc3RhdGUpID0+IHN0YXRlLmlkcztcbiAgICBjb25zdCBzZWxlY3RFbnRpdGllcyA9IChzdGF0ZSkgPT4gc3RhdGUuZW50aXRpZXM7XG4gICAgY29uc3Qgc2VsZWN0QWxsID0gY3JlYXRlU2VsZWN0b3IyKHNlbGVjdElkcywgc2VsZWN0RW50aXRpZXMsIChpZHMsIGVudGl0aWVzKSA9PiBpZHMubWFwKChpZCkgPT4gZW50aXRpZXNbaWRdKSk7XG4gICAgY29uc3Qgc2VsZWN0SWQgPSAoXywgaWQpID0+IGlkO1xuICAgIGNvbnN0IHNlbGVjdEJ5SWQgPSAoZW50aXRpZXMsIGlkKSA9PiBlbnRpdGllc1tpZF07XG4gICAgY29uc3Qgc2VsZWN0VG90YWwgPSBjcmVhdGVTZWxlY3RvcjIoc2VsZWN0SWRzLCAoaWRzKSA9PiBpZHMubGVuZ3RoKTtcbiAgICBpZiAoIXNlbGVjdFN0YXRlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZWxlY3RJZHMsXG4gICAgICAgIHNlbGVjdEVudGl0aWVzLFxuICAgICAgICBzZWxlY3RBbGwsXG4gICAgICAgIHNlbGVjdFRvdGFsLFxuICAgICAgICBzZWxlY3RCeUlkOiBjcmVhdGVTZWxlY3RvcjIoc2VsZWN0RW50aXRpZXMsIHNlbGVjdElkLCBzZWxlY3RCeUlkKVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0R2xvYmFsaXplZEVudGl0aWVzID0gY3JlYXRlU2VsZWN0b3IyKHNlbGVjdFN0YXRlLCBzZWxlY3RFbnRpdGllcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNlbGVjdElkczogY3JlYXRlU2VsZWN0b3IyKHNlbGVjdFN0YXRlLCBzZWxlY3RJZHMpLFxuICAgICAgc2VsZWN0RW50aXRpZXM6IHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcyxcbiAgICAgIHNlbGVjdEFsbDogY3JlYXRlU2VsZWN0b3IyKHNlbGVjdFN0YXRlLCBzZWxlY3RBbGwpLFxuICAgICAgc2VsZWN0VG90YWw6IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RTdGF0ZSwgc2VsZWN0VG90YWwpLFxuICAgICAgc2VsZWN0QnlJZDogY3JlYXRlU2VsZWN0b3IyKHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcywgc2VsZWN0SWQsIHNlbGVjdEJ5SWQpXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldFNlbGVjdG9yc1xuICB9O1xufVxuXG4vLyBzcmMvZW50aXRpZXMvc3RhdGVfYWRhcHRlci50c1xuaW1wb3J0IHsgcHJvZHVjZSBhcyBjcmVhdGVOZXh0U3RhdGUzLCBpc0RyYWZ0IGFzIGlzRHJhZnQzIH0gZnJvbSBcImltbWVyXCI7XG52YXIgaXNEcmFmdFR5cGVkID0gaXNEcmFmdDM7XG5mdW5jdGlvbiBjcmVhdGVTaW5nbGVBcmd1bWVudFN0YXRlT3BlcmF0b3IobXV0YXRvcikge1xuICBjb25zdCBvcGVyYXRvciA9IGNyZWF0ZVN0YXRlT3BlcmF0b3IoKF8sIHN0YXRlKSA9PiBtdXRhdG9yKHN0YXRlKSk7XG4gIHJldHVybiBmdW5jdGlvbiBvcGVyYXRpb24oc3RhdGUpIHtcbiAgICByZXR1cm4gb3BlcmF0b3Ioc3RhdGUsIHZvaWQgMCk7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTdGF0ZU9wZXJhdG9yKG11dGF0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG9wZXJhdGlvbihzdGF0ZSwgYXJnKSB7XG4gICAgZnVuY3Rpb24gaXNQYXlsb2FkQWN0aW9uQXJndW1lbnQoYXJnMikge1xuICAgICAgcmV0dXJuIGlzRlNBKGFyZzIpO1xuICAgIH1cbiAgICBjb25zdCBydW5NdXRhdG9yID0gKGRyYWZ0KSA9PiB7XG4gICAgICBpZiAoaXNQYXlsb2FkQWN0aW9uQXJndW1lbnQoYXJnKSkge1xuICAgICAgICBtdXRhdG9yKGFyZy5wYXlsb2FkLCBkcmFmdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtdXRhdG9yKGFyZywgZHJhZnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzRHJhZnRUeXBlZChzdGF0ZSkpIHtcbiAgICAgIHJ1bk11dGF0b3Ioc3RhdGUpO1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlTmV4dFN0YXRlMyhzdGF0ZSwgcnVuTXV0YXRvcik7XG4gIH07XG59XG5cbi8vIHNyYy9lbnRpdGllcy91dGlscy50c1xuaW1wb3J0IHsgY3VycmVudCBhcyBjdXJyZW50MiwgaXNEcmFmdCBhcyBpc0RyYWZ0NCB9IGZyb20gXCJpbW1lclwiO1xuZnVuY3Rpb24gc2VsZWN0SWRWYWx1ZShlbnRpdHksIHNlbGVjdElkKSB7XG4gIGNvbnN0IGtleSA9IHNlbGVjdElkKGVudGl0eSk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYga2V5ID09PSB2b2lkIDApIHtcbiAgICBjb25zb2xlLndhcm4oXCJUaGUgZW50aXR5IHBhc3NlZCB0byB0aGUgYHNlbGVjdElkYCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCB1bmRlZmluZWQuXCIsIFwiWW91IHNob3VsZCBwcm9iYWJseSBwcm92aWRlIHlvdXIgb3duIGBzZWxlY3RJZGAgaW1wbGVtZW50YXRpb24uXCIsIFwiVGhlIGVudGl0eSB0aGF0IHdhcyBwYXNzZWQ6XCIsIGVudGl0eSwgXCJUaGUgYHNlbGVjdElkYCBpbXBsZW1lbnRhdGlvbjpcIiwgc2VsZWN0SWQudG9TdHJpbmcoKSk7XG4gIH1cbiAgcmV0dXJuIGtleTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUVudGl0aWVzQXJyYXkoZW50aXRpZXMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGVudGl0aWVzKSkge1xuICAgIGVudGl0aWVzID0gT2JqZWN0LnZhbHVlcyhlbnRpdGllcyk7XG4gIH1cbiAgcmV0dXJuIGVudGl0aWVzO1xufVxuZnVuY3Rpb24gZ2V0Q3VycmVudCh2YWx1ZSkge1xuICByZXR1cm4gaXNEcmFmdDQodmFsdWUpID8gY3VycmVudDIodmFsdWUpIDogdmFsdWU7XG59XG5mdW5jdGlvbiBzcGxpdEFkZGVkVXBkYXRlZEVudGl0aWVzKG5ld0VudGl0aWVzLCBzZWxlY3RJZCwgc3RhdGUpIHtcbiAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcbiAgY29uc3QgZXhpc3RpbmdJZHNBcnJheSA9IGdldEN1cnJlbnQoc3RhdGUuaWRzKTtcbiAgY29uc3QgZXhpc3RpbmdJZHMgPSBuZXcgU2V0KGV4aXN0aW5nSWRzQXJyYXkpO1xuICBjb25zdCBhZGRlZCA9IFtdO1xuICBjb25zdCBhZGRlZElkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtdKTtcbiAgY29uc3QgdXBkYXRlZCA9IFtdO1xuICBmb3IgKGNvbnN0IGVudGl0eSBvZiBuZXdFbnRpdGllcykge1xuICAgIGNvbnN0IGlkID0gc2VsZWN0SWRWYWx1ZShlbnRpdHksIHNlbGVjdElkKTtcbiAgICBpZiAoZXhpc3RpbmdJZHMuaGFzKGlkKSB8fCBhZGRlZElkcy5oYXMoaWQpKSB7XG4gICAgICB1cGRhdGVkLnB1c2goe1xuICAgICAgICBpZCxcbiAgICAgICAgY2hhbmdlczogZW50aXR5XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWRkZWRJZHMuYWRkKGlkKTtcbiAgICAgIGFkZGVkLnB1c2goZW50aXR5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFthZGRlZCwgdXBkYXRlZCwgZXhpc3RpbmdJZHNBcnJheV07XG59XG5cbi8vIHNyYy9lbnRpdGllcy91bnNvcnRlZF9zdGF0ZV9hZGFwdGVyLnRzXG5mdW5jdGlvbiBjcmVhdGVVbnNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCkge1xuICBmdW5jdGlvbiBhZGRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcbiAgICBjb25zdCBrZXkgPSBzZWxlY3RJZFZhbHVlKGVudGl0eSwgc2VsZWN0SWQpO1xuICAgIGlmIChrZXkgaW4gc3RhdGUuZW50aXRpZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3RhdGUuaWRzLnB1c2goa2V5KTtcbiAgICBzdGF0ZS5lbnRpdGllc1trZXldID0gZW50aXR5O1xuICB9XG4gIGZ1bmN0aW9uIGFkZE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgbmV3RW50aXRpZXMpIHtcbiAgICAgIGFkZE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNldE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xuICAgIGNvbnN0IGtleSA9IHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCk7XG4gICAgaWYgKCEoa2V5IGluIHN0YXRlLmVudGl0aWVzKSkge1xuICAgICAgc3RhdGUuaWRzLnB1c2goa2V5KTtcbiAgICB9XG4gICAgO1xuICAgIHN0YXRlLmVudGl0aWVzW2tleV0gPSBlbnRpdHk7XG4gIH1cbiAgZnVuY3Rpb24gc2V0TWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XG4gICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBuZXdFbnRpdGllcykge1xuICAgICAgc2V0T25lTXV0YWJseShlbnRpdHksIHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2V0QWxsTXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xuICAgIHN0YXRlLmlkcyA9IFtdO1xuICAgIHN0YXRlLmVudGl0aWVzID0ge307XG4gICAgYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVPbmVNdXRhYmx5KGtleSwgc3RhdGUpIHtcbiAgICByZXR1cm4gcmVtb3ZlTWFueU11dGFibHkoW2tleV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVNYW55TXV0YWJseShrZXlzLCBzdGF0ZSkge1xuICAgIGxldCBkaWRNdXRhdGUgPSBmYWxzZTtcbiAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgaWYgKGtleSBpbiBzdGF0ZS5lbnRpdGllcykge1xuICAgICAgICBkZWxldGUgc3RhdGUuZW50aXRpZXNba2V5XTtcbiAgICAgICAgZGlkTXV0YXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoZGlkTXV0YXRlKSB7XG4gICAgICBzdGF0ZS5pZHMgPSBzdGF0ZS5pZHMuZmlsdGVyKChpZCkgPT4gaWQgaW4gc3RhdGUuZW50aXRpZXMpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZW1vdmVBbGxNdXRhYmx5KHN0YXRlKSB7XG4gICAgT2JqZWN0LmFzc2lnbihzdGF0ZSwge1xuICAgICAgaWRzOiBbXSxcbiAgICAgIGVudGl0aWVzOiB7fVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHRha2VOZXdLZXkoa2V5cywgdXBkYXRlLCBzdGF0ZSkge1xuICAgIGNvbnN0IG9yaWdpbmFsMyA9IHN0YXRlLmVudGl0aWVzW3VwZGF0ZS5pZF07XG4gICAgaWYgKG9yaWdpbmFsMyA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHVwZGF0ZWQgPSBPYmplY3QuYXNzaWduKHt9LCBvcmlnaW5hbDMsIHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICBjb25zdCBuZXdLZXkgPSBzZWxlY3RJZFZhbHVlKHVwZGF0ZWQsIHNlbGVjdElkKTtcbiAgICBjb25zdCBoYXNOZXdLZXkgPSBuZXdLZXkgIT09IHVwZGF0ZS5pZDtcbiAgICBpZiAoaGFzTmV3S2V5KSB7XG4gICAgICBrZXlzW3VwZGF0ZS5pZF0gPSBuZXdLZXk7XG4gICAgICBkZWxldGUgc3RhdGUuZW50aXRpZXNbdXBkYXRlLmlkXTtcbiAgICB9XG4gICAgO1xuICAgIHN0YXRlLmVudGl0aWVzW25ld0tleV0gPSB1cGRhdGVkO1xuICAgIHJldHVybiBoYXNOZXdLZXk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlT25lTXV0YWJseSh1cGRhdGUsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHVwZGF0ZU1hbnlNdXRhYmx5KFt1cGRhdGVdLCBzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlTWFueU11dGFibHkodXBkYXRlcywgc3RhdGUpIHtcbiAgICBjb25zdCBuZXdLZXlzID0ge307XG4gICAgY29uc3QgdXBkYXRlc1BlckVudGl0eSA9IHt9O1xuICAgIHVwZGF0ZXMuZm9yRWFjaCgodXBkYXRlKSA9PiB7XG4gICAgICBpZiAodXBkYXRlLmlkIGluIHN0YXRlLmVudGl0aWVzKSB7XG4gICAgICAgIHVwZGF0ZXNQZXJFbnRpdHlbdXBkYXRlLmlkXSA9IHtcbiAgICAgICAgICBpZDogdXBkYXRlLmlkLFxuICAgICAgICAgIC8vIFNwcmVhZHMgaWdub3JlIGZhbHN5IHZhbHVlcywgc28gdGhpcyB3b3JrcyBldmVuIGlmIHRoZXJlIGlzbid0XG4gICAgICAgICAgLy8gYW4gZXhpc3RpbmcgdXBkYXRlIGFscmVhZHkgYXQgdGhpcyBrZXlcbiAgICAgICAgICBjaGFuZ2VzOiB7XG4gICAgICAgICAgICAuLi51cGRhdGVzUGVyRW50aXR5W3VwZGF0ZS5pZF0/LmNoYW5nZXMsXG4gICAgICAgICAgICAuLi51cGRhdGUuY2hhbmdlc1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB1cGRhdGVzID0gT2JqZWN0LnZhbHVlcyh1cGRhdGVzUGVyRW50aXR5KTtcbiAgICBjb25zdCBkaWRNdXRhdGVFbnRpdGllcyA9IHVwZGF0ZXMubGVuZ3RoID4gMDtcbiAgICBpZiAoZGlkTXV0YXRlRW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IGRpZE11dGF0ZUlkcyA9IHVwZGF0ZXMuZmlsdGVyKCh1cGRhdGUpID0+IHRha2VOZXdLZXkobmV3S2V5cywgdXBkYXRlLCBzdGF0ZSkpLmxlbmd0aCA+IDA7XG4gICAgICBpZiAoZGlkTXV0YXRlSWRzKSB7XG4gICAgICAgIHN0YXRlLmlkcyA9IE9iamVjdC52YWx1ZXMoc3RhdGUuZW50aXRpZXMpLm1hcCgoZSkgPT4gc2VsZWN0SWRWYWx1ZShlLCBzZWxlY3RJZCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1cHNlcnRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcbiAgICByZXR1cm4gdXBzZXJ0TWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiB1cHNlcnRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBjb25zdCBbYWRkZWQsIHVwZGF0ZWRdID0gc3BsaXRBZGRlZFVwZGF0ZWRFbnRpdGllcyhuZXdFbnRpdGllcywgc2VsZWN0SWQsIHN0YXRlKTtcbiAgICBhZGRNYW55TXV0YWJseShhZGRlZCwgc3RhdGUpO1xuICAgIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZWQsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHJlbW92ZUFsbDogY3JlYXRlU2luZ2xlQXJndW1lbnRTdGF0ZU9wZXJhdG9yKHJlbW92ZUFsbE11dGFibHkpLFxuICAgIGFkZE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihhZGRPbmVNdXRhYmx5KSxcbiAgICBhZGRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKGFkZE1hbnlNdXRhYmx5KSxcbiAgICBzZXRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0T25lTXV0YWJseSksXG4gICAgc2V0TWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRNYW55TXV0YWJseSksXG4gICAgc2V0QWxsOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldEFsbE11dGFibHkpLFxuICAgIHVwZGF0ZU9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cGRhdGVPbmVNdXRhYmx5KSxcbiAgICB1cGRhdGVNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwZGF0ZU1hbnlNdXRhYmx5KSxcbiAgICB1cHNlcnRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBzZXJ0T25lTXV0YWJseSksXG4gICAgdXBzZXJ0TWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cHNlcnRNYW55TXV0YWJseSksXG4gICAgcmVtb3ZlT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHJlbW92ZU9uZU11dGFibHkpLFxuICAgIHJlbW92ZU1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IocmVtb3ZlTWFueU11dGFibHkpXG4gIH07XG59XG5cbi8vIHNyYy9lbnRpdGllcy9zb3J0ZWRfc3RhdGVfYWRhcHRlci50c1xuZnVuY3Rpb24gZmluZEluc2VydEluZGV4KHNvcnRlZEl0ZW1zLCBpdGVtLCBjb21wYXJpc29uRnVuY3Rpb24pIHtcbiAgbGV0IGxvd0luZGV4ID0gMDtcbiAgbGV0IGhpZ2hJbmRleCA9IHNvcnRlZEl0ZW1zLmxlbmd0aDtcbiAgd2hpbGUgKGxvd0luZGV4IDwgaGlnaEluZGV4KSB7XG4gICAgbGV0IG1pZGRsZUluZGV4ID0gbG93SW5kZXggKyBoaWdoSW5kZXggPj4+IDE7XG4gICAgY29uc3QgY3VycmVudEl0ZW0gPSBzb3J0ZWRJdGVtc1ttaWRkbGVJbmRleF07XG4gICAgY29uc3QgcmVzID0gY29tcGFyaXNvbkZ1bmN0aW9uKGl0ZW0sIGN1cnJlbnRJdGVtKTtcbiAgICBpZiAocmVzID49IDApIHtcbiAgICAgIGxvd0luZGV4ID0gbWlkZGxlSW5kZXggKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBoaWdoSW5kZXggPSBtaWRkbGVJbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxvd0luZGV4O1xufVxuZnVuY3Rpb24gaW5zZXJ0KHNvcnRlZEl0ZW1zLCBpdGVtLCBjb21wYXJpc29uRnVuY3Rpb24pIHtcbiAgY29uc3QgaW5zZXJ0QXRJbmRleCA9IGZpbmRJbnNlcnRJbmRleChzb3J0ZWRJdGVtcywgaXRlbSwgY29tcGFyaXNvbkZ1bmN0aW9uKTtcbiAgc29ydGVkSXRlbXMuc3BsaWNlKGluc2VydEF0SW5kZXgsIDAsIGl0ZW0pO1xuICByZXR1cm4gc29ydGVkSXRlbXM7XG59XG5mdW5jdGlvbiBjcmVhdGVTb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQsIGNvbXBhcmVyKSB7XG4gIGNvbnN0IHtcbiAgICByZW1vdmVPbmUsXG4gICAgcmVtb3ZlTWFueSxcbiAgICByZW1vdmVBbGxcbiAgfSA9IGNyZWF0ZVVuc29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkKTtcbiAgZnVuY3Rpb24gYWRkT25lTXV0YWJseShlbnRpdHksIHN0YXRlKSB7XG4gICAgcmV0dXJuIGFkZE1hbnlNdXRhYmx5KFtlbnRpdHldLCBzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlLCBleGlzdGluZ0lkcykge1xuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gICAgY29uc3QgZXhpc3RpbmdLZXlzID0gbmV3IFNldChleGlzdGluZ0lkcyA/PyBnZXRDdXJyZW50KHN0YXRlLmlkcykpO1xuICAgIGNvbnN0IGFkZGVkS2V5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3QgbW9kZWxzID0gbmV3RW50aXRpZXMuZmlsdGVyKChtb2RlbCkgPT4ge1xuICAgICAgY29uc3QgbW9kZWxJZCA9IHNlbGVjdElkVmFsdWUobW9kZWwsIHNlbGVjdElkKTtcbiAgICAgIGNvbnN0IG5vdEFkZGVkID0gIWFkZGVkS2V5cy5oYXMobW9kZWxJZCk7XG4gICAgICBpZiAobm90QWRkZWQpIGFkZGVkS2V5cy5hZGQobW9kZWxJZCk7XG4gICAgICByZXR1cm4gIWV4aXN0aW5nS2V5cy5oYXMobW9kZWxJZCkgJiYgbm90QWRkZWQ7XG4gICAgfSk7XG4gICAgaWYgKG1vZGVscy5sZW5ndGggIT09IDApIHtcbiAgICAgIG1lcmdlRnVuY3Rpb24oc3RhdGUsIG1vZGVscyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNldE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xuICAgIHJldHVybiBzZXRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHNldE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIGxldCBkZWR1cGxpY2F0ZWRFbnRpdGllcyA9IHt9O1xuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gICAgaWYgKG5ld0VudGl0aWVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgZm9yIChjb25zdCBpdGVtIG9mIG5ld0VudGl0aWVzKSB7XG4gICAgICAgIGNvbnN0IGVudGl0eUlkID0gc2VsZWN0SWQoaXRlbSk7XG4gICAgICAgIGRlZHVwbGljYXRlZEVudGl0aWVzW2VudGl0eUlkXSA9IGl0ZW07XG4gICAgICAgIGRlbGV0ZSBzdGF0ZS5lbnRpdGllc1tlbnRpdHlJZF07XG4gICAgICB9XG4gICAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkoZGVkdXBsaWNhdGVkRW50aXRpZXMpO1xuICAgICAgbWVyZ2VGdW5jdGlvbihzdGF0ZSwgbmV3RW50aXRpZXMpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZXRBbGxNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gICAgc3RhdGUuZW50aXRpZXMgPSB7fTtcbiAgICBzdGF0ZS5pZHMgPSBbXTtcbiAgICBhZGRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUsIFtdKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVPbmVNdXRhYmx5KHVwZGF0ZSwgc3RhdGUpIHtcbiAgICByZXR1cm4gdXBkYXRlTWFueU11dGFibHkoW3VwZGF0ZV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVNYW55TXV0YWJseSh1cGRhdGVzLCBzdGF0ZSkge1xuICAgIGxldCBhcHBsaWVkVXBkYXRlcyA9IGZhbHNlO1xuICAgIGxldCByZXBsYWNlZElkcyA9IGZhbHNlO1xuICAgIGZvciAobGV0IHVwZGF0ZSBvZiB1cGRhdGVzKSB7XG4gICAgICBjb25zdCBlbnRpdHkgPSBzdGF0ZS5lbnRpdGllc1t1cGRhdGUuaWRdO1xuICAgICAgaWYgKCFlbnRpdHkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBhcHBsaWVkVXBkYXRlcyA9IHRydWU7XG4gICAgICBPYmplY3QuYXNzaWduKGVudGl0eSwgdXBkYXRlLmNoYW5nZXMpO1xuICAgICAgY29uc3QgbmV3SWQgPSBzZWxlY3RJZChlbnRpdHkpO1xuICAgICAgaWYgKHVwZGF0ZS5pZCAhPT0gbmV3SWQpIHtcbiAgICAgICAgcmVwbGFjZWRJZHMgPSB0cnVlO1xuICAgICAgICBkZWxldGUgc3RhdGUuZW50aXRpZXNbdXBkYXRlLmlkXTtcbiAgICAgICAgY29uc3Qgb2xkSW5kZXggPSBzdGF0ZS5pZHMuaW5kZXhPZih1cGRhdGUuaWQpO1xuICAgICAgICBzdGF0ZS5pZHNbb2xkSW5kZXhdID0gbmV3SWQ7XG4gICAgICAgIHN0YXRlLmVudGl0aWVzW25ld0lkXSA9IGVudGl0eTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFwcGxpZWRVcGRhdGVzKSB7XG4gICAgICBtZXJnZUZ1bmN0aW9uKHN0YXRlLCBbXSwgYXBwbGllZFVwZGF0ZXMsIHJlcGxhY2VkSWRzKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdXBzZXJ0T25lTXV0YWJseShlbnRpdHksIHN0YXRlKSB7XG4gICAgcmV0dXJuIHVwc2VydE1hbnlNdXRhYmx5KFtlbnRpdHldLCBzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBzZXJ0TWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XG4gICAgY29uc3QgW2FkZGVkLCB1cGRhdGVkLCBleGlzdGluZ0lkc0FycmF5XSA9IHNwbGl0QWRkZWRVcGRhdGVkRW50aXRpZXMobmV3RW50aXRpZXMsIHNlbGVjdElkLCBzdGF0ZSk7XG4gICAgaWYgKGFkZGVkLmxlbmd0aCkge1xuICAgICAgYWRkTWFueU11dGFibHkoYWRkZWQsIHN0YXRlLCBleGlzdGluZ0lkc0FycmF5KTtcbiAgICB9XG4gICAgaWYgKHVwZGF0ZWQubGVuZ3RoKSB7XG4gICAgICB1cGRhdGVNYW55TXV0YWJseSh1cGRhdGVkLCBzdGF0ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGFyZUFycmF5c0VxdWFsKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFbaV0gPT09IGJbaV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IG1lcmdlRnVuY3Rpb24gPSAoc3RhdGUsIGFkZGVkSXRlbXMsIGFwcGxpZWRVcGRhdGVzLCByZXBsYWNlZElkcykgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnRFbnRpdGllcyA9IGdldEN1cnJlbnQoc3RhdGUuZW50aXRpZXMpO1xuICAgIGNvbnN0IGN1cnJlbnRJZHMgPSBnZXRDdXJyZW50KHN0YXRlLmlkcyk7XG4gICAgY29uc3Qgc3RhdGVFbnRpdGllcyA9IHN0YXRlLmVudGl0aWVzO1xuICAgIGxldCBpZHMgPSBjdXJyZW50SWRzO1xuICAgIGlmIChyZXBsYWNlZElkcykge1xuICAgICAgaWRzID0gbmV3IFNldChjdXJyZW50SWRzKTtcbiAgICB9XG4gICAgbGV0IHNvcnRlZEVudGl0aWVzID0gW107XG4gICAgZm9yIChjb25zdCBpZCBvZiBpZHMpIHtcbiAgICAgIGNvbnN0IGVudGl0eSA9IGN1cnJlbnRFbnRpdGllc1tpZF07XG4gICAgICBpZiAoZW50aXR5KSB7XG4gICAgICAgIHNvcnRlZEVudGl0aWVzLnB1c2goZW50aXR5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgd2FzUHJldmlvdXNseUVtcHR5ID0gc29ydGVkRW50aXRpZXMubGVuZ3RoID09PSAwO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhZGRlZEl0ZW1zKSB7XG4gICAgICBzdGF0ZUVudGl0aWVzW3NlbGVjdElkKGl0ZW0pXSA9IGl0ZW07XG4gICAgICBpZiAoIXdhc1ByZXZpb3VzbHlFbXB0eSkge1xuICAgICAgICBpbnNlcnQoc29ydGVkRW50aXRpZXMsIGl0ZW0sIGNvbXBhcmVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHdhc1ByZXZpb3VzbHlFbXB0eSkge1xuICAgICAgc29ydGVkRW50aXRpZXMgPSBhZGRlZEl0ZW1zLnNsaWNlKCkuc29ydChjb21wYXJlcik7XG4gICAgfSBlbHNlIGlmIChhcHBsaWVkVXBkYXRlcykge1xuICAgICAgc29ydGVkRW50aXRpZXMuc29ydChjb21wYXJlcik7XG4gICAgfVxuICAgIGNvbnN0IG5ld1NvcnRlZElkcyA9IHNvcnRlZEVudGl0aWVzLm1hcChzZWxlY3RJZCk7XG4gICAgaWYgKCFhcmVBcnJheXNFcXVhbChjdXJyZW50SWRzLCBuZXdTb3J0ZWRJZHMpKSB7XG4gICAgICBzdGF0ZS5pZHMgPSBuZXdTb3J0ZWRJZHM7XG4gICAgfVxuICB9O1xuICByZXR1cm4ge1xuICAgIHJlbW92ZU9uZSxcbiAgICByZW1vdmVNYW55LFxuICAgIHJlbW92ZUFsbCxcbiAgICBhZGRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IoYWRkT25lTXV0YWJseSksXG4gICAgdXBkYXRlT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwZGF0ZU9uZU11dGFibHkpLFxuICAgIHVwc2VydE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cHNlcnRPbmVNdXRhYmx5KSxcbiAgICBzZXRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0T25lTXV0YWJseSksXG4gICAgc2V0TWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRNYW55TXV0YWJseSksXG4gICAgc2V0QWxsOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldEFsbE11dGFibHkpLFxuICAgIGFkZE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IoYWRkTWFueU11dGFibHkpLFxuICAgIHVwZGF0ZU1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlTWFueU11dGFibHkpLFxuICAgIHVwc2VydE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBzZXJ0TWFueU11dGFibHkpXG4gIH07XG59XG5cbi8vIHNyYy9lbnRpdGllcy9jcmVhdGVfYWRhcHRlci50c1xuZnVuY3Rpb24gY3JlYXRlRW50aXR5QWRhcHRlcihvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHNlbGVjdElkLFxuICAgIHNvcnRDb21wYXJlclxuICB9ID0ge1xuICAgIHNvcnRDb21wYXJlcjogZmFsc2UsXG4gICAgc2VsZWN0SWQ6IChpbnN0YW5jZSkgPT4gaW5zdGFuY2UuaWQsXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICBjb25zdCBzdGF0ZUFkYXB0ZXIgPSBzb3J0Q29tcGFyZXIgPyBjcmVhdGVTb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQsIHNvcnRDb21wYXJlcikgOiBjcmVhdGVVbnNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCk7XG4gIGNvbnN0IHN0YXRlRmFjdG9yeSA9IGNyZWF0ZUluaXRpYWxTdGF0ZUZhY3Rvcnkoc3RhdGVBZGFwdGVyKTtcbiAgY29uc3Qgc2VsZWN0b3JzRmFjdG9yeSA9IGNyZWF0ZVNlbGVjdG9yc0ZhY3RvcnkoKTtcbiAgcmV0dXJuIHtcbiAgICBzZWxlY3RJZCxcbiAgICBzb3J0Q29tcGFyZXIsXG4gICAgLi4uc3RhdGVGYWN0b3J5LFxuICAgIC4uLnNlbGVjdG9yc0ZhY3RvcnksXG4gICAgLi4uc3RhdGVBZGFwdGVyXG4gIH07XG59XG5cbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvaW5kZXgudHNcbmltcG9ydCB7IGlzQWN0aW9uIGFzIGlzQWN0aW9uMyB9IGZyb20gXCJyZWR1eFwiO1xuXG4vLyBzcmMvbGlzdGVuZXJNaWRkbGV3YXJlL2V4Y2VwdGlvbnMudHNcbnZhciB0YXNrID0gXCJ0YXNrXCI7XG52YXIgbGlzdGVuZXIgPSBcImxpc3RlbmVyXCI7XG52YXIgY29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcbnZhciBjYW5jZWxsZWQgPSBcImNhbmNlbGxlZFwiO1xudmFyIHRhc2tDYW5jZWxsZWQgPSBgdGFzay0ke2NhbmNlbGxlZH1gO1xudmFyIHRhc2tDb21wbGV0ZWQgPSBgdGFzay0ke2NvbXBsZXRlZH1gO1xudmFyIGxpc3RlbmVyQ2FuY2VsbGVkID0gYCR7bGlzdGVuZXJ9LSR7Y2FuY2VsbGVkfWA7XG52YXIgbGlzdGVuZXJDb21wbGV0ZWQgPSBgJHtsaXN0ZW5lcn0tJHtjb21wbGV0ZWR9YDtcbnZhciBUYXNrQWJvcnRFcnJvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY29kZSkge1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy5tZXNzYWdlID0gYCR7dGFza30gJHtjYW5jZWxsZWR9IChyZWFzb246ICR7Y29kZX0pYDtcbiAgfVxuICBuYW1lID0gXCJUYXNrQWJvcnRFcnJvclwiO1xuICBtZXNzYWdlO1xufTtcblxuLy8gc3JjL2xpc3RlbmVyTWlkZGxld2FyZS91dGlscy50c1xudmFyIGFzc2VydEZ1bmN0aW9uID0gKGZ1bmMsIGV4cGVjdGVkKSA9PiB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMyKSA6IGAke2V4cGVjdGVkfSBpcyBub3QgYSBmdW5jdGlvbmApO1xuICB9XG59O1xudmFyIG5vb3AyID0gKCkgPT4ge1xufTtcbnZhciBjYXRjaFJlamVjdGlvbiA9IChwcm9taXNlLCBvbkVycm9yID0gbm9vcDIpID0+IHtcbiAgcHJvbWlzZS5jYXRjaChvbkVycm9yKTtcbiAgcmV0dXJuIHByb21pc2U7XG59O1xudmFyIGFkZEFib3J0U2lnbmFsTGlzdGVuZXIgPSAoYWJvcnRTaWduYWwsIGNhbGxiYWNrKSA9PiB7XG4gIGFib3J0U2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBjYWxsYmFjaywge1xuICAgIG9uY2U6IHRydWVcbiAgfSk7XG4gIHJldHVybiAoKSA9PiBhYm9ydFNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgY2FsbGJhY2spO1xufTtcbnZhciBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uID0gKGFib3J0Q29udHJvbGxlciwgcmVhc29uKSA9PiB7XG4gIGNvbnN0IHNpZ25hbCA9IGFib3J0Q29udHJvbGxlci5zaWduYWw7XG4gIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIShcInJlYXNvblwiIGluIHNpZ25hbCkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2lnbmFsLCBcInJlYXNvblwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHJlYXNvbixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgO1xuICBhYm9ydENvbnRyb2xsZXIuYWJvcnQocmVhc29uKTtcbn07XG5cbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvdGFzay50c1xudmFyIHZhbGlkYXRlQWN0aXZlID0gKHNpZ25hbCkgPT4ge1xuICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICBjb25zdCB7XG4gICAgICByZWFzb25cbiAgICB9ID0gc2lnbmFsO1xuICAgIHRocm93IG5ldyBUYXNrQWJvcnRFcnJvcihyZWFzb24pO1xuICB9XG59O1xuZnVuY3Rpb24gcmFjZVdpdGhTaWduYWwoc2lnbmFsLCBwcm9taXNlKSB7XG4gIGxldCBjbGVhbnVwID0gbm9vcDI7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3Qgbm90aWZ5UmVqZWN0aW9uID0gKCkgPT4gcmVqZWN0KG5ldyBUYXNrQWJvcnRFcnJvcihzaWduYWwucmVhc29uKSk7XG4gICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICBub3RpZnlSZWplY3Rpb24oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2xlYW51cCA9IGFkZEFib3J0U2lnbmFsTGlzdGVuZXIoc2lnbmFsLCBub3RpZnlSZWplY3Rpb24pO1xuICAgIHByb21pc2UuZmluYWxseSgoKSA9PiBjbGVhbnVwKCkpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgY2xlYW51cCA9IG5vb3AyO1xuICB9KTtcbn1cbnZhciBydW5UYXNrID0gYXN5bmMgKHRhc2syLCBjbGVhblVwKSA9PiB7XG4gIHRyeSB7XG4gICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCB0YXNrMigpO1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXM6IFwib2tcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiBlcnJvciBpbnN0YW5jZW9mIFRhc2tBYm9ydEVycm9yID8gXCJjYW5jZWxsZWRcIiA6IFwicmVqZWN0ZWRcIixcbiAgICAgIGVycm9yXG4gICAgfTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjbGVhblVwPy4oKTtcbiAgfVxufTtcbnZhciBjcmVhdGVQYXVzZSA9IChzaWduYWwpID0+IHtcbiAgcmV0dXJuIChwcm9taXNlKSA9PiB7XG4gICAgcmV0dXJuIGNhdGNoUmVqZWN0aW9uKHJhY2VXaXRoU2lnbmFsKHNpZ25hbCwgcHJvbWlzZSkudGhlbigob3V0cHV0KSA9PiB7XG4gICAgICB2YWxpZGF0ZUFjdGl2ZShzaWduYWwpO1xuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9KSk7XG4gIH07XG59O1xudmFyIGNyZWF0ZURlbGF5ID0gKHNpZ25hbCkgPT4ge1xuICBjb25zdCBwYXVzZSA9IGNyZWF0ZVBhdXNlKHNpZ25hbCk7XG4gIHJldHVybiAodGltZW91dE1zKSA9PiB7XG4gICAgcmV0dXJuIHBhdXNlKG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWVvdXRNcykpKTtcbiAgfTtcbn07XG5cbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvaW5kZXgudHNcbnZhciB7XG4gIGFzc2lnblxufSA9IE9iamVjdDtcbnZhciBJTlRFUk5BTF9OSUxfVE9LRU4gPSB7fTtcbnZhciBhbG0gPSBcImxpc3RlbmVyTWlkZGxld2FyZVwiO1xudmFyIGNyZWF0ZUZvcmsgPSAocGFyZW50QWJvcnRTaWduYWwsIHBhcmVudEJsb2NraW5nUHJvbWlzZXMpID0+IHtcbiAgY29uc3QgbGlua0NvbnRyb2xsZXJzID0gKGNvbnRyb2xsZXIpID0+IGFkZEFib3J0U2lnbmFsTGlzdGVuZXIocGFyZW50QWJvcnRTaWduYWwsICgpID0+IGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oY29udHJvbGxlciwgcGFyZW50QWJvcnRTaWduYWwucmVhc29uKSk7XG4gIHJldHVybiAodGFza0V4ZWN1dG9yLCBvcHRzKSA9PiB7XG4gICAgYXNzZXJ0RnVuY3Rpb24odGFza0V4ZWN1dG9yLCBcInRhc2tFeGVjdXRvclwiKTtcbiAgICBjb25zdCBjaGlsZEFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBsaW5rQ29udHJvbGxlcnMoY2hpbGRBYm9ydENvbnRyb2xsZXIpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHJ1blRhc2soYXN5bmMgKCkgPT4ge1xuICAgICAgdmFsaWRhdGVBY3RpdmUocGFyZW50QWJvcnRTaWduYWwpO1xuICAgICAgdmFsaWRhdGVBY3RpdmUoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICAgIGNvbnN0IHJlc3VsdDIgPSBhd2FpdCB0YXNrRXhlY3V0b3Ioe1xuICAgICAgICBwYXVzZTogY3JlYXRlUGF1c2UoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKSxcbiAgICAgICAgZGVsYXk6IGNyZWF0ZURlbGF5KGNoaWxkQWJvcnRDb250cm9sbGVyLnNpZ25hbCksXG4gICAgICAgIHNpZ25hbDogY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIHZhbGlkYXRlQWN0aXZlKGNoaWxkQWJvcnRDb250cm9sbGVyLnNpZ25hbCk7XG4gICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICB9LCAoKSA9PiBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGNoaWxkQWJvcnRDb250cm9sbGVyLCB0YXNrQ29tcGxldGVkKSk7XG4gICAgaWYgKG9wdHM/LmF1dG9Kb2luKSB7XG4gICAgICBwYXJlbnRCbG9ja2luZ1Byb21pc2VzLnB1c2gocmVzdWx0LmNhdGNoKG5vb3AyKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByZXN1bHQ6IGNyZWF0ZVBhdXNlKHBhcmVudEFib3J0U2lnbmFsKShyZXN1bHQpLFxuICAgICAgY2FuY2VsKCkge1xuICAgICAgICBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGNoaWxkQWJvcnRDb250cm9sbGVyLCB0YXNrQ2FuY2VsbGVkKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufTtcbnZhciBjcmVhdGVUYWtlUGF0dGVybiA9IChzdGFydExpc3RlbmluZywgc2lnbmFsKSA9PiB7XG4gIGNvbnN0IHRha2UgPSBhc3luYyAocHJlZGljYXRlLCB0aW1lb3V0KSA9PiB7XG4gICAgdmFsaWRhdGVBY3RpdmUoc2lnbmFsKTtcbiAgICBsZXQgdW5zdWJzY3JpYmUgPSAoKSA9PiB7XG4gICAgfTtcbiAgICBjb25zdCB0dXBsZVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgc3RvcExpc3RlbmluZyA9IHN0YXJ0TGlzdGVuaW5nKHtcbiAgICAgICAgcHJlZGljYXRlLFxuICAgICAgICBlZmZlY3Q6IChhY3Rpb24sIGxpc3RlbmVyQXBpKSA9PiB7XG4gICAgICAgICAgbGlzdGVuZXJBcGkudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICByZXNvbHZlKFthY3Rpb24sIGxpc3RlbmVyQXBpLmdldFN0YXRlKCksIGxpc3RlbmVyQXBpLmdldE9yaWdpbmFsU3RhdGUoKV0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHVuc3Vic2NyaWJlID0gKCkgPT4ge1xuICAgICAgICBzdG9wTGlzdGVuaW5nKCk7XG4gICAgICAgIHJlamVjdCgpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBwcm9taXNlcyA9IFt0dXBsZVByb21pc2VdO1xuICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgIHByb21pc2VzLnB1c2gobmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dCwgbnVsbCkpKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IHJhY2VXaXRoU2lnbmFsKHNpZ25hbCwgUHJvbWlzZS5yYWNlKHByb21pc2VzKSk7XG4gICAgICB2YWxpZGF0ZUFjdGl2ZShzaWduYWwpO1xuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiAocHJlZGljYXRlLCB0aW1lb3V0KSA9PiBjYXRjaFJlamVjdGlvbih0YWtlKHByZWRpY2F0ZSwgdGltZW91dCkpO1xufTtcbnZhciBnZXRMaXN0ZW5lckVudHJ5UHJvcHNGcm9tID0gKG9wdGlvbnMpID0+IHtcbiAgbGV0IHtcbiAgICB0eXBlLFxuICAgIGFjdGlvbkNyZWF0b3IsXG4gICAgbWF0Y2hlcixcbiAgICBwcmVkaWNhdGUsXG4gICAgZWZmZWN0XG4gIH0gPSBvcHRpb25zO1xuICBpZiAodHlwZSkge1xuICAgIHByZWRpY2F0ZSA9IGNyZWF0ZUFjdGlvbih0eXBlKS5tYXRjaDtcbiAgfSBlbHNlIGlmIChhY3Rpb25DcmVhdG9yKSB7XG4gICAgdHlwZSA9IGFjdGlvbkNyZWF0b3IudHlwZTtcbiAgICBwcmVkaWNhdGUgPSBhY3Rpb25DcmVhdG9yLm1hdGNoO1xuICB9IGVsc2UgaWYgKG1hdGNoZXIpIHtcbiAgICBwcmVkaWNhdGUgPSBtYXRjaGVyO1xuICB9IGVsc2UgaWYgKHByZWRpY2F0ZSkge1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDIxKSA6IFwiQ3JlYXRpbmcgb3IgcmVtb3ZpbmcgYSBsaXN0ZW5lciByZXF1aXJlcyBvbmUgb2YgdGhlIGtub3duIGZpZWxkcyBmb3IgbWF0Y2hpbmcgYW4gYWN0aW9uXCIpO1xuICB9XG4gIGFzc2VydEZ1bmN0aW9uKGVmZmVjdCwgXCJvcHRpb25zLmxpc3RlbmVyXCIpO1xuICByZXR1cm4ge1xuICAgIHByZWRpY2F0ZSxcbiAgICB0eXBlLFxuICAgIGVmZmVjdFxuICB9O1xufTtcbnZhciBjcmVhdGVMaXN0ZW5lckVudHJ5ID0gLyogQF9fUFVSRV9fICovIGFzc2lnbigob3B0aW9ucykgPT4ge1xuICBjb25zdCB7XG4gICAgdHlwZSxcbiAgICBwcmVkaWNhdGUsXG4gICAgZWZmZWN0XG4gIH0gPSBnZXRMaXN0ZW5lckVudHJ5UHJvcHNGcm9tKG9wdGlvbnMpO1xuICBjb25zdCBlbnRyeSA9IHtcbiAgICBpZDogbmFub2lkKCksXG4gICAgZWZmZWN0LFxuICAgIHR5cGUsXG4gICAgcHJlZGljYXRlLFxuICAgIHBlbmRpbmc6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgdW5zdWJzY3JpYmU6ICgpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDIyKSA6IFwiVW5zdWJzY3JpYmUgbm90IGluaXRpYWxpemVkXCIpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGVudHJ5O1xufSwge1xuICB3aXRoVHlwZXM6ICgpID0+IGNyZWF0ZUxpc3RlbmVyRW50cnlcbn0pO1xudmFyIGZpbmRMaXN0ZW5lckVudHJ5ID0gKGxpc3RlbmVyTWFwLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHtcbiAgICB0eXBlLFxuICAgIGVmZmVjdCxcbiAgICBwcmVkaWNhdGVcbiAgfSA9IGdldExpc3RlbmVyRW50cnlQcm9wc0Zyb20ob3B0aW9ucyk7XG4gIHJldHVybiBBcnJheS5mcm9tKGxpc3RlbmVyTWFwLnZhbHVlcygpKS5maW5kKChlbnRyeSkgPT4ge1xuICAgIGNvbnN0IG1hdGNoUHJlZGljYXRlT3JUeXBlID0gdHlwZW9mIHR5cGUgPT09IFwic3RyaW5nXCIgPyBlbnRyeS50eXBlID09PSB0eXBlIDogZW50cnkucHJlZGljYXRlID09PSBwcmVkaWNhdGU7XG4gICAgcmV0dXJuIG1hdGNoUHJlZGljYXRlT3JUeXBlICYmIGVudHJ5LmVmZmVjdCA9PT0gZWZmZWN0O1xuICB9KTtcbn07XG52YXIgY2FuY2VsQWN0aXZlTGlzdGVuZXJzID0gKGVudHJ5KSA9PiB7XG4gIGVudHJ5LnBlbmRpbmcuZm9yRWFjaCgoY29udHJvbGxlcikgPT4ge1xuICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oY29udHJvbGxlciwgbGlzdGVuZXJDYW5jZWxsZWQpO1xuICB9KTtcbn07XG52YXIgY3JlYXRlQ2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUgPSAobGlzdGVuZXJNYXAsIGV4ZWN1dGluZ0xpc3RlbmVycykgPT4ge1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGZvciAoY29uc3QgbGlzdGVuZXIyIG9mIGV4ZWN1dGluZ0xpc3RlbmVycy5rZXlzKCkpIHtcbiAgICAgIGNhbmNlbEFjdGl2ZUxpc3RlbmVycyhsaXN0ZW5lcjIpO1xuICAgIH1cbiAgICBsaXN0ZW5lck1hcC5jbGVhcigpO1xuICB9O1xufTtcbnZhciBzYWZlbHlOb3RpZnlFcnJvciA9IChlcnJvckhhbmRsZXIsIGVycm9yVG9Ob3RpZnksIGVycm9ySW5mbykgPT4ge1xuICB0cnkge1xuICAgIGVycm9ySGFuZGxlcihlcnJvclRvTm90aWZ5LCBlcnJvckluZm8pO1xuICB9IGNhdGNoIChlcnJvckhhbmRsZXJFcnJvcikge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhyb3cgZXJyb3JIYW5kbGVyRXJyb3I7XG4gICAgfSwgMCk7XG4gIH1cbn07XG52YXIgYWRkTGlzdGVuZXIgPSAvKiBAX19QVVJFX18gKi8gYXNzaWduKC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVBY3Rpb24oYCR7YWxtfS9hZGRgKSwge1xuICB3aXRoVHlwZXM6ICgpID0+IGFkZExpc3RlbmVyXG59KTtcbnZhciBjbGVhckFsbExpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVBY3Rpb24oYCR7YWxtfS9yZW1vdmVBbGxgKTtcbnZhciByZW1vdmVMaXN0ZW5lciA9IC8qIEBfX1BVUkVfXyAqLyBhc3NpZ24oLyogQF9fUFVSRV9fICovIGNyZWF0ZUFjdGlvbihgJHthbG19L3JlbW92ZWApLCB7XG4gIHdpdGhUeXBlczogKCkgPT4gcmVtb3ZlTGlzdGVuZXJcbn0pO1xudmFyIGRlZmF1bHRFcnJvckhhbmRsZXIgPSAoLi4uYXJncykgPT4ge1xuICBjb25zb2xlLmVycm9yKGAke2FsbX0vZXJyb3JgLCAuLi5hcmdzKTtcbn07XG52YXIgY3JlYXRlTGlzdGVuZXJNaWRkbGV3YXJlID0gKG1pZGRsZXdhcmVPcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgbGlzdGVuZXJNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBleGVjdXRpbmdMaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCB0cmFja0V4ZWN1dGluZ0xpc3RlbmVyID0gKGVudHJ5KSA9PiB7XG4gICAgY29uc3QgY291bnQgPSBleGVjdXRpbmdMaXN0ZW5lcnMuZ2V0KGVudHJ5KSA/PyAwO1xuICAgIGV4ZWN1dGluZ0xpc3RlbmVycy5zZXQoZW50cnksIGNvdW50ICsgMSk7XG4gIH07XG4gIGNvbnN0IHVudHJhY2tFeGVjdXRpbmdMaXN0ZW5lciA9IChlbnRyeSkgPT4ge1xuICAgIGNvbnN0IGNvdW50ID0gZXhlY3V0aW5nTGlzdGVuZXJzLmdldChlbnRyeSkgPz8gMTtcbiAgICBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgIGV4ZWN1dGluZ0xpc3RlbmVycy5kZWxldGUoZW50cnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGVjdXRpbmdMaXN0ZW5lcnMuc2V0KGVudHJ5LCBjb3VudCAtIDEpO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qge1xuICAgIGV4dHJhLFxuICAgIG9uRXJyb3IgPSBkZWZhdWx0RXJyb3JIYW5kbGVyXG4gIH0gPSBtaWRkbGV3YXJlT3B0aW9ucztcbiAgYXNzZXJ0RnVuY3Rpb24ob25FcnJvciwgXCJvbkVycm9yXCIpO1xuICBjb25zdCBpbnNlcnRFbnRyeSA9IChlbnRyeSkgPT4ge1xuICAgIGVudHJ5LnVuc3Vic2NyaWJlID0gKCkgPT4gbGlzdGVuZXJNYXAuZGVsZXRlKGVudHJ5LmlkKTtcbiAgICBsaXN0ZW5lck1hcC5zZXQoZW50cnkuaWQsIGVudHJ5KTtcbiAgICByZXR1cm4gKGNhbmNlbE9wdGlvbnMpID0+IHtcbiAgICAgIGVudHJ5LnVuc3Vic2NyaWJlKCk7XG4gICAgICBpZiAoY2FuY2VsT3B0aW9ucz8uY2FuY2VsQWN0aXZlKSB7XG4gICAgICAgIGNhbmNlbEFjdGl2ZUxpc3RlbmVycyhlbnRyeSk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgY29uc3Qgc3RhcnRMaXN0ZW5pbmcgPSAob3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IGVudHJ5ID0gZmluZExpc3RlbmVyRW50cnkobGlzdGVuZXJNYXAsIG9wdGlvbnMpID8/IGNyZWF0ZUxpc3RlbmVyRW50cnkob3B0aW9ucyk7XG4gICAgcmV0dXJuIGluc2VydEVudHJ5KGVudHJ5KTtcbiAgfTtcbiAgYXNzaWduKHN0YXJ0TGlzdGVuaW5nLCB7XG4gICAgd2l0aFR5cGVzOiAoKSA9PiBzdGFydExpc3RlbmluZ1xuICB9KTtcbiAgY29uc3Qgc3RvcExpc3RlbmluZyA9IChvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgZW50cnkgPSBmaW5kTGlzdGVuZXJFbnRyeShsaXN0ZW5lck1hcCwgb3B0aW9ucyk7XG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICBlbnRyeS51bnN1YnNjcmliZSgpO1xuICAgICAgaWYgKG9wdGlvbnMuY2FuY2VsQWN0aXZlKSB7XG4gICAgICAgIGNhbmNlbEFjdGl2ZUxpc3RlbmVycyhlbnRyeSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAhIWVudHJ5O1xuICB9O1xuICBhc3NpZ24oc3RvcExpc3RlbmluZywge1xuICAgIHdpdGhUeXBlczogKCkgPT4gc3RvcExpc3RlbmluZ1xuICB9KTtcbiAgY29uc3Qgbm90aWZ5TGlzdGVuZXIgPSBhc3luYyAoZW50cnksIGFjdGlvbiwgYXBpLCBnZXRPcmlnaW5hbFN0YXRlKSA9PiB7XG4gICAgY29uc3QgaW50ZXJuYWxUYXNrQ29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCB0YWtlID0gY3JlYXRlVGFrZVBhdHRlcm4oc3RhcnRMaXN0ZW5pbmcsIGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICBjb25zdCBhdXRvSm9pblByb21pc2VzID0gW107XG4gICAgdHJ5IHtcbiAgICAgIGVudHJ5LnBlbmRpbmcuYWRkKGludGVybmFsVGFza0NvbnRyb2xsZXIpO1xuICAgICAgdHJhY2tFeGVjdXRpbmdMaXN0ZW5lcihlbnRyeSk7XG4gICAgICBhd2FpdCBQcm9taXNlLnJlc29sdmUoZW50cnkuZWZmZWN0KFxuICAgICAgICBhY3Rpb24sXG4gICAgICAgIC8vIFVzZSBhc3NpZ24oKSByYXRoZXIgdGhhbiAuLi4gdG8gYXZvaWQgZXh0cmEgaGVscGVyIGZ1bmN0aW9ucyBhZGRlZCB0byBidW5kbGVcbiAgICAgICAgYXNzaWduKHt9LCBhcGksIHtcbiAgICAgICAgICBnZXRPcmlnaW5hbFN0YXRlLFxuICAgICAgICAgIGNvbmRpdGlvbjogKHByZWRpY2F0ZSwgdGltZW91dCkgPT4gdGFrZShwcmVkaWNhdGUsIHRpbWVvdXQpLnRoZW4oQm9vbGVhbiksXG4gICAgICAgICAgdGFrZSxcbiAgICAgICAgICBkZWxheTogY3JlYXRlRGVsYXkoaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwpLFxuICAgICAgICAgIHBhdXNlOiBjcmVhdGVQYXVzZShpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCksXG4gICAgICAgICAgZXh0cmEsXG4gICAgICAgICAgc2lnbmFsOiBpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgICBmb3JrOiBjcmVhdGVGb3JrKGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsLCBhdXRvSm9pblByb21pc2VzKSxcbiAgICAgICAgICB1bnN1YnNjcmliZTogZW50cnkudW5zdWJzY3JpYmUsXG4gICAgICAgICAgc3Vic2NyaWJlOiAoKSA9PiB7XG4gICAgICAgICAgICBsaXN0ZW5lck1hcC5zZXQoZW50cnkuaWQsIGVudHJ5KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNhbmNlbEFjdGl2ZUxpc3RlbmVyczogKCkgPT4ge1xuICAgICAgICAgICAgZW50cnkucGVuZGluZy5mb3JFYWNoKChjb250cm9sbGVyLCBfLCBzZXQpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIgIT09IGludGVybmFsVGFza0NvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGNvbnRyb2xsZXIsIGxpc3RlbmVyQ2FuY2VsbGVkKTtcbiAgICAgICAgICAgICAgICBzZXQuZGVsZXRlKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNhbmNlbDogKCkgPT4ge1xuICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihpbnRlcm5hbFRhc2tDb250cm9sbGVyLCBsaXN0ZW5lckNhbmNlbGxlZCk7XG4gICAgICAgICAgICBlbnRyeS5wZW5kaW5nLmRlbGV0ZShpbnRlcm5hbFRhc2tDb250cm9sbGVyKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQ6ICgpID0+IHtcbiAgICAgICAgICAgIHZhbGlkYXRlQWN0aXZlKGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApKTtcbiAgICB9IGNhdGNoIChsaXN0ZW5lckVycm9yKSB7XG4gICAgICBpZiAoIShsaXN0ZW5lckVycm9yIGluc3RhbmNlb2YgVGFza0Fib3J0RXJyb3IpKSB7XG4gICAgICAgIHNhZmVseU5vdGlmeUVycm9yKG9uRXJyb3IsIGxpc3RlbmVyRXJyb3IsIHtcbiAgICAgICAgICByYWlzZWRCeTogXCJlZmZlY3RcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoYXV0b0pvaW5Qcm9taXNlcyk7XG4gICAgICBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGludGVybmFsVGFza0NvbnRyb2xsZXIsIGxpc3RlbmVyQ29tcGxldGVkKTtcbiAgICAgIHVudHJhY2tFeGVjdXRpbmdMaXN0ZW5lcihlbnRyeSk7XG4gICAgICBlbnRyeS5wZW5kaW5nLmRlbGV0ZShpbnRlcm5hbFRhc2tDb250cm9sbGVyKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlID0gY3JlYXRlQ2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUobGlzdGVuZXJNYXAsIGV4ZWN1dGluZ0xpc3RlbmVycyk7XG4gIGNvbnN0IG1pZGRsZXdhcmUgPSAoYXBpKSA9PiAobmV4dCkgPT4gKGFjdGlvbikgPT4ge1xuICAgIGlmICghaXNBY3Rpb24zKGFjdGlvbikpIHtcbiAgICAgIHJldHVybiBuZXh0KGFjdGlvbik7XG4gICAgfVxuICAgIGlmIChhZGRMaXN0ZW5lci5tYXRjaChhY3Rpb24pKSB7XG4gICAgICByZXR1cm4gc3RhcnRMaXN0ZW5pbmcoYWN0aW9uLnBheWxvYWQpO1xuICAgIH1cbiAgICBpZiAoY2xlYXJBbGxMaXN0ZW5lcnMubWF0Y2goYWN0aW9uKSkge1xuICAgICAgY2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJlbW92ZUxpc3RlbmVyLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIHJldHVybiBzdG9wTGlzdGVuaW5nKGFjdGlvbi5wYXlsb2FkKTtcbiAgICB9XG4gICAgbGV0IG9yaWdpbmFsU3RhdGUgPSBhcGkuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBnZXRPcmlnaW5hbFN0YXRlID0gKCkgPT4ge1xuICAgICAgaWYgKG9yaWdpbmFsU3RhdGUgPT09IElOVEVSTkFMX05JTF9UT0tFTikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyMykgOiBgJHthbG19OiBnZXRPcmlnaW5hbFN0YXRlIGNhbiBvbmx5IGJlIGNhbGxlZCBzeW5jaHJvbm91c2x5YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ2luYWxTdGF0ZTtcbiAgICB9O1xuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IG5leHQoYWN0aW9uKTtcbiAgICAgIGlmIChsaXN0ZW5lck1hcC5zaXplID4gMCkge1xuICAgICAgICBjb25zdCBjdXJyZW50U3RhdGUgPSBhcGkuZ2V0U3RhdGUoKTtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJFbnRyaWVzID0gQXJyYXkuZnJvbShsaXN0ZW5lck1hcC52YWx1ZXMoKSk7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgbGlzdGVuZXJFbnRyaWVzKSB7XG4gICAgICAgICAgbGV0IHJ1bkxpc3RlbmVyID0gZmFsc2U7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJ1bkxpc3RlbmVyID0gZW50cnkucHJlZGljYXRlKGFjdGlvbiwgY3VycmVudFN0YXRlLCBvcmlnaW5hbFN0YXRlKTtcbiAgICAgICAgICB9IGNhdGNoIChwcmVkaWNhdGVFcnJvcikge1xuICAgICAgICAgICAgcnVuTGlzdGVuZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIHNhZmVseU5vdGlmeUVycm9yKG9uRXJyb3IsIHByZWRpY2F0ZUVycm9yLCB7XG4gICAgICAgICAgICAgIHJhaXNlZEJ5OiBcInByZWRpY2F0ZVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFydW5MaXN0ZW5lcikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vdGlmeUxpc3RlbmVyKGVudHJ5LCBhY3Rpb24sIGFwaSwgZ2V0T3JpZ2luYWxTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgb3JpZ2luYWxTdGF0ZSA9IElOVEVSTkFMX05JTF9UT0tFTjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBtaWRkbGV3YXJlLFxuICAgIHN0YXJ0TGlzdGVuaW5nLFxuICAgIHN0b3BMaXN0ZW5pbmcsXG4gICAgY2xlYXJMaXN0ZW5lcnM6IGNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlXG4gIH07XG59O1xuXG4vLyBzcmMvZHluYW1pY01pZGRsZXdhcmUvaW5kZXgudHNcbmltcG9ydCB7IGNvbXBvc2UgYXMgY29tcG9zZTMgfSBmcm9tIFwicmVkdXhcIjtcbnZhciBjcmVhdGVNaWRkbGV3YXJlRW50cnkgPSAobWlkZGxld2FyZSkgPT4gKHtcbiAgbWlkZGxld2FyZSxcbiAgYXBwbGllZDogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKVxufSk7XG52YXIgbWF0Y2hJbnN0YW5jZSA9IChpbnN0YW5jZUlkKSA9PiAoYWN0aW9uKSA9PiBhY3Rpb24/Lm1ldGE/Lmluc3RhbmNlSWQgPT09IGluc3RhbmNlSWQ7XG52YXIgY3JlYXRlRHluYW1pY01pZGRsZXdhcmUgPSAoKSA9PiB7XG4gIGNvbnN0IGluc3RhbmNlSWQgPSBuYW5vaWQoKTtcbiAgY29uc3QgbWlkZGxld2FyZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHdpdGhNaWRkbGV3YXJlID0gT2JqZWN0LmFzc2lnbihjcmVhdGVBY3Rpb24oXCJkeW5hbWljTWlkZGxld2FyZS9hZGRcIiwgKC4uLm1pZGRsZXdhcmVzKSA9PiAoe1xuICAgIHBheWxvYWQ6IG1pZGRsZXdhcmVzLFxuICAgIG1ldGE6IHtcbiAgICAgIGluc3RhbmNlSWRcbiAgICB9XG4gIH0pKSwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gd2l0aE1pZGRsZXdhcmVcbiAgfSk7XG4gIGNvbnN0IGFkZE1pZGRsZXdhcmUgPSBPYmplY3QuYXNzaWduKGZ1bmN0aW9uIGFkZE1pZGRsZXdhcmUyKC4uLm1pZGRsZXdhcmVzKSB7XG4gICAgbWlkZGxld2FyZXMuZm9yRWFjaCgobWlkZGxld2FyZTIpID0+IHtcbiAgICAgIGdldE9ySW5zZXJ0Q29tcHV0ZWQobWlkZGxld2FyZU1hcCwgbWlkZGxld2FyZTIsIGNyZWF0ZU1pZGRsZXdhcmVFbnRyeSk7XG4gICAgfSk7XG4gIH0sIHtcbiAgICB3aXRoVHlwZXM6ICgpID0+IGFkZE1pZGRsZXdhcmVcbiAgfSk7XG4gIGNvbnN0IGdldEZpbmFsTWlkZGxld2FyZSA9IChhcGkpID0+IHtcbiAgICBjb25zdCBhcHBsaWVkTWlkZGxld2FyZSA9IEFycmF5LmZyb20obWlkZGxld2FyZU1hcC52YWx1ZXMoKSkubWFwKChlbnRyeSkgPT4gZ2V0T3JJbnNlcnRDb21wdXRlZChlbnRyeS5hcHBsaWVkLCBhcGksIGVudHJ5Lm1pZGRsZXdhcmUpKTtcbiAgICByZXR1cm4gY29tcG9zZTMoLi4uYXBwbGllZE1pZGRsZXdhcmUpO1xuICB9O1xuICBjb25zdCBpc1dpdGhNaWRkbGV3YXJlID0gaXNBbGxPZih3aXRoTWlkZGxld2FyZSwgbWF0Y2hJbnN0YW5jZShpbnN0YW5jZUlkKSk7XG4gIGNvbnN0IG1pZGRsZXdhcmUgPSAoYXBpKSA9PiAobmV4dCkgPT4gKGFjdGlvbikgPT4ge1xuICAgIGlmIChpc1dpdGhNaWRkbGV3YXJlKGFjdGlvbikpIHtcbiAgICAgIGFkZE1pZGRsZXdhcmUoLi4uYWN0aW9uLnBheWxvYWQpO1xuICAgICAgcmV0dXJuIGFwaS5kaXNwYXRjaDtcbiAgICB9XG4gICAgcmV0dXJuIGdldEZpbmFsTWlkZGxld2FyZShhcGkpKG5leHQpKGFjdGlvbik7XG4gIH07XG4gIHJldHVybiB7XG4gICAgbWlkZGxld2FyZSxcbiAgICBhZGRNaWRkbGV3YXJlLFxuICAgIHdpdGhNaWRkbGV3YXJlLFxuICAgIGluc3RhbmNlSWRcbiAgfTtcbn07XG5cbi8vIHNyYy9jb21iaW5lU2xpY2VzLnRzXG5pbXBvcnQgeyBjb21iaW5lUmVkdWNlcnMgYXMgY29tYmluZVJlZHVjZXJzMiB9IGZyb20gXCJyZWR1eFwiO1xudmFyIGlzU2xpY2VMaWtlID0gKG1heWJlU2xpY2VMaWtlKSA9PiBcInJlZHVjZXJQYXRoXCIgaW4gbWF5YmVTbGljZUxpa2UgJiYgdHlwZW9mIG1heWJlU2xpY2VMaWtlLnJlZHVjZXJQYXRoID09PSBcInN0cmluZ1wiO1xudmFyIGdldFJlZHVjZXJzID0gKHNsaWNlcykgPT4gc2xpY2VzLmZsYXRNYXAoKHNsaWNlT3JNYXApID0+IGlzU2xpY2VMaWtlKHNsaWNlT3JNYXApID8gW1tzbGljZU9yTWFwLnJlZHVjZXJQYXRoLCBzbGljZU9yTWFwLnJlZHVjZXJdXSA6IE9iamVjdC5lbnRyaWVzKHNsaWNlT3JNYXApKTtcbnZhciBPUklHSU5BTF9TVEFURSA9IFN5bWJvbC5mb3IoXCJydGstc3RhdGUtcHJveHktb3JpZ2luYWxcIik7XG52YXIgaXNTdGF0ZVByb3h5ID0gKHZhbHVlKSA9PiAhIXZhbHVlICYmICEhdmFsdWVbT1JJR0lOQUxfU1RBVEVdO1xudmFyIHN0YXRlUHJveHlNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbnZhciBjcmVhdGVTdGF0ZVByb3h5ID0gKHN0YXRlLCByZWR1Y2VyTWFwLCBpbml0aWFsU3RhdGVDYWNoZSkgPT4gZ2V0T3JJbnNlcnRDb21wdXRlZChzdGF0ZVByb3h5TWFwLCBzdGF0ZSwgKCkgPT4gbmV3IFByb3h5KHN0YXRlLCB7XG4gIGdldDogKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpID0+IHtcbiAgICBpZiAocHJvcCA9PT0gT1JJR0lOQUxfU1RBVEUpIHJldHVybiB0YXJnZXQ7XG4gICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNvbnN0IGNhY2hlZCA9IGluaXRpYWxTdGF0ZUNhY2hlW3Byb3BdO1xuICAgICAgaWYgKHR5cGVvZiBjYWNoZWQgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBjYWNoZWQ7XG4gICAgICBjb25zdCByZWR1Y2VyID0gcmVkdWNlck1hcFtwcm9wXTtcbiAgICAgIGlmIChyZWR1Y2VyKSB7XG4gICAgICAgIGNvbnN0IHJlZHVjZXJSZXN1bHQgPSByZWR1Y2VyKHZvaWQgMCwge1xuICAgICAgICAgIHR5cGU6IG5hbm9pZCgpXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIHJlZHVjZXJSZXN1bHQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyNCkgOiBgVGhlIHNsaWNlIHJlZHVjZXIgZm9yIGtleSBcIiR7cHJvcC50b1N0cmluZygpfVwiIHJldHVybmVkIHVuZGVmaW5lZCB3aGVuIGNhbGxlZCBmb3Igc2VsZWN0b3IoKS4gSWYgdGhlIHN0YXRlIHBhc3NlZCB0byB0aGUgcmVkdWNlciBpcyB1bmRlZmluZWQsIHlvdSBtdXN0IGV4cGxpY2l0bHkgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgbm90IGJlIHVuZGVmaW5lZC4gSWYgeW91IGRvbid0IHdhbnQgdG8gc2V0IGEgdmFsdWUgZm9yIHRoaXMgcmVkdWNlciwgeW91IGNhbiB1c2UgbnVsbCBpbnN0ZWFkIG9mIHVuZGVmaW5lZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBpbml0aWFsU3RhdGVDYWNoZVtwcm9wXSA9IHJlZHVjZXJSZXN1bHQ7XG4gICAgICAgIHJldHVybiByZWR1Y2VyUmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KSk7XG52YXIgb3JpZ2luYWwgPSAoc3RhdGUpID0+IHtcbiAgaWYgKCFpc1N0YXRlUHJveHkoc3RhdGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjUpIDogXCJvcmlnaW5hbCBtdXN0IGJlIHVzZWQgb24gc3RhdGUgUHJveHlcIik7XG4gIH1cbiAgcmV0dXJuIHN0YXRlW09SSUdJTkFMX1NUQVRFXTtcbn07XG52YXIgZW1wdHlPYmplY3QgPSB7fTtcbnZhciBub29wUmVkdWNlciA9IChzdGF0ZSA9IGVtcHR5T2JqZWN0KSA9PiBzdGF0ZTtcbmZ1bmN0aW9uIGNvbWJpbmVTbGljZXMoLi4uc2xpY2VzKSB7XG4gIGNvbnN0IHJlZHVjZXJNYXAgPSBPYmplY3QuZnJvbUVudHJpZXMoZ2V0UmVkdWNlcnMoc2xpY2VzKSk7XG4gIGNvbnN0IGdldFJlZHVjZXIgPSAoKSA9PiBPYmplY3Qua2V5cyhyZWR1Y2VyTWFwKS5sZW5ndGggPyBjb21iaW5lUmVkdWNlcnMyKHJlZHVjZXJNYXApIDogbm9vcFJlZHVjZXI7XG4gIGxldCByZWR1Y2VyID0gZ2V0UmVkdWNlcigpO1xuICBmdW5jdGlvbiBjb21iaW5lZFJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAgIHJldHVybiByZWR1Y2VyKHN0YXRlLCBhY3Rpb24pO1xuICB9XG4gIGNvbWJpbmVkUmVkdWNlci53aXRoTGF6eUxvYWRlZFNsaWNlcyA9ICgpID0+IGNvbWJpbmVkUmVkdWNlcjtcbiAgY29uc3QgaW5pdGlhbFN0YXRlQ2FjaGUgPSB7fTtcbiAgY29uc3QgaW5qZWN0ID0gKHNsaWNlLCBjb25maWcgPSB7fSkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlZHVjZXJQYXRoLFxuICAgICAgcmVkdWNlcjogcmVkdWNlclRvSW5qZWN0XG4gICAgfSA9IHNsaWNlO1xuICAgIGNvbnN0IGN1cnJlbnRSZWR1Y2VyID0gcmVkdWNlck1hcFtyZWR1Y2VyUGF0aF07XG4gICAgaWYgKCFjb25maWcub3ZlcnJpZGVFeGlzdGluZyAmJiBjdXJyZW50UmVkdWNlciAmJiBjdXJyZW50UmVkdWNlciAhPT0gcmVkdWNlclRvSW5qZWN0KSB7XG4gICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBjYWxsZWQgXFxgaW5qZWN0XFxgIHRvIG92ZXJyaWRlIGFscmVhZHktZXhpc3RpbmcgcmVkdWNlciAke3JlZHVjZXJQYXRofSB3aXRob3V0IHNwZWNpZnlpbmcgXFxgb3ZlcnJpZGVFeGlzdGluZzogdHJ1ZVxcYGApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbWJpbmVkUmVkdWNlcjtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5vdmVycmlkZUV4aXN0aW5nICYmIGN1cnJlbnRSZWR1Y2VyICE9PSByZWR1Y2VyVG9JbmplY3QpIHtcbiAgICAgIGRlbGV0ZSBpbml0aWFsU3RhdGVDYWNoZVtyZWR1Y2VyUGF0aF07XG4gICAgfVxuICAgIHJlZHVjZXJNYXBbcmVkdWNlclBhdGhdID0gcmVkdWNlclRvSW5qZWN0O1xuICAgIHJlZHVjZXIgPSBnZXRSZWR1Y2VyKCk7XG4gICAgcmV0dXJuIGNvbWJpbmVkUmVkdWNlcjtcbiAgfTtcbiAgY29uc3Qgc2VsZWN0b3IgPSBPYmplY3QuYXNzaWduKGZ1bmN0aW9uIG1ha2VTZWxlY3RvcihzZWxlY3RvckZuLCBzZWxlY3RTdGF0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBzZWxlY3RvcjIoc3RhdGUsIC4uLmFyZ3MpIHtcbiAgICAgIHJldHVybiBzZWxlY3RvckZuKGNyZWF0ZVN0YXRlUHJveHkoc2VsZWN0U3RhdGUgPyBzZWxlY3RTdGF0ZShzdGF0ZSwgLi4uYXJncykgOiBzdGF0ZSwgcmVkdWNlck1hcCwgaW5pdGlhbFN0YXRlQ2FjaGUpLCAuLi5hcmdzKTtcbiAgICB9O1xuICB9LCB7XG4gICAgb3JpZ2luYWxcbiAgfSk7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKGNvbWJpbmVkUmVkdWNlciwge1xuICAgIGluamVjdCxcbiAgICBzZWxlY3RvclxuICB9KTtcbn1cblxuLy8gc3JjL2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UudHNcbmZ1bmN0aW9uIGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoY29kZSkge1xuICByZXR1cm4gYE1pbmlmaWVkIFJlZHV4IFRvb2xraXQgZXJyb3IgIyR7Y29kZX07IHZpc2l0IGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvRXJyb3JzP2NvZGU9JHtjb2RlfSBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgZm9yIGZ1bGwgZXJyb3JzLiBgO1xufVxuZXhwb3J0IHtcbiAgUmVkdWNlclR5cGUsXG4gIFNIT1VMRF9BVVRPQkFUQ0gsXG4gIFRhc2tBYm9ydEVycm9yLFxuICBUdXBsZSxcbiAgYWRkTGlzdGVuZXIsXG4gIGFzeW5jVGh1bmtDcmVhdG9yLFxuICBhdXRvQmF0Y2hFbmhhbmNlcixcbiAgYnVpbGRDcmVhdGVTbGljZSxcbiAgY2xlYXJBbGxMaXN0ZW5lcnMsXG4gIGNvbWJpbmVTbGljZXMsXG4gIGNvbmZpZ3VyZVN0b3JlLFxuICBjcmVhdGVBY3Rpb24sXG4gIGNyZWF0ZUFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlLFxuICBjcmVhdGVBc3luY1RodW5rLFxuICBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvcixcbiAgY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3JDcmVhdG9yLFxuICBjcmVhdGVEeW5hbWljTWlkZGxld2FyZSxcbiAgY3JlYXRlRW50aXR5QWRhcHRlcixcbiAgY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlLFxuICBjcmVhdGVMaXN0ZW5lck1pZGRsZXdhcmUsXG4gIHByb2R1Y2UgYXMgY3JlYXRlTmV4dFN0YXRlLFxuICBjcmVhdGVSZWR1Y2VyLFxuICBjcmVhdGVTZWxlY3RvcixcbiAgY3JlYXRlU2VsZWN0b3JDcmVhdG9yMiBhcyBjcmVhdGVTZWxlY3RvckNyZWF0b3IsXG4gIGNyZWF0ZVNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZSxcbiAgY3JlYXRlU2xpY2UsXG4gIGN1cnJlbnQzIGFzIGN1cnJlbnQsXG4gIGZpbmROb25TZXJpYWxpemFibGVWYWx1ZSxcbiAgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSxcbiAgZnJlZXplLFxuICBpc0FjdGlvbkNyZWF0b3IsXG4gIGlzQWxsT2YsXG4gIGlzQW55T2YsXG4gIGlzQXN5bmNUaHVua0FjdGlvbixcbiAgaXNEcmFmdDUgYXMgaXNEcmFmdCxcbiAgaXNGU0EgYXMgaXNGbHV4U3RhbmRhcmRBY3Rpb24sXG4gIGlzRnVsZmlsbGVkLFxuICBpc0ltbXV0YWJsZURlZmF1bHQsXG4gIGlzUGVuZGluZyxcbiAgaXNQbGFpbixcbiAgaXNSZWplY3RlZCxcbiAgaXNSZWplY3RlZFdpdGhWYWx1ZSxcbiAgbHJ1TWVtb2l6ZSxcbiAgbWluaVNlcmlhbGl6ZUVycm9yLFxuICBuYW5vaWQsXG4gIG9yaWdpbmFsMiBhcyBvcmlnaW5hbCxcbiAgcHJlcGFyZUF1dG9CYXRjaGVkLFxuICByZW1vdmVMaXN0ZW5lcixcbiAgdW53cmFwUmVzdWx0LFxuICB3ZWFrTWFwTWVtb2l6ZTIgYXMgd2Vha01hcE1lbW9pemVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWR1eC10b29sa2l0Lm1vZGVybi5tanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\n");

/***/ })

};
;